{"version":3,"sources":["webpack:///../../../sourceES6/core/XR/webXRTypes.ts","webpack:///../../../sourceES6/core/XR/webXRSessionManager.ts","webpack:///../../../sourceES6/core/XR/webXRManagedOutputCanvas.ts","webpack:///../../../sourceES6/core/XR/webXRExperienceHelper.ts","webpack:///../../../sourceES6/core/XR/webXRCamera.ts","webpack:///../../../../sourceES6/core/Meshes/Builders/sphereBuilder.ts","webpack:///../../../sourceES6/core/XR/webXRFeaturesManager.ts"],"names":["WebXRState","scene","_sessionEnded","baseLayer","currentTimestamp","defaultHeightCompensation","onXRFrameObservable","onXRReferenceSpaceChanged","onXRSessionEnded","onXRSessionInit","this","_referenceSpace","newReferenceSpace","notifyObservers","dispose","exitXRAsync","clear","session","end","catch","e","Warn","Promise","resolve","getRenderTargetTextureForEye","eye","_rttProvider","getRenderTargetForEye","getWebXRRenderTarget","options","engine","getEngine","_xrNavigator","xr","native","GetDefaults","canvasElement","getRenderingCanvas","undefined","initializeAsync","navigator","reject","initializeSessionAsync","xrSessionMode","xrSessionInit","requestSession","then","addEventListener","framebufferDimensionsObject","restoreDefaultFramebuffer","customAnimationFrameRequester","_renderLoop","once","isSessionSupportedAsync","sessionMode","WebXRSessionManager","IsSessionSupportedAsync","resetReferenceSpace","referenceSpace","baseReferenceSpace","runXRRenderLoop","requestAnimationFrame","bind","renderFunction","timestamp","xrFrame","currentFrame","getNativeRenderTargetProvider","_createRenderTargetTexture","framebufferWidth","framebufferHeight","framebuffer","window","cancelAnimationFrame","_frameHandler","setReferenceSpaceTypeAsync","referenceSpaceType","requestReferenceSpace","rejectionReason","Error","Log","heightCompensation","XRRigidTransform","x","y","z","getOffsetReferenceSpace","viewerReferenceSpace","updateRenderStateAsync","state","updateRenderState","functionToUse","isSessionSupported","supportsSession","call","result","returnValue","width","height","internalTexture","Unknown","_framebuffer","renderTargetTexture","_texture","defaults","WebXRManagedOutputCanvasOptions","canvasOptions","antialias","depth","stencil","isStencilEnable","alpha","multiview","framebufferScaleFactor","newCanvasCssStyle","_xrSessionManager","_options","_canvas","xrLayer","onXRLayerInitObservable","_engine","_setManagedOutputCanvas","canvas","document","createElement","style","cssText","add","_addCanvas","_removeCanvas","initializeXRLayerAsync","xrSession","createLayer","layer","XRWebGLLayer","canvasContext","makeXRCompatible","body","appendChild","_setCanvasSize","addOnce","contains","removeChild","init","setSize","_originalCanvasSize","offsetWidth","offsetHeight","getContext","_nonVRCamera","_originalSceneAutoClear","_supported","onInitialXRPoseSetObservable","onStateChangedObservable","NOT_IN_XR","sessionManager","camera","featuresManager","onDisposeObservable","CreateAsync","helper","WebXRExperienceHelper","_setState","activeCamera","enterXRAsync","renderTarget","sessionCreationOptions","ENTERING_XR","optionalFeatures","push","extendXRSessionInitObject","depthFar","maxZ","depthNear","minZ","autoClear","_nonXRToXRCamera","compensateOnFirstFrame","rigCameras","forEach","c","outputRenderTarget","setPosition","position","copyFrom","IN_XR","console","log","message","EXITING_XR","setTransformationFromNonVRCamera","val","name","Zero","_firstFrame","_referenceQuaternion","Identity","_referencedPosition","_xrInvPositionCache","_xrInvQuaternionCache","onBeforeCameraTeleport","onAfterCameraTeleport","_rotate180","rotationQuaternion","cameraRigMode","RIG_MODE_CUSTOM","updateUpVectorFromRotation","_updateNumberOfRigCameras","freezeProjectionMatrix","copyFromFloats","frame","_updateFromXRSession","_updateReferenceSpace","basePose","getViewerPose","transform","_updateForDualEyeDebugging","viewport","otherCamera","resetToBaseReferenceSpace","getScene","computeWorldMatrix","decompose","FromEulerAnglesToRef","toEulerAngles","getClassName","pose","pos","set","orientation","w","_scene","useRightHandedSystem","length","views","view","i","currentRig","isLeftCamera","isRightCamera","_isRightCamera","_isLeftCamera","multiplyInPlace","FromFloat32ArrayToRefScaled","projectionMatrix","_projectionMatrix","toggleProjectionMatrixHandInPlace","renderState","getViewport","viewCount","newCamera","isRigCamera","rigParent","removedCamera","pop","equals","subtractToRef","conjugateInPlace","multiplyToRef","_updateReferenceSpaceOffset","normalize","positionOffset","rotationOffset","ignoreHeight","negateInPlace","rotateByQuaternionToRef","transform2","CreateSphere","segments","diameterX","diameter","diameterY","diameterZ","arc","slice","sideOrientation","DEFAULTSIDE","radius","totalZRotationSteps","totalYRotationSteps","indices","positions","normals","uvs","zRotationStep","normalizedZ","angleZ","Math","PI","yRotationStep","normalizedY","angleY","rotationZ","RotationZ","rotationY","RotationY","afterRotZ","TransformCoordinates","Up","complete","vertex","multiply","normal","divide","verticesCount","firstIndex","_ComputeSides","frontUVs","backUVs","vertexData","updatable","SphereBuilder","sphere","_GetDefaultSideOrientation","_originalBuilderSideOrientation","applyToMesh","ANCHOR_SYSTEM","BACKGROUND_REMOVER","HIT_TEST","PHYSICS_CONTROLLERS","PLANE_DETECTION","POINTER_SELECTION","TELEPORTATION","FEATURE_POINTS","HAND_TRACKING","_features","getEnabledFeatures","featureName","feature","enabled","featureImplementation","attached","disableAutoAttach","attachFeature","detachFeature","AddWebXRFeature","constructorFunction","version","stable","_AvailableFeatures","latest","ConstructFeature","xrSessionManager","GetAvailableFeatures","Object","keys","GetAvailableVersions","GetLatestVersionOfFeature","GetStableVersionOfFeature","attach","detach","disableFeature","Name","enableFeature","moduleOptions","attachIfPossible","required","versionToLoad","WebXRFeaturesManager","isNaN","constructFunction","constructed","dependsOn","every","join","isCompatible","getEnabledFeature","nativeName","xrNativeFeatureName","requiredFeatures","indexOf"],"mappings":"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","file":"js/6.babylonBundle.js","sourcesContent":["import { Nullable } from \"../types\";\nimport { IDisposable } from \"../scene\";\n\n/**\n * States of the webXR experience\n */\nexport enum WebXRState {\n    /**\n     * Transitioning to being in XR mode\n     */\n    ENTERING_XR,\n    /**\n     * Transitioning to non XR mode\n     */\n    EXITING_XR,\n    /**\n     * In XR mode and presenting\n     */\n    IN_XR,\n    /**\n     * Not entered XR mode\n     */\n    NOT_IN_XR,\n}\n\n/**\n * Abstraction of the XR render target\n */\nexport interface WebXRRenderTarget extends IDisposable {\n    /**\n     * xrpresent context of the canvas which can be used to display/mirror xr content\n     */\n    canvasContext: WebGLRenderingContext;\n\n    /**\n     * xr layer for the canvas\n     */\n    xrLayer: Nullable<XRWebGLLayer>;\n\n    /**\n     * Initializes the xr layer for the session\n     * @param xrSession xr session\n     * @returns a promise that will resolve once the XR Layer has been created\n     */\n    initializeXRLayerAsync(xrSession: XRSession): Promise<XRWebGLLayer>;\n}\n","import { Logger } from \"../Misc/logger\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Nullable } from \"../types\";\r\nimport { IDisposable, Scene } from \"../scene\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { WebXRRenderTarget } from \"./webXRTypes\";\r\nimport { WebXRManagedOutputCanvas, WebXRManagedOutputCanvasOptions } from \"./webXRManagedOutputCanvas\";\r\n\r\ninterface IRenderTargetProvider {\r\n    getRenderTargetForEye(eye: XREye): RenderTargetTexture;\r\n}\r\n\r\n/**\r\n * Manages an XRSession to work with Babylon's engine\r\n * @see https://doc.babylonjs.com/how_to/webxr_session_manager\r\n */\r\nexport class WebXRSessionManager implements IDisposable {\r\n    private _referenceSpace: XRReferenceSpace;\r\n    private _rttProvider: Nullable<IRenderTargetProvider>;\r\n    private _sessionEnded: boolean = false;\r\n    private _xrNavigator: any;\r\n    private baseLayer: Nullable<XRWebGLLayer> = null;\r\n\r\n    /**\r\n     * The base reference space from which the session started. good if you want to reset your\r\n     * reference space\r\n     */\r\n    public baseReferenceSpace: XRReferenceSpace;\r\n    /**\r\n     * Current XR frame\r\n     */\r\n    public currentFrame: Nullable<XRFrame>;\r\n    /** WebXR timestamp updated every frame */\r\n    public currentTimestamp: number = -1;\r\n    /**\r\n     * Used just in case of a failure to initialize an immersive session.\r\n     * The viewer reference space is compensated using this height, creating a kind of \"viewer-floor\" reference space\r\n     */\r\n    public defaultHeightCompensation = 1.7;\r\n    /**\r\n     * Fires every time a new xrFrame arrives which can be used to update the camera\r\n     */\r\n    public onXRFrameObservable: Observable<XRFrame> = new Observable<XRFrame>();\r\n    /**\r\n     * Fires when the reference space changed\r\n     */\r\n    public onXRReferenceSpaceChanged: Observable<XRReferenceSpace> = new Observable();\r\n    /**\r\n     * Fires when the xr session is ended either by the device or manually done\r\n     */\r\n    public onXRSessionEnded: Observable<any> = new Observable<any>();\r\n    /**\r\n     * Fires when the xr session is ended either by the device or manually done\r\n     */\r\n    public onXRSessionInit: Observable<XRSession> = new Observable<XRSession>();\r\n    /**\r\n     * Underlying xr session\r\n     */\r\n    public session: XRSession;\r\n    /**\r\n     * The viewer (head position) reference space. This can be used to get the XR world coordinates\r\n     * or get the offset the player is currently at.\r\n     */\r\n    public viewerReferenceSpace: XRReferenceSpace;\r\n\r\n    /**\r\n     * Constructs a WebXRSessionManager, this must be initialized within a user action before usage\r\n     * @param scene The scene which the session should be created for\r\n     */\r\n    constructor(\r\n        /** The scene which the session should be created for */\r\n        public scene: Scene\r\n    ) {}\r\n\r\n    /**\r\n     * The current reference space used in this session. This reference space can constantly change!\r\n     * It is mainly used to offset the camera's position.\r\n     */\r\n    public get referenceSpace(): XRReferenceSpace {\r\n        return this._referenceSpace;\r\n    }\r\n\r\n    /**\r\n     * Set a new reference space and triggers the observable\r\n     */\r\n    public set referenceSpace(newReferenceSpace: XRReferenceSpace) {\r\n        this._referenceSpace = newReferenceSpace;\r\n        this.onXRReferenceSpaceChanged.notifyObservers(this._referenceSpace);\r\n    }\r\n\r\n    /**\r\n     * Disposes of the session manager\r\n     */\r\n    public dispose() {\r\n        // disposing without leaving XR? Exit XR first\r\n        if (!this._sessionEnded) {\r\n            this.exitXRAsync();\r\n        }\r\n        this.onXRFrameObservable.clear();\r\n        this.onXRSessionEnded.clear();\r\n        this.onXRReferenceSpaceChanged.clear();\r\n        this.onXRSessionInit.clear();\r\n    }\r\n\r\n    /**\r\n     * Stops the xrSession and restores the render loop\r\n     * @returns Promise which resolves after it exits XR\r\n     */\r\n    public exitXRAsync() {\r\n        if (this.session && !this._sessionEnded) {\r\n            this._sessionEnded = true;\r\n            return this.session.end().catch((e) => {\r\n                Logger.Warn(\"Could not end XR session.\");\r\n            });\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Gets the correct render target texture to be rendered this frame for this eye\r\n     * @param eye the eye for which to get the render target\r\n     * @returns the render target for the specified eye\r\n     */\r\n    public getRenderTargetTextureForEye(eye: XREye): RenderTargetTexture {\r\n        return this._rttProvider!.getRenderTargetForEye(eye);\r\n    }\r\n\r\n    /**\r\n     * Creates a WebXRRenderTarget object for the XR session\r\n     * @param onStateChangedObservable optional, mechanism for enabling/disabling XR rendering canvas, used only on Web\r\n     * @param options optional options to provide when creating a new render target\r\n     * @returns a WebXR render target to which the session can render\r\n     */\r\n    public getWebXRRenderTarget(options?: WebXRManagedOutputCanvasOptions): WebXRRenderTarget {\r\n        const engine = this.scene.getEngine();\r\n        if (this._xrNavigator.xr.native) {\r\n            return this._xrNavigator.xr.getWebXRRenderTarget(engine);\r\n        } else {\r\n            options = options || WebXRManagedOutputCanvasOptions.GetDefaults(engine);\r\n            options.canvasElement = engine.getRenderingCanvas() || undefined;\r\n            return new WebXRManagedOutputCanvas(this, options);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes the manager\r\n     * After initialization enterXR can be called to start an XR session\r\n     * @returns Promise which resolves after it is initialized\r\n     */\r\n    public initializeAsync(): Promise<void> {\r\n        // Check if the browser supports webXR\r\n        this._xrNavigator = navigator;\r\n        if (!this._xrNavigator.xr) {\r\n            return Promise.reject(\"WebXR not available\");\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Initializes an xr session\r\n     * @param xrSessionMode mode to initialize\r\n     * @param xrSessionInit defines optional and required values to pass to the session builder\r\n     * @returns a promise which will resolve once the session has been initialized\r\n     */\r\n    public initializeSessionAsync(xrSessionMode: XRSessionMode = \"immersive-vr\", xrSessionInit: XRSessionInit = {}): Promise<XRSession> {\r\n        return this._xrNavigator.xr.requestSession(xrSessionMode, xrSessionInit).then((session: XRSession) => {\r\n            this.session = session;\r\n            this.onXRSessionInit.notifyObservers(session);\r\n            this._sessionEnded = false;\r\n\r\n            // handle when the session is ended (By calling session.end or device ends its own session eg. pressing home button on phone)\r\n            this.session.addEventListener(\r\n                \"end\",\r\n                () => {\r\n                    const engine = this.scene.getEngine();\r\n                    this._sessionEnded = true;\r\n                    // Remove render target texture and notify frame observers\r\n                    this._rttProvider = null;\r\n                    // make sure dimensions object is restored\r\n                    engine.framebufferDimensionsObject = null;\r\n\r\n                    // Restore frame buffer to avoid clear on xr framebuffer after session end\r\n                    engine.restoreDefaultFramebuffer();\r\n\r\n                    // Need to restart render loop as after the session is ended the last request for new frame will never call callback\r\n                    engine.customAnimationFrameRequester = null;\r\n                    this.onXRSessionEnded.notifyObservers(null);\r\n                    engine._renderLoop();\r\n                },\r\n                { once: true }\r\n            );\r\n            return this.session;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Checks if a session would be supported for the creation options specified\r\n     * @param sessionMode session mode to check if supported eg. immersive-vr\r\n     * @returns A Promise that resolves to true if supported and false if not\r\n     */\r\n    public isSessionSupportedAsync(sessionMode: XRSessionMode): Promise<boolean> {\r\n        return WebXRSessionManager.IsSessionSupportedAsync(sessionMode);\r\n    }\r\n\r\n    /**\r\n     * Resets the reference space to the one started the session\r\n     */\r\n    public resetReferenceSpace() {\r\n        this.referenceSpace = this.baseReferenceSpace;\r\n    }\r\n\r\n    /**\r\n     * Starts rendering to the xr layer\r\n     */\r\n    public runXRRenderLoop() {\r\n        const engine = this.scene.getEngine();\r\n        // Tell the engine's render loop to be driven by the xr session's refresh rate and provide xr pose information\r\n        engine.customAnimationFrameRequester = {\r\n            requestAnimationFrame: this.session.requestAnimationFrame.bind(this.session),\r\n            renderFunction: (timestamp: number, xrFrame: Nullable<XRFrame>) => {\r\n                if (this._sessionEnded) {\r\n                    return;\r\n                }\r\n                // Store the XR frame and timestamp in the session manager\r\n                this.currentFrame = xrFrame;\r\n                this.currentTimestamp = timestamp;\r\n                if (xrFrame) {\r\n                    engine.framebufferDimensionsObject = this.baseLayer!;\r\n                    this.onXRFrameObservable.notifyObservers(xrFrame);\r\n                    engine._renderLoop();\r\n                    engine.framebufferDimensionsObject = null;\r\n                }\r\n            },\r\n        };\r\n\r\n        if (this._xrNavigator.xr.native) {\r\n            this._rttProvider = this._xrNavigator.xr.getNativeRenderTargetProvider(this.session, this._createRenderTargetTexture.bind(this));\r\n        } else {\r\n            // Create render target texture from xr's webgl render target\r\n            const rtt = this._createRenderTargetTexture(this.baseLayer!.framebufferWidth, this.baseLayer!.framebufferHeight, this.baseLayer!.framebuffer);\r\n            this._rttProvider = { getRenderTargetForEye: () => rtt };\r\n            engine.framebufferDimensionsObject = this.baseLayer;\r\n        }\r\n\r\n        // Stop window's animation frame and trigger sessions animation frame\r\n        if (typeof window !== \"undefined\" && window.cancelAnimationFrame) {\r\n            window.cancelAnimationFrame(engine._frameHandler);\r\n        }\r\n        engine._renderLoop();\r\n    }\r\n\r\n    /**\r\n     * Sets the reference space on the xr session\r\n     * @param referenceSpaceType space to set\r\n     * @returns a promise that will resolve once the reference space has been set\r\n     */\r\n    public setReferenceSpaceTypeAsync(referenceSpaceType: XRReferenceSpaceType = \"local-floor\"): Promise<XRReferenceSpace> {\r\n        return this.session\r\n            .requestReferenceSpace(referenceSpaceType)\r\n            .then(\r\n                (referenceSpace: XRReferenceSpace) => {\r\n                    return referenceSpace;\r\n                },\r\n                (rejectionReason) => {\r\n                    Logger.Error(\"XR.requestReferenceSpace failed for the following reason: \");\r\n                    Logger.Error(rejectionReason);\r\n                    Logger.Log('Defaulting to universally-supported \"viewer\" reference space type.');\r\n\r\n                    return this.session.requestReferenceSpace(\"viewer\").then(\r\n                        (referenceSpace: XRReferenceSpace) => {\r\n                            const heightCompensation = new XRRigidTransform({ x: 0, y: -this.defaultHeightCompensation, z: 0 });\r\n                            return referenceSpace.getOffsetReferenceSpace(heightCompensation);\r\n                        },\r\n                        (rejectionReason) => {\r\n                            Logger.Error(rejectionReason);\r\n                            throw 'XR initialization failed: required \"viewer\" reference space type not supported.';\r\n                        }\r\n                    );\r\n                }\r\n            )\r\n            .then((referenceSpace) => {\r\n                // create viewer reference space before setting the first reference space\r\n                return this.session.requestReferenceSpace(\"viewer\").then((viewerReferenceSpace: XRReferenceSpace) => {\r\n                    this.viewerReferenceSpace = viewerReferenceSpace;\r\n                    return referenceSpace;\r\n                });\r\n            })\r\n            .then((referenceSpace) => {\r\n                // initialize the base and offset (currently the same)\r\n                this.referenceSpace = this.baseReferenceSpace = referenceSpace;\r\n                return this.referenceSpace;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Updates the render state of the session\r\n     * @param state state to set\r\n     * @returns a promise that resolves once the render state has been updated\r\n     */\r\n    public updateRenderStateAsync(state: XRRenderState) {\r\n        if (state.baseLayer) {\r\n            this.baseLayer = state.baseLayer;\r\n        }\r\n        return this.session.updateRenderState(state);\r\n    }\r\n\r\n    /**\r\n     * Returns a promise that resolves with a boolean indicating if the provided session mode is supported by this browser\r\n     * @param sessionMode defines the session to test\r\n     * @returns a promise with boolean as final value\r\n     */\r\n    public static IsSessionSupportedAsync(sessionMode: XRSessionMode): Promise<boolean> {\r\n        if (!(navigator as any).xr) {\r\n            return Promise.resolve(false);\r\n        }\r\n        // When the specs are final, remove supportsSession!\r\n        const functionToUse = (navigator as any).xr.isSessionSupported || (navigator as any).xr.supportsSession;\r\n        if (!functionToUse) {\r\n            return Promise.resolve(false);\r\n        } else {\r\n            return functionToUse\r\n                .call((navigator as any).xr, sessionMode)\r\n                .then((result: boolean) => {\r\n                    const returnValue = typeof result === \"undefined\" ? true : result;\r\n                    return Promise.resolve(returnValue);\r\n                })\r\n                .catch((e: any) => {\r\n                    Logger.Warn(e);\r\n                    return Promise.resolve(false);\r\n                });\r\n        }\r\n    }\r\n\r\n    private _createRenderTargetTexture(width: number, height: number, framebuffer: Nullable<WebGLFramebuffer> = null) {\r\n        // Create internal texture\r\n        var internalTexture = new InternalTexture(this.scene.getEngine(), InternalTextureSource.Unknown, true);\r\n        internalTexture.width = width;\r\n        internalTexture.height = height;\r\n        internalTexture._framebuffer = framebuffer;\r\n\r\n        // Create render target texture from the internal texture\r\n        var renderTargetTexture = new RenderTargetTexture(\"XR renderTargetTexture\", { width: width, height: height }, this.scene, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, true);\r\n        renderTargetTexture._texture = internalTexture;\r\n\r\n        return renderTargetTexture;\r\n    }\r\n}\r\n","import { Nullable } from \"../types\";\r\nimport { ThinEngine } from \"../Engines/thinEngine\";\r\nimport { WebXRRenderTarget } from \"./webXRTypes\";\r\nimport { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport { Observable } from \"../Misc/observable\";\r\n\r\n/**\r\n * COnfiguration object for WebXR output canvas\r\n */\r\nexport class WebXRManagedOutputCanvasOptions {\r\n    /**\r\n     * An optional canvas in case you wish to create it yourself and provide it here.\r\n     * If not provided, a new canvas will be created\r\n     */\r\n    public canvasElement?: HTMLCanvasElement;\r\n    /**\r\n     * Options for this XR Layer output\r\n     */\r\n    public canvasOptions?: XRWebGLLayerOptions;\r\n    /**\r\n     * CSS styling for a newly created canvas (if not provided)\r\n     */\r\n    public newCanvasCssStyle?: string;\r\n\r\n    /**\r\n     * Get the default values of the configuration object\r\n     * @param engine defines the engine to use (can be null)\r\n     * @returns default values of this configuration object\r\n     */\r\n    public static GetDefaults(engine?: ThinEngine): WebXRManagedOutputCanvasOptions {\r\n        const defaults = new WebXRManagedOutputCanvasOptions();\r\n        defaults.canvasOptions = {\r\n            antialias: true,\r\n            depth: true,\r\n            stencil: engine ? engine.isStencilEnable : true,\r\n            alpha: true,\r\n            multiview: false,\r\n            framebufferScaleFactor: 1,\r\n        };\r\n\r\n        defaults.newCanvasCssStyle = \"position:absolute; bottom:0px;right:0px;z-index:10;width:90%;height:100%;background-color: #000000;\";\r\n\r\n        return defaults;\r\n    }\r\n}\r\n/**\r\n * Creates a canvas that is added/removed from the webpage when entering/exiting XR\r\n */\r\nexport class WebXRManagedOutputCanvas implements WebXRRenderTarget {\r\n    private _canvas: Nullable<HTMLCanvasElement> = null;\r\n    private _engine: ThinEngine;\r\n    private _originalCanvasSize: {\r\n        width: number;\r\n        height: number;\r\n    };\r\n\r\n    /**\r\n     * Rendering context of the canvas which can be used to display/mirror xr content\r\n     */\r\n    public canvasContext: WebGLRenderingContext;\r\n    /**\r\n     * xr layer for the canvas\r\n     */\r\n    public xrLayer: Nullable<XRWebGLLayer> = null;\r\n\r\n    /**\r\n     * Obseervers registered here will be triggered when the xr layer was initialized\r\n     */\r\n    public onXRLayerInitObservable: Observable<XRWebGLLayer> = new Observable();\r\n\r\n    /**\r\n     * Initializes the canvas to be added/removed upon entering/exiting xr\r\n     * @param _xrSessionManager The XR Session manager\r\n     * @param _options optional configuration for this canvas output. defaults will be used if not provided\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager, private _options: WebXRManagedOutputCanvasOptions = WebXRManagedOutputCanvasOptions.GetDefaults()) {\r\n        this._engine = _xrSessionManager.scene.getEngine();\r\n        if (!_options.canvasElement) {\r\n            const canvas = document.createElement(\"canvas\");\r\n            canvas.style.cssText = this._options.newCanvasCssStyle || \"position:absolute; bottom:0px;right:0px;\";\r\n            this._setManagedOutputCanvas(canvas);\r\n        } else {\r\n            this._setManagedOutputCanvas(_options.canvasElement);\r\n        }\r\n\r\n        _xrSessionManager.onXRSessionInit.add(() => {\r\n            this._addCanvas();\r\n        });\r\n\r\n        _xrSessionManager.onXRSessionEnded.add(() => {\r\n            this._removeCanvas();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Disposes of the object\r\n     */\r\n    public dispose() {\r\n        this._removeCanvas();\r\n        this._setManagedOutputCanvas(null);\r\n    }\r\n\r\n    /**\r\n     * Initializes the xr layer for the session\r\n     * @param xrSession xr session\r\n     * @returns a promise that will resolve once the XR Layer has been created\r\n     */\r\n    public initializeXRLayerAsync(xrSession: XRSession): Promise<XRWebGLLayer> {\r\n        const createLayer = () => {\r\n            const layer = new XRWebGLLayer(xrSession, this.canvasContext, this._options.canvasOptions);\r\n            this.onXRLayerInitObservable.notifyObservers(layer);\r\n            return layer;\r\n        };\r\n\r\n        // support canvases without makeXRCompatible\r\n        if (!(this.canvasContext as any).makeXRCompatible) {\r\n            this.xrLayer = createLayer();\r\n            return Promise.resolve(this.xrLayer);\r\n        }\r\n\r\n        return (this.canvasContext as any).makeXRCompatible().then(() => {\r\n            this.xrLayer = createLayer();\r\n            return this.xrLayer;\r\n        });\r\n    }\r\n\r\n    private _addCanvas() {\r\n        if (this._canvas && this._canvas !== this._engine.getRenderingCanvas()) {\r\n            document.body.appendChild(this._canvas);\r\n        }\r\n        if (this.xrLayer) {\r\n            this._setCanvasSize(true);\r\n        } else {\r\n            this.onXRLayerInitObservable.addOnce((layer) => {\r\n                this._setCanvasSize(true, layer);\r\n            });\r\n        }\r\n    }\r\n\r\n    private _removeCanvas() {\r\n        if (this._canvas && document.body.contains(this._canvas) && this._canvas !== this._engine.getRenderingCanvas()) {\r\n            document.body.removeChild(this._canvas);\r\n        }\r\n        this._setCanvasSize(false);\r\n    }\r\n\r\n    private _setCanvasSize(init: boolean = true, xrLayer = this.xrLayer) {\r\n        if (!this._canvas) {\r\n            return;\r\n        }\r\n        if (init) {\r\n            if (xrLayer) {\r\n                if (this._canvas !== this._engine.getRenderingCanvas()) {\r\n                    this._canvas.style.width = xrLayer.framebufferWidth + \"px\";\r\n                    this._canvas.style.height = xrLayer.framebufferHeight + \"px\";\r\n                } else {\r\n                    this._engine.setSize(xrLayer.framebufferWidth, xrLayer.framebufferHeight);\r\n                }\r\n            }\r\n        } else {\r\n            if (this._originalCanvasSize) {\r\n                if (this._canvas !== this._engine.getRenderingCanvas()) {\r\n                    this._canvas.style.width = this._originalCanvasSize.width + \"px\";\r\n                    this._canvas.style.height = this._originalCanvasSize.height + \"px\";\r\n                } else {\r\n                    this._engine.setSize(this._originalCanvasSize.width, this._originalCanvasSize.height);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _setManagedOutputCanvas(canvas: Nullable<HTMLCanvasElement>) {\r\n        this._removeCanvas();\r\n        if (!canvas) {\r\n            this._canvas = null;\r\n            (this.canvasContext as any) = null;\r\n        } else {\r\n            this._originalCanvasSize = {\r\n                width: canvas.offsetWidth,\r\n                height: canvas.offsetHeight,\r\n            };\r\n            this._canvas = canvas;\r\n            this.canvasContext = <any>this._canvas.getContext(\"webgl2\");\r\n            if (!this.canvasContext) {\r\n                this.canvasContext = <any>this._canvas.getContext(\"webgl\");\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { Nullable } from \"../types\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { IDisposable, Scene } from \"../scene\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport { WebXRCamera } from \"./webXRCamera\";\r\nimport { WebXRState, WebXRRenderTarget } from \"./webXRTypes\";\r\nimport { WebXRFeaturesManager } from \"./webXRFeaturesManager\";\r\nimport { Logger } from \"../Misc/logger\";\r\n\r\n/**\r\n * Base set of functionality needed to create an XR experience (WebXRSessionManager, Camera, StateManagement, etc.)\r\n * @see https://doc.babylonjs.com/how_to/webxr_experience_helpers\r\n */\r\nexport class WebXRExperienceHelper implements IDisposable {\r\n    private _nonVRCamera: Nullable<Camera> = null;\r\n    private _originalSceneAutoClear = true;\r\n    private _supported = false;\r\n\r\n    /**\r\n     * Camera used to render xr content\r\n     */\r\n    public camera: WebXRCamera;\r\n    /** A features manager for this xr session */\r\n    public featuresManager: WebXRFeaturesManager;\r\n    /**\r\n     * Observers registered here will be triggered after the camera's initial transformation is set\r\n     * This can be used to set a different ground level or an extra rotation.\r\n     *\r\n     * Note that ground level is considered to be at 0. The height defined by the XR camera will be added\r\n     * to the position set after this observable is done executing.\r\n     */\r\n    public onInitialXRPoseSetObservable = new Observable<WebXRCamera>();\r\n    /**\r\n     * Fires when the state of the experience helper has changed\r\n     */\r\n    public onStateChangedObservable = new Observable<WebXRState>();\r\n    /** Session manager used to keep track of xr session */\r\n    public sessionManager: WebXRSessionManager;\r\n    /**\r\n     * The current state of the XR experience (eg. transitioning, in XR or not in XR)\r\n     */\r\n    public state: WebXRState = WebXRState.NOT_IN_XR;\r\n\r\n    /**\r\n     * Creates a WebXRExperienceHelper\r\n     * @param scene The scene the helper should be created in\r\n     */\r\n    private constructor(private scene: Scene) {\r\n        this.sessionManager = new WebXRSessionManager(scene);\r\n        this.camera = new WebXRCamera(\"\", scene, this.sessionManager);\r\n        this.featuresManager = new WebXRFeaturesManager(this.sessionManager);\r\n\r\n        scene.onDisposeObservable.add(() => {\r\n            this.exitXRAsync();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates the experience helper\r\n     * @param scene the scene to attach the experience helper to\r\n     * @returns a promise for the experience helper\r\n     */\r\n    public static CreateAsync(scene: Scene): Promise<WebXRExperienceHelper> {\r\n        var helper = new WebXRExperienceHelper(scene);\r\n        return helper.sessionManager\r\n            .initializeAsync()\r\n            .then(() => {\r\n                helper._supported = true;\r\n                return helper;\r\n            })\r\n            .catch((e) => {\r\n                helper._setState(WebXRState.NOT_IN_XR);\r\n                helper.dispose();\r\n                throw e;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Disposes of the experience helper\r\n     */\r\n    public dispose() {\r\n        this.camera.dispose();\r\n        this.onStateChangedObservable.clear();\r\n        this.onInitialXRPoseSetObservable.clear();\r\n        this.sessionManager.dispose();\r\n        if (this._nonVRCamera) {\r\n            this.scene.activeCamera = this._nonVRCamera;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enters XR mode (This must be done within a user interaction in most browsers eg. button click)\r\n     * @param sessionMode options for the XR session\r\n     * @param referenceSpaceType frame of reference of the XR session\r\n     * @param renderTarget the output canvas that will be used to enter XR mode\r\n     * @param sessionCreationOptions optional XRSessionInit object to init the session with\r\n     * @returns promise that resolves after xr mode has entered\r\n     */\r\n    public enterXRAsync(sessionMode: XRSessionMode, referenceSpaceType: XRReferenceSpaceType, renderTarget: WebXRRenderTarget = this.sessionManager.getWebXRRenderTarget(), sessionCreationOptions: XRSessionInit = {}): Promise<WebXRSessionManager> {\r\n        if (!this._supported) {\r\n            throw \"WebXR not supported in this browser or environment\";\r\n        }\r\n        this._setState(WebXRState.ENTERING_XR);\r\n        if (referenceSpaceType !== \"viewer\" && referenceSpaceType !== \"local\") {\r\n            sessionCreationOptions.optionalFeatures = sessionCreationOptions.optionalFeatures || [];\r\n            sessionCreationOptions.optionalFeatures.push(referenceSpaceType);\r\n        }\r\n        this.featuresManager.extendXRSessionInitObject(sessionCreationOptions);\r\n        // we currently recommend \"unbounded\" space in AR (#7959)\r\n        if (sessionMode === \"immersive-ar\" && referenceSpaceType !== \"unbounded\") {\r\n            Logger.Warn(\"We recommend using 'unbounded' reference space type when using 'immersive-ar' session mode\");\r\n        }\r\n        // make sure that the session mode is supported\r\n        return this.sessionManager\r\n            .initializeSessionAsync(sessionMode, sessionCreationOptions)\r\n            .then(() => {\r\n                return this.sessionManager.setReferenceSpaceTypeAsync(referenceSpaceType);\r\n            })\r\n            .then(() => {\r\n                return renderTarget.initializeXRLayerAsync(this.sessionManager.session);\r\n            })\r\n            .then(() => {\r\n                return this.sessionManager.updateRenderStateAsync({\r\n                    depthFar: this.camera.maxZ,\r\n                    depthNear: this.camera.minZ,\r\n                    baseLayer: renderTarget.xrLayer!,\r\n                });\r\n            })\r\n            .then(() => {\r\n                // run the render loop\r\n                this.sessionManager.runXRRenderLoop();\r\n                // Cache pre xr scene settings\r\n                this._originalSceneAutoClear = this.scene.autoClear;\r\n                this._nonVRCamera = this.scene.activeCamera;\r\n\r\n                this.scene.activeCamera = this.camera;\r\n                // do not compensate when AR session is used\r\n                if (sessionMode !== \"immersive-ar\") {\r\n                    this._nonXRToXRCamera();\r\n                } else {\r\n                    // Kept here, TODO - check if needed\r\n                    this.scene.autoClear = false;\r\n                    this.camera.compensateOnFirstFrame = false;\r\n                }\r\n\r\n                this.sessionManager.onXRSessionEnded.addOnce(() => {\r\n                    // Reset camera rigs output render target to ensure sessions render target is not drawn after it ends\r\n                    this.camera.rigCameras.forEach((c) => {\r\n                        c.outputRenderTarget = null;\r\n                    });\r\n\r\n                    // Restore scene settings\r\n                    this.scene.autoClear = this._originalSceneAutoClear;\r\n                    this.scene.activeCamera = this._nonVRCamera;\r\n                    if (sessionMode !== \"immersive-ar\" && this.camera.compensateOnFirstFrame) {\r\n                        if ((<any>this._nonVRCamera).setPosition) {\r\n                            (<any>this._nonVRCamera).setPosition(this.camera.position);\r\n                        } else {\r\n                            this._nonVRCamera!.position.copyFrom(this.camera.position);\r\n                        }\r\n                    }\r\n\r\n                    this._setState(WebXRState.NOT_IN_XR);\r\n                });\r\n\r\n                // Wait until the first frame arrives before setting state to in xr\r\n                this.sessionManager.onXRFrameObservable.addOnce(() => {\r\n                    this._setState(WebXRState.IN_XR);\r\n                });\r\n\r\n                return this.sessionManager;\r\n            })\r\n            .catch((e: any) => {\r\n                console.log(e);\r\n                console.log(e.message);\r\n                this._setState(WebXRState.NOT_IN_XR);\r\n                throw e;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Exits XR mode and returns the scene to its original state\r\n     * @returns promise that resolves after xr mode has exited\r\n     */\r\n    public exitXRAsync() {\r\n        // only exit if state is IN_XR\r\n        if (this.state !== WebXRState.IN_XR) {\r\n            return Promise.resolve();\r\n        }\r\n        this._setState(WebXRState.EXITING_XR);\r\n        return this.sessionManager.exitXRAsync();\r\n    }\r\n\r\n    private _nonXRToXRCamera() {\r\n        this.camera.setTransformationFromNonVRCamera(this._nonVRCamera!);\r\n        this.onInitialXRPoseSetObservable.notifyObservers(this.camera);\r\n    }\r\n\r\n    private _setState(val: WebXRState) {\r\n        if (this.state === val) {\r\n            return;\r\n        }\r\n        this.state = val;\r\n        this.onStateChangedObservable.notifyObservers(this.state);\r\n    }\r\n}\r\n","import { Vector3, Matrix, Quaternion } from \"../Maths/math.vector\";\r\nimport { Scene } from \"../scene\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { FreeCamera } from \"../Cameras/freeCamera\";\r\nimport { TargetCamera } from \"../Cameras/targetCamera\";\r\nimport { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport { Viewport } from \"../Maths/math.viewport\";\r\nimport { Observable } from \"../Misc/observable\";\r\n\r\n/**\r\n * WebXR Camera which holds the views for the xrSession\r\n * @see https://doc.babylonjs.com/how_to/webxr_camera\r\n */\r\nexport class WebXRCamera extends FreeCamera {\r\n    private _firstFrame = false;\r\n    private _referenceQuaternion: Quaternion = Quaternion.Identity();\r\n    private _referencedPosition: Vector3 = new Vector3();\r\n    private _xrInvPositionCache: Vector3 = new Vector3();\r\n    private _xrInvQuaternionCache = Quaternion.Identity();\r\n\r\n    /**\r\n     * Observable raised before camera teleportation\r\n     */\r\n    public onBeforeCameraTeleport = new Observable<Vector3>();\r\n\r\n    /**\r\n     *  Observable raised after camera teleportation\r\n     */\r\n    public onAfterCameraTeleport = new Observable<Vector3>();\r\n\r\n    /**\r\n     * Should position compensation execute on first frame.\r\n     * This is used when copying the position from a native (non XR) camera\r\n     */\r\n    public compensateOnFirstFrame: boolean = true;\r\n\r\n    /**\r\n     * Creates a new webXRCamera, this should only be set at the camera after it has been updated by the xrSessionManager\r\n     * @param name the name of the camera\r\n     * @param scene the scene to add the camera to\r\n     * @param _xrSessionManager a constructed xr session manager\r\n     */\r\n    constructor(name: string, scene: Scene, private _xrSessionManager: WebXRSessionManager) {\r\n        super(name, Vector3.Zero(), scene);\r\n\r\n        // Initial camera configuration\r\n        this.minZ = 0.1;\r\n        this.rotationQuaternion = new Quaternion();\r\n        this.cameraRigMode = Camera.RIG_MODE_CUSTOM;\r\n        this.updateUpVectorFromRotation = true;\r\n        this._updateNumberOfRigCameras(1);\r\n        // freeze projection matrix, which will be copied later\r\n        this.freezeProjectionMatrix();\r\n\r\n        this._xrSessionManager.onXRSessionInit.add(() => {\r\n            this._referencedPosition.copyFromFloats(0, 0, 0);\r\n            this._referenceQuaternion.copyFromFloats(0, 0, 0, 1);\r\n            // first frame - camera's y position should be 0 for the correct offset\r\n            this._firstFrame = this.compensateOnFirstFrame;\r\n        });\r\n\r\n        // Check transformation changes on each frame. Callback is added to be first so that the transformation will be\r\n        // applied to the rest of the elements using the referenceSpace object\r\n        this._xrSessionManager.onXRFrameObservable.add(\r\n            (frame) => {\r\n                if (this._firstFrame) {\r\n                    this._updateFromXRSession();\r\n                }\r\n                this._updateReferenceSpace();\r\n                this._updateFromXRSession();\r\n            },\r\n            undefined,\r\n            true\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Return the user's height, unrelated to the current ground.\r\n     * This will be the y position of this camera, when ground level is 0.\r\n     */\r\n    public get realWorldHeight(): number {\r\n        const basePose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.baseReferenceSpace);\r\n        if (basePose && basePose.transform) {\r\n            return basePose.transform.position.y;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _updateForDualEyeDebugging(/*pupilDistance = 0.01*/) {\r\n        // Create initial camera rigs\r\n        this._updateNumberOfRigCameras(2);\r\n        this.rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1.0);\r\n        // this.rigCameras[0].position.x = -pupilDistance / 2;\r\n        this.rigCameras[0].outputRenderTarget = null;\r\n        this.rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1.0);\r\n        // this.rigCameras[1].position.x = pupilDistance / 2;\r\n        this.rigCameras[1].outputRenderTarget = null;\r\n    }\r\n\r\n    /**\r\n     * Sets this camera's transformation based on a non-vr camera\r\n     * @param otherCamera the non-vr camera to copy the transformation from\r\n     * @param resetToBaseReferenceSpace should XR reset to the base reference space\r\n     */\r\n    public setTransformationFromNonVRCamera(otherCamera: Camera = this.getScene().activeCamera!, resetToBaseReferenceSpace: boolean = true) {\r\n        if (!otherCamera || otherCamera === this) {\r\n            return;\r\n        }\r\n        const mat = otherCamera.computeWorldMatrix();\r\n        mat.decompose(undefined, this.rotationQuaternion, this.position);\r\n        // set the ground level\r\n        this.position.y = 0;\r\n        Quaternion.FromEulerAnglesToRef(0, this.rotationQuaternion.toEulerAngles().y, 0, this.rotationQuaternion);\r\n        this._firstFrame = true;\r\n        if (resetToBaseReferenceSpace) {\r\n            this._xrSessionManager.resetReferenceSpace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the current instance class name (\"WebXRCamera\").\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"WebXRCamera\";\r\n    }\r\n\r\n    private _rotate180 = new Quaternion(0, 1, 0, 0);\r\n\r\n    private _updateFromXRSession() {\r\n        const pose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.referenceSpace);\r\n\r\n        if (!pose) {\r\n            return;\r\n        }\r\n\r\n        if (pose.transform) {\r\n            const pos = pose.transform.position;\r\n            this._referencedPosition.set(pos.x, pos.y, pos.z);\r\n            const orientation = pose.transform.orientation;\r\n\r\n            this._referenceQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);\r\n            if (!this._scene.useRightHandedSystem) {\r\n                this._referencedPosition.z *= -1;\r\n                this._referenceQuaternion.z *= -1;\r\n                this._referenceQuaternion.w *= -1;\r\n            }\r\n\r\n            if (this._firstFrame) {\r\n                this._firstFrame = false;\r\n                // we have the XR reference, now use this to find the offset to get the camera to be\r\n                // in the right position\r\n\r\n                // set the height to correlate to the current height\r\n                this.position.y += this._referencedPosition.y;\r\n                // avoid using the head rotation on the first frame.\r\n                this._referenceQuaternion.copyFromFloats(0, 0, 0, 1);\r\n            } else {\r\n                // update position and rotation as reference\r\n                this.rotationQuaternion.copyFrom(this._referenceQuaternion);\r\n                this.position.copyFrom(this._referencedPosition);\r\n            }\r\n        }\r\n\r\n        // Update camera rigs\r\n        if (this.rigCameras.length !== pose.views.length) {\r\n            this._updateNumberOfRigCameras(pose.views.length);\r\n        }\r\n\r\n        pose.views.forEach((view: XRView, i: number) => {\r\n            const currentRig = <TargetCamera>this.rigCameras[i];\r\n            // update right and left, where applicable\r\n            if (!currentRig.isLeftCamera && !currentRig.isRightCamera) {\r\n                if (view.eye === \"right\") {\r\n                    currentRig._isRightCamera = true;\r\n                } else if (view.eye === \"left\") {\r\n                    currentRig._isLeftCamera = true;\r\n                }\r\n            }\r\n            // Update view/projection matrix\r\n            const pos = view.transform.position;\r\n            const orientation = view.transform.orientation;\r\n\r\n            currentRig.position.set(pos.x, pos.y, pos.z);\r\n            currentRig.rotationQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);\r\n            if (!this._scene.useRightHandedSystem) {\r\n                currentRig.position.z *= -1;\r\n                currentRig.rotationQuaternion.z *= -1;\r\n                currentRig.rotationQuaternion.w *= -1;\r\n            } else {\r\n                currentRig.rotationQuaternion.multiplyInPlace(this._rotate180);\r\n            }\r\n            Matrix.FromFloat32ArrayToRefScaled(view.projectionMatrix, 0, 1, currentRig._projectionMatrix);\r\n\r\n            if (!this._scene.useRightHandedSystem) {\r\n                currentRig._projectionMatrix.toggleProjectionMatrixHandInPlace();\r\n            }\r\n\r\n            // first camera?\r\n            if (i === 0) {\r\n                this._projectionMatrix.copyFrom(currentRig._projectionMatrix);\r\n            }\r\n\r\n            // Update viewport\r\n            if (this._xrSessionManager.session.renderState.baseLayer) {\r\n                var viewport = this._xrSessionManager.session.renderState.baseLayer.getViewport(view);\r\n                var width = this._xrSessionManager.session.renderState.baseLayer.framebufferWidth;\r\n                var height = this._xrSessionManager.session.renderState.baseLayer.framebufferHeight;\r\n                currentRig.viewport.width = viewport.width / width;\r\n                currentRig.viewport.height = viewport.height / height;\r\n                currentRig.viewport.x = viewport.x / width;\r\n                currentRig.viewport.y = viewport.y / height;\r\n            }\r\n\r\n            // Set cameras to render to the session's render target\r\n            currentRig.outputRenderTarget = this._xrSessionManager.getRenderTargetTextureForEye(view.eye);\r\n        });\r\n    }\r\n\r\n    private _updateNumberOfRigCameras(viewCount = 1) {\r\n        while (this.rigCameras.length < viewCount) {\r\n            var newCamera = new TargetCamera(\"XR-RigCamera: \" + this.rigCameras.length, Vector3.Zero(), this.getScene());\r\n            newCamera.minZ = 0.1;\r\n            newCamera.rotationQuaternion = new Quaternion();\r\n            newCamera.updateUpVectorFromRotation = true;\r\n            newCamera.isRigCamera = true;\r\n            newCamera.rigParent = this;\r\n            // do not compute projection matrix, provided by XR\r\n            newCamera.freezeProjectionMatrix();\r\n            this.rigCameras.push(newCamera);\r\n        }\r\n        while (this.rigCameras.length > viewCount) {\r\n            var removedCamera = this.rigCameras.pop();\r\n            if (removedCamera) {\r\n                removedCamera.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _updateReferenceSpace() {\r\n        // were position & rotation updated OUTSIDE of the xr update loop\r\n        if (!this.position.equals(this._referencedPosition) || !this.rotationQuaternion.equals(this._referenceQuaternion)) {\r\n            this.position.subtractToRef(this._referencedPosition, this._referencedPosition);\r\n            this._referenceQuaternion.conjugateInPlace();\r\n            this._referenceQuaternion.multiplyToRef(this.rotationQuaternion, this._referenceQuaternion);\r\n            this._updateReferenceSpaceOffset(this._referencedPosition, this._referenceQuaternion.normalize());\r\n        }\r\n    }\r\n\r\n    private _updateReferenceSpaceOffset(positionOffset: Vector3, rotationOffset?: Quaternion, ignoreHeight: boolean = false) {\r\n        if (!this._xrSessionManager.referenceSpace || !this._xrSessionManager.currentFrame) {\r\n            return;\r\n        }\r\n        // Compute the origin offset based on player position/orientation.\r\n        this._xrInvPositionCache.copyFrom(positionOffset);\r\n        if (rotationOffset) {\r\n            this._xrInvQuaternionCache.copyFrom(rotationOffset);\r\n        } else {\r\n            this._xrInvQuaternionCache.copyFromFloats(0, 0, 0, 1);\r\n        }\r\n\r\n        // right handed system\r\n        if (!this._scene.useRightHandedSystem) {\r\n            this._xrInvPositionCache.z *= -1;\r\n            this._xrInvQuaternionCache.z *= -1;\r\n            this._xrInvQuaternionCache.w *= -1;\r\n        }\r\n\r\n        this._xrInvPositionCache.negateInPlace();\r\n        this._xrInvQuaternionCache.conjugateInPlace();\r\n        // transform point according to rotation with pivot\r\n        this._xrInvPositionCache.rotateByQuaternionToRef(this._xrInvQuaternionCache, this._xrInvPositionCache);\r\n        if (ignoreHeight) {\r\n            this._xrInvPositionCache.y = 0;\r\n        }\r\n        const transform = new XRRigidTransform({ x: this._xrInvPositionCache.x, y: this._xrInvPositionCache.y, z: this._xrInvPositionCache.z }, { x: this._xrInvQuaternionCache.x, y: this._xrInvQuaternionCache.y, z: this._xrInvQuaternionCache.z, w: this._xrInvQuaternionCache.w });\r\n        // Update offset reference to use a new originOffset with the teleported\r\n        // player position and orientation.\r\n        // This new offset needs to be applied to the base ref space.\r\n        const referenceSpace = this._xrSessionManager.referenceSpace.getOffsetReferenceSpace(transform);\r\n\r\n        const pose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(referenceSpace);\r\n\r\n        if (pose) {\r\n            const pos = new Vector3(pose.transform.position.x, pose.transform.position.y, pose.transform.position.z);\r\n            if (!this._scene.useRightHandedSystem) {\r\n                pos.z *= -1;\r\n            }\r\n            this.position.subtractToRef(pos, pos);\r\n            if (!this._scene.useRightHandedSystem) {\r\n                pos.z *= -1;\r\n            }\r\n            pos.negateInPlace();\r\n\r\n            const transform2 = new XRRigidTransform({ x: pos.x, y: pos.y, z: pos.z });\r\n            // Update offset reference to use a new originOffset with the teleported\r\n            // player position and orientation.\r\n            // This new offset needs to be applied to the base ref space.\r\n            this._xrSessionManager.referenceSpace = referenceSpace.getOffsetReferenceSpace(transform2);\r\n        }\r\n    }\r\n}\r\n","import { Vector4, Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Nullable } from '../../types';\r\n\r\nVertexData.CreateSphere = function(options: { segments?: number, diameter?: number, diameterX?: number, diameterY?: number, diameterZ?: number, arc?: number, slice?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }): VertexData {\r\n    var segments: number = options.segments || 32;\r\n    var diameterX: number = options.diameterX || options.diameter || 1;\r\n    var diameterY: number = options.diameterY || options.diameter || 1;\r\n    var diameterZ: number = options.diameterZ || options.diameter || 1;\r\n    var arc: number = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    var slice: number = options.slice && (options.slice <= 0) ? 1.0 : options.slice || 1.0;\r\n    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    var radius = new Vector3(diameterX / 2, diameterY / 2, diameterZ / 2);\r\n\r\n    var totalZRotationSteps = 2 + segments;\r\n    var totalYRotationSteps = 2 * totalZRotationSteps;\r\n\r\n    var indices = [];\r\n    var positions = [];\r\n    var normals = [];\r\n    var uvs = [];\r\n\r\n    for (var zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {\r\n        var normalizedZ = zRotationStep / totalZRotationSteps;\r\n        var angleZ = normalizedZ * Math.PI * slice;\r\n\r\n        for (var yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {\r\n            var normalizedY = yRotationStep / totalYRotationSteps;\r\n\r\n            var angleY = normalizedY * Math.PI * 2 * arc;\r\n\r\n            var rotationZ = Matrix.RotationZ(-angleZ);\r\n            var rotationY = Matrix.RotationY(angleY);\r\n            var afterRotZ = Vector3.TransformCoordinates(Vector3.Up(), rotationZ);\r\n            var complete = Vector3.TransformCoordinates(afterRotZ, rotationY);\r\n\r\n            var vertex = complete.multiply(radius);\r\n            var normal = complete.divide(radius).normalize();\r\n\r\n            positions.push(vertex.x, vertex.y, vertex.z);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            uvs.push(normalizedY, normalizedZ);\r\n        }\r\n\r\n        if (zRotationStep > 0) {\r\n            var verticesCount = positions.length / 3;\r\n            for (var firstIndex = verticesCount - 2 * (totalYRotationSteps + 1); (firstIndex + totalYRotationSteps + 2) < verticesCount; firstIndex++) {\r\n                if (zRotationStep > 1) {\r\n                    indices.push((firstIndex));\r\n                    indices.push((firstIndex + 1));\r\n                    indices.push(firstIndex + totalYRotationSteps + 1);\r\n                }\r\n                if (zRotationStep < totalZRotationSteps || slice < 1.0) {\r\n                    indices.push((firstIndex + totalYRotationSteps + 1));\r\n                    indices.push((firstIndex + 1));\r\n                    indices.push((firstIndex + totalYRotationSteps + 2));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    var vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n};\r\n\r\nMesh.CreateSphere = (name: string, segments: number, diameter: number, scene?: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    var options = {\r\n        segments: segments,\r\n        diameterX: diameter,\r\n        diameterY: diameter,\r\n        diameterZ: diameter,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable\r\n    };\r\n\r\n    return SphereBuilder.CreateSphere(name, options, scene);\r\n};\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport class SphereBuilder {\r\n    /**\r\n     * Creates a sphere mesh\r\n     * * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)\r\n     * * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)\r\n     * * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)\r\n     * * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio\r\n     * * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the sphere mesh\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#sphere\r\n     */\r\n    public static CreateSphere(name: string, options: { segments?: number, diameter?: number, diameterX?: number, diameterY?: number, diameterZ?: number, arc?: number, slice?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4, updatable?: boolean }, scene: Nullable<Scene> = null): Mesh {\r\n        var sphere = new Mesh(name, scene);\r\n\r\n        options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n        sphere._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n        var vertexData = VertexData.CreateSphere(options);\r\n\r\n        vertexData.applyToMesh(sphere, options.updatable);\r\n\r\n        return sphere;\r\n    }\r\n}\r\n","import { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport { IDisposable } from \"../scene\";\r\nimport { Tools } from \"../Misc/tools\";\r\n\r\n/**\r\n * Defining the interface required for a (webxr) feature\r\n */\r\nexport interface IWebXRFeature extends IDisposable {\r\n    /**\r\n     * Is this feature attached\r\n     */\r\n    attached: boolean;\r\n    /**\r\n     * Should auto-attach be disabled?\r\n     */\r\n    disableAutoAttach: boolean;\r\n\r\n    /**\r\n     * Attach the feature to the session\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @param force should attachment be forced (even when already attached)\r\n     * @returns true if successful.\r\n     */\r\n    attach(force?: boolean): boolean;\r\n    /**\r\n     * Detach the feature from the session\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    detach(): boolean;\r\n\r\n    /**\r\n     * This function will be executed during before enabling the feature and can be used to not-allow enabling it.\r\n     * Note that at this point the session has NOT started, so this is purely checking if the browser supports it\r\n     *\r\n     * @returns whether or not the feature is compatible in this environment\r\n     */\r\n    isCompatible(): boolean;\r\n\r\n    /**\r\n     * Was this feature disposed;\r\n     */\r\n    isDisposed: boolean;\r\n\r\n    /**\r\n     * The name of the native xr feature name, if applicable (like anchor, hit-test, or hand-tracking)\r\n     */\r\n    xrNativeFeatureName?: string;\r\n\r\n    /**\r\n     * A list of (Babylon WebXR) features this feature depends on\r\n     */\r\n    dependsOn?: string[];\r\n}\r\n\r\n/**\r\n * A list of the currently available features without referencing them\r\n */\r\nexport class WebXRFeatureName {\r\n    /**\r\n     * The name of the anchor system feature\r\n     */\r\n    public static readonly ANCHOR_SYSTEM = \"xr-anchor-system\";\r\n    /**\r\n     * The name of the background remover feature\r\n     */\r\n    public static readonly BACKGROUND_REMOVER = \"xr-background-remover\";\r\n    /**\r\n     * The name of the hit test feature\r\n     */\r\n    public static readonly HIT_TEST = \"xr-hit-test\";\r\n    /**\r\n     * physics impostors for xr controllers feature\r\n     */\r\n    public static readonly PHYSICS_CONTROLLERS = \"xr-physics-controller\";\r\n    /**\r\n     * The name of the plane detection feature\r\n     */\r\n    public static readonly PLANE_DETECTION = \"xr-plane-detection\";\r\n    /**\r\n     * The name of the pointer selection feature\r\n     */\r\n    public static readonly POINTER_SELECTION = \"xr-controller-pointer-selection\";\r\n    /**\r\n     * The name of the teleportation feature\r\n     */\r\n    public static readonly TELEPORTATION = \"xr-controller-teleportation\";\r\n    /**\r\n     * The name of the feature points feature.\r\n     */\r\n    public static readonly FEATURE_POINTS = \"xr-feature-points\";\r\n    /**\r\n     * The name of the hand tracking feature.\r\n     */\r\n    public static readonly HAND_TRACKING = \"xr-hand-tracking\";\r\n}\r\n\r\n/**\r\n * Defining the constructor of a feature. Used to register the modules.\r\n */\r\nexport type WebXRFeatureConstructor = (xrSessionManager: WebXRSessionManager, options?: any) => () => IWebXRFeature;\r\n\r\n/**\r\n * The WebXR features manager is responsible of enabling or disabling features required for the current XR session.\r\n * It is mainly used in AR sessions.\r\n *\r\n * A feature can have a version that is defined by Babylon (and does not correspond with the webxr version).\r\n */\r\nexport class WebXRFeaturesManager implements IDisposable {\r\n    private static readonly _AvailableFeatures: {\r\n        [name: string]: {\r\n            stable: number;\r\n            latest: number;\r\n            [version: number]: WebXRFeatureConstructor;\r\n        };\r\n    } = {};\r\n\r\n    private _features: {\r\n        [name: string]: {\r\n            featureImplementation: IWebXRFeature;\r\n            version: number;\r\n            enabled: boolean;\r\n            required: boolean;\r\n        };\r\n    } = {};\r\n\r\n    /**\r\n     * constructs a new features manages.\r\n     *\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     */\r\n    constructor(private _xrSessionManager: WebXRSessionManager) {\r\n        // when session starts / initialized - attach\r\n        this._xrSessionManager.onXRSessionInit.add(() => {\r\n            this.getEnabledFeatures().forEach((featureName) => {\r\n                const feature = this._features[featureName];\r\n                if (feature.enabled && !feature.featureImplementation.attached && !feature.featureImplementation.disableAutoAttach) {\r\n                    this.attachFeature(featureName);\r\n                }\r\n            });\r\n        });\r\n\r\n        // when session ends - detach\r\n        this._xrSessionManager.onXRSessionEnded.add(() => {\r\n            this.getEnabledFeatures().forEach((featureName) => {\r\n                const feature = this._features[featureName];\r\n                if (feature.enabled && feature.featureImplementation.attached) {\r\n                    // detach, but don't disable!\r\n                    this.detachFeature(featureName);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Used to register a module. After calling this function a developer can use this feature in the scene.\r\n     * Mainly used internally.\r\n     *\r\n     * @param featureName the name of the feature to register\r\n     * @param constructorFunction the function used to construct the module\r\n     * @param version the (babylon) version of the module\r\n     * @param stable is that a stable version of this module\r\n     */\r\n    public static AddWebXRFeature(featureName: string, constructorFunction: WebXRFeatureConstructor, version: number = 1, stable: boolean = false) {\r\n        this._AvailableFeatures[featureName] = this._AvailableFeatures[featureName] || { latest: version };\r\n        if (version > this._AvailableFeatures[featureName].latest) {\r\n            this._AvailableFeatures[featureName].latest = version;\r\n        }\r\n        if (stable) {\r\n            this._AvailableFeatures[featureName].stable = version;\r\n        }\r\n        this._AvailableFeatures[featureName][version] = constructorFunction;\r\n    }\r\n\r\n    /**\r\n     * Returns a constructor of a specific feature.\r\n     *\r\n     * @param featureName the name of the feature to construct\r\n     * @param version the version of the feature to load\r\n     * @param xrSessionManager the xrSessionManager. Used to construct the module\r\n     * @param options optional options provided to the module.\r\n     * @returns a function that, when called, will return a new instance of this feature\r\n     */\r\n    public static ConstructFeature(featureName: string, version: number = 1, xrSessionManager: WebXRSessionManager, options?: any): () => IWebXRFeature {\r\n        const constructorFunction = this._AvailableFeatures[featureName][version];\r\n        if (!constructorFunction) {\r\n            // throw an error? return nothing?\r\n            throw new Error(\"feature not found\");\r\n        }\r\n\r\n        return constructorFunction(xrSessionManager, options);\r\n    }\r\n\r\n    /**\r\n     * Can be used to return the list of features currently registered\r\n     *\r\n     * @returns an Array of available features\r\n     */\r\n    public static GetAvailableFeatures() {\r\n        return Object.keys(this._AvailableFeatures);\r\n    }\r\n\r\n    /**\r\n     * Gets the versions available for a specific feature\r\n     * @param featureName the name of the feature\r\n     * @returns an array with the available versions\r\n     */\r\n    public static GetAvailableVersions(featureName: string) {\r\n        return Object.keys(this._AvailableFeatures[featureName]);\r\n    }\r\n\r\n    /**\r\n     * Return the latest unstable version of this feature\r\n     * @param featureName the name of the feature to search\r\n     * @returns the version number. if not found will return -1\r\n     */\r\n    public static GetLatestVersionOfFeature(featureName: string): number {\r\n        return (this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].latest) || -1;\r\n    }\r\n\r\n    /**\r\n     * Return the latest stable version of this feature\r\n     * @param featureName the name of the feature to search\r\n     * @returns the version number. if not found will return -1\r\n     */\r\n    public static GetStableVersionOfFeature(featureName: string): number {\r\n        return (this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].stable) || -1;\r\n    }\r\n\r\n    /**\r\n     * Attach a feature to the current session. Mainly used when session started to start the feature effect.\r\n     * Can be used during a session to start a feature\r\n     * @param featureName the name of feature to attach\r\n     */\r\n    public attachFeature(featureName: string) {\r\n        const feature = this._features[featureName];\r\n        if (feature && feature.enabled && !feature.featureImplementation.attached) {\r\n            feature.featureImplementation.attach();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Can be used inside a session or when the session ends to detach a specific feature\r\n     * @param featureName the name of the feature to detach\r\n     */\r\n    public detachFeature(featureName: string) {\r\n        const feature = this._features[featureName];\r\n        if (feature && feature.featureImplementation.attached) {\r\n            feature.featureImplementation.detach();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Used to disable an already-enabled feature\r\n     * The feature will be disposed and will be recreated once enabled.\r\n     * @param featureName the feature to disable\r\n     * @returns true if disable was successful\r\n     */\r\n    public disableFeature(featureName: string | { Name: string }): boolean {\r\n        const name = typeof featureName === \"string\" ? featureName : featureName.Name;\r\n        const feature = this._features[name];\r\n        if (feature && feature.enabled) {\r\n            feature.enabled = false;\r\n            this.detachFeature(name);\r\n            feature.featureImplementation.dispose();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * dispose this features manager\r\n     */\r\n    public dispose(): void {\r\n        this.getEnabledFeatures().forEach((feature) => {\r\n            this.disableFeature(feature);\r\n            this._features[feature].featureImplementation.dispose();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Enable a feature using its name and a version. This will enable it in the scene, and will be responsible to attach it when the session starts.\r\n     * If used twice, the old version will be disposed and a new one will be constructed. This way you can re-enable with different configuration.\r\n     *\r\n     * @param featureName the name of the feature to load or the class of the feature\r\n     * @param version optional version to load. if not provided the latest version will be enabled\r\n     * @param moduleOptions options provided to the module. Ses the module documentation / constructor\r\n     * @param attachIfPossible if set to true (default) the feature will be automatically attached, if it is currently possible\r\n     * @param required is this feature required to the app. If set to true the session init will fail if the feature is not available.\r\n     * @returns a new constructed feature or throws an error if feature not found.\r\n     */\r\n    public enableFeature(featureName: string | { Name: string }, version: number | string = \"latest\", moduleOptions: any = {}, attachIfPossible: boolean = true, required: boolean = true): IWebXRFeature {\r\n        const name = typeof featureName === \"string\" ? featureName : featureName.Name;\r\n        let versionToLoad = 0;\r\n        if (typeof version === \"string\") {\r\n            if (!version) {\r\n                throw new Error(`Error in provided version - ${name} (${version})`);\r\n            }\r\n            if (version === \"stable\") {\r\n                versionToLoad = WebXRFeaturesManager.GetStableVersionOfFeature(name);\r\n            } else if (version === \"latest\") {\r\n                versionToLoad = WebXRFeaturesManager.GetLatestVersionOfFeature(name);\r\n            } else {\r\n                // try loading the number the string represents\r\n                versionToLoad = +version;\r\n            }\r\n            if (versionToLoad === -1 || isNaN(versionToLoad)) {\r\n                throw new Error(`feature not found - ${name} (${version})`);\r\n            }\r\n        } else {\r\n            versionToLoad = version;\r\n        }\r\n        // check if already initialized\r\n        const feature = this._features[name];\r\n        const constructFunction = WebXRFeaturesManager.ConstructFeature(name, versionToLoad, this._xrSessionManager, moduleOptions);\r\n        if (!constructFunction) {\r\n            // report error?\r\n            throw new Error(`feature not found - ${name}`);\r\n        }\r\n\r\n        /* If the feature is already enabled, detach and dispose it, and create a new one */\r\n        if (feature) {\r\n            this.disableFeature(name);\r\n        }\r\n\r\n        const constructed = constructFunction();\r\n        if (constructed.dependsOn) {\r\n            const dependentsFound = constructed.dependsOn.every((featureName) => !!this._features[featureName]);\r\n            if (!dependentsFound) {\r\n                throw new Error(`Dependant features missing. Make sure the following features are enabled - ${constructed.dependsOn.join(\", \")}`);\r\n            }\r\n        }\r\n        if (constructed.isCompatible()) {\r\n            this._features[name] = {\r\n                featureImplementation: constructed,\r\n                enabled: true,\r\n                version: versionToLoad,\r\n                required,\r\n            };\r\n\r\n            if (attachIfPossible) {\r\n                // if session started already, request and enable\r\n                if (this._xrSessionManager.session && !feature.featureImplementation.attached) {\r\n                    // enable feature\r\n                    this.attachFeature(name);\r\n                }\r\n            } else {\r\n                // disable auto-attach when session starts\r\n                this._features[name].featureImplementation.disableAutoAttach = true;\r\n            }\r\n\r\n            return this._features[name].featureImplementation;\r\n        } else {\r\n            if (required) {\r\n                throw new Error(\"required feature not compatible\");\r\n            } else {\r\n                Tools.Warn(`Feature ${name} not compatible with the current environment/browser and was not enabled.`);\r\n                return constructed;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get the implementation of an enabled feature.\r\n     * @param featureName the name of the feature to load\r\n     * @returns the feature class, if found\r\n     */\r\n    public getEnabledFeature(featureName: string): IWebXRFeature {\r\n        return this._features[featureName] && this._features[featureName].featureImplementation;\r\n    }\r\n\r\n    /**\r\n     * Get the list of enabled features\r\n     * @returns an array of enabled features\r\n     */\r\n    public getEnabledFeatures() {\r\n        return Object.keys(this._features);\r\n    }\r\n\r\n    /**\r\n     * This function will exten the session creation configuration object with enabled features.\r\n     * If, for example, the anchors feature is enabled, it will be automatically added to the optional or required features list,\r\n     * according to the defined \"required\" variable, provided during enableFeature call\r\n     * @param xrSessionInit the xr Session init object to extend\r\n     *\r\n     * @returns an extended XRSessionInit object\r\n     */\r\n    public extendXRSessionInitObject(xrSessionInit: XRSessionInit): XRSessionInit {\r\n        const enabledFeatures = this.getEnabledFeatures();\r\n        enabledFeatures.forEach((featureName) => {\r\n            const feature = this._features[featureName];\r\n            const nativeName = feature.featureImplementation.xrNativeFeatureName;\r\n            if (nativeName) {\r\n                if (feature.required) {\r\n                    xrSessionInit.requiredFeatures = xrSessionInit.requiredFeatures || [];\r\n                    if (xrSessionInit.requiredFeatures.indexOf(nativeName) === -1) {\r\n                        xrSessionInit.requiredFeatures.push(nativeName);\r\n                    }\r\n                } else {\r\n                    xrSessionInit.optionalFeatures = xrSessionInit.optionalFeatures || [];\r\n                    if (xrSessionInit.optionalFeatures.indexOf(nativeName) === -1) {\r\n                        xrSessionInit.optionalFeatures.push(nativeName);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        return xrSessionInit;\r\n    }\r\n}\r\n"],"sourceRoot":""}