{"version":3,"sources":["webpack:///../../../sourceES6/core/Cameras/freeCameraInputsManager.ts","webpack:///../../../../sourceES6/core/Engines/Extensions/engine.renderTarget.ts","webpack:///../../../../sourceES6/core/Engines/Extensions/engine.renderTargetCube.ts","webpack:///../../../../sourceES6/core/Cameras/Inputs/freeCameraKeyboardMoveInput.ts","webpack:///../../../../sourceES6/core/Cameras/Inputs/freeCameraMouseInput.ts","webpack:///../../../../sourceES6/core/Cameras/Inputs/freeCameraTouchInput.ts","webpack:///../../../../sourceES6/core/Materials/Textures/renderTargetTexture.ts","webpack:///../../../sourceES6/core/Cameras/freeCamera.ts"],"names":["camera","_mouseInput","addKeyboard","this","add","addMouse","touchEnabled","removeMouse","remove","addTouch","clear","prototype","createRenderTargetTexture","size","options","fullOptions","undefined","generateMipMaps","generateDepthBuffer","generateStencilBuffer","type","samplingMode","format","_caps","textureFloatLinearFiltering","textureHalfFloatLinearFiltering","textureFloat","Warn","gl","_gl","texture","RenderTarget","width","height","layers","filters","_getSamplingParameters","target","TEXTURE_2D_ARRAY","TEXTURE_2D","sizedFormat","_getRGBABufferInternalSizedFormat","internalFormat","_getInternalFormat","_getWebGLTextureType","_bindTextureDirectly","is2DArray","texImage3D","texImage2D","texParameteri","TEXTURE_MAG_FILTER","mag","TEXTURE_MIN_FILTER","min","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","generateMipmap","framebuffer","createFramebuffer","_bindUnboundFramebuffer","_depthStencilBuffer","_setupFramebufferDepthAttachments","framebufferTexture2D","FRAMEBUFFER","COLOR_ATTACHMENT0","_webGLTexture","_framebuffer","baseWidth","baseHeight","depth","isReady","samples","_generateDepthBuffer","_generateStencilBuffer","_internalTexturesCache","push","createDepthStencilTexture","isCube","_createDepthStencilCubeTexture","_createDepthStencilTexture","internalTexture","Depth","depthTextureExtension","Error","internalOptions","bilinearFiltering","comparisonFunction","generateStencil","_setupDepthStencilTexture","UNSIGNED_INT_24_8","UNSIGNED_INT","DEPTH_STENCIL","DEPTH_COMPONENT","webGLVersion","DEPTH24_STENCIL8","DEPTH_COMPONENT24","createRenderTargetCubeTexture","TEXTURE_CUBE_MAP","face","TEXTURE_CUBE_MAP_POSITIVE_X","keysUp","keysUpward","keysDown","keysDownward","keysLeft","keysRight","_keys","Array","attachControl","element","noPreventDefault","_onCanvasBlurObserver","_scene","getScene","_engine","getEngine","onCanvasBlurObservable","_onKeyboardObserver","onKeyboardObservable","info","index","evt","event","metaKey","KEYDOWN","indexOf","keyCode","preventDefault","splice","detachControl","checkInputs","length","speed","_computeLocalCameraSpeed","_localDirection","copyFromFloats","useRightHandedSystem","z","getViewMatrix","invertToRef","_cameraTransformMatrix","TransformNormalToRef","_transformedDirection","cameraDirection","addInPlace","getClassName","_onLostFocus","getSimpleName","FreeCameraKeyboardMoveInput","buttons","angularSensibility","previousPosition","onPointerMovedObservable","_allowCameraRotation","engine","_pointerInput","p","isInVRExclusivePointerMode","pointerType","POINTERMOVE","button","srcElement","POINTERDOWN","setPointerCapture","pointerId","e","x","clientX","y","clientY","focus","POINTERUP","releasePointerCapture","isPointerLock","offsetX","offsetY","parent","_getWorldMatrixDeterminant","cameraRotation","notifyObservers","_onMouseMove","movementX","mozMovementX","webkitMovementX","msMovementX","movementY","mozMovementY","webkitMovementY","msMovementY","_observer","onPointerObservable","addEventListener","onContextMenu","bind","removeEventListener","FreeCameraMouseInput","allowMouse","touchAngularSensibility","touchMoveSensibility","_offsetX","_offsetY","_pointerPressed","isMouseEvent","hostInformation","isMobile","MouseEvent","direction","RotationYawPitchRollToRef","rotation","_cameraRotationMatrix","TransformCoordinates","FreeCameraTouchInput","name","scene","doNotChangeAspectRatio","isMulti","delayAllocation","TRILINEAR_SAMPLINGMODE","renderParticles","renderSprites","ignoreCameraViewport","onBeforeBindObservable","onAfterUnbindObservable","onBeforeRenderObservable","onAfterRenderObservable","onClearObservable","onResizeObservable","_currentRefreshId","_refreshRate","_samples","boundingBoxPosition","Zero","_coordinatesMode","PROJECTION_MODE","renderList","isRenderTarget","_initialSizeParameter","_processSizeParameter","_resizeObserver","_generateMipMaps","_doNotChangeAspectRatio","_renderingManager","_useSceneAutoClearSetup","_renderTargetOptions","NEAREST_SAMPLINGMODE","wrapU","CLAMP_ADDRESSMODE","wrapV","_texture","getRenderSize","coordinatesMode","INVCUBIC_MODE","_textureMatrix","Identity","_size","_renderList","value","_hookArray","array","oldPush","wasEmpty","result","apply","items","meshes","forEach","mesh","_markSubMeshesAsLightDirty","oldSplice","deleteCount","deleted","callback","_onAfterUnbindObserver","_onBeforeRenderObserver","_onAfterRenderObserver","_onClearObserver","_onRatioRescale","_sizeRatio","resize","_boundingBoxSize","equals","markAllMaterialsAsDirty","getInternalTexture","_depthStencilTexture","ratio","_getEngine","_bestReflectionRenderTargetDimension","getRenderWidth","getRenderHeight","updateRenderTargetTextureSampleCount","resetRefreshCounter","addPostProcess","postProcess","_postProcessManager","_postProcesses","autoClear","clearPostProcesses","dispose","removePostProcess","_shouldRender","refreshRate","getRenderLayers","scale","newSize","Math","max","getReflectionTextureMatrix","wasCube","releaseInternalTexture","hasObservers","render","useCameraPostProcess","dumpForDebug","useCameraPostProcesses","_waitingRenderList","id","getMeshByID","renderListPredicate","sceneMeshes","activeCamera","setViewport","viewport","setTransformMatrix","getProjectionMatrix","_defaultRenderListPrepared","layer","renderToTarget","incrementRenderId","resetCachedMaterial","scenes","renderDimension","curved","NearestPOT","minimum","FloorPOT","_prepareRenderingManager","currentRenderList","currentRenderListLength","checkLayerMask","reset","sceneRenderId","getRenderId","meshIndex","customIsReadyFunction","_preActivateForIntermediateRendering","isMasked","layerMask","isEnabled","isVisible","subMeshes","_activate","isAnInstance","_internalAbstractMeshDataInfo","_actAsRegularMesh","sourceMesh","_onlyForInstancesIntermediate","_isActiveIntermediate","subIndex","subMesh","dispatch","particleIndex","particleSystems","particleSystem","emitter","isStarted","position","dispatchParticles","_bindFrameBuffer","faceIndex","bindFramebuffer","unbindFrameBuffer","unBindFramebuffer","_prepareFrame","postProcessManager","defaultRenderList","getActiveMeshes","data","defaultRenderListLength","getCustomRenderList","clearColor","updateTransformMatrix","_beforeRenderTargetDrawStage","action","customRenderFunction","_afterRenderTargetDrawStage","_finalizeFrame","DumpFramebuffer","generateMipMapsForCubemap","setRenderingOrder","renderingGroupId","opaqueSortCompareFn","alphaTestSortCompareFn","transparentSortCompareFn","setRenderingAutoClearDepthStencil","autoClearDepthStencil","clone","textureSize","getSize","newTexture","RenderTargetTexture","hasAlpha","level","slice","serialize","serializationObject","renderTargetSize","disposeFramebufferObjects","objBuffer","_releaseFramebufferObjects","customRenderTargets","cameras","depthStencilTexture","_releaseTexture","_rebuild","REFRESHRATE_RENDER_ONCE","freeRenderingGroups","getViewCount","REFRESHRATE_RENDER_ONEVERYFRAME","REFRESHRATE_RENDER_ONEVERYTWOFRAMES","_CreateRenderTargetTexture","setActiveOnSceneIfNoneActive","ellipsoid","ellipsoidOffset","checkCollisions","applyGravity","_needMoveForGravity","_oldPosition","_diffPosition","_newPosition","_collisionMask","_onCollisionPositionChange","collisionId","newPosition","collidedMesh","newPos","copyFrom","subtractToRef","CollisionsEpsilon","onCollide","inputs","mouse","attached","keyboard","attachElement","detachElement","mask","isNaN","_collideWithWorld","displacement","getWorldMatrix","subtractFromFloatsToRef","coordinator","collisionCoordinator","_collider","createCollider","_radius","collisionMask","actualDisplacement","gravity","getNewPosition","uniqueId","_checkInputs","_decideIfNeedsToMove","abs","_updatePosition","collisionsEnabled"],"mappings":"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","file":"js/2.babylonBundle.js","sourcesContent":["import { FreeCamera } from \"./freeCamera\";\r\nimport { CameraInputsManager } from \"./cameraInputsManager\";\r\nimport { FreeCameraKeyboardMoveInput } from \"../Cameras/Inputs/freeCameraKeyboardMoveInput\";\r\nimport { FreeCameraMouseInput } from \"../Cameras/Inputs/freeCameraMouseInput\";\r\nimport { FreeCameraTouchInput } from \"../Cameras/Inputs/freeCameraTouchInput\";\r\nimport { Nullable } from '../types';\r\n\r\n/**\r\n * Default Inputs manager for the FreeCamera.\r\n * It groups all the default supported inputs for ease of use.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\r\nexport class FreeCameraInputsManager extends CameraInputsManager<FreeCamera> {\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _mouseInput: Nullable<FreeCameraMouseInput> = null;\r\n    /**\r\n     * Instantiates a new FreeCameraInputsManager.\r\n     * @param camera Defines the camera the inputs belong to\r\n     */\r\n    constructor(camera: FreeCamera) {\r\n        super(camera);\r\n    }\r\n\r\n    /**\r\n     * Add keyboard input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    addKeyboard(): FreeCameraInputsManager {\r\n        this.add(new FreeCameraKeyboardMoveInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add mouse input support to the input manager.\r\n     * @param touchEnabled if the FreeCameraMouseInput should support touch (default: true)\r\n     * @returns the current input manager\r\n     */\r\n    addMouse(touchEnabled = true): FreeCameraInputsManager {\r\n        if (!this._mouseInput) {\r\n            this._mouseInput = new FreeCameraMouseInput(touchEnabled);\r\n            this.add(this._mouseInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes the mouse input support from the manager\r\n     * @returns the current input manager\r\n     */\r\n    removeMouse(): FreeCameraInputsManager {\r\n        if (this._mouseInput) {\r\n            this.remove(this._mouseInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add touch input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    addTouch(): FreeCameraInputsManager {\r\n        this.add(new FreeCameraTouchInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove all attached input methods from a camera\r\n     */\r\n    public clear(): void {\r\n        super.clear();\r\n        this._mouseInput = null;\r\n    }\r\n}\r\n","import { InternalTexture, InternalTextureSource } from '../../Materials/Textures/internalTexture';\r\nimport { Logger } from '../../Misc/logger';\r\nimport { RenderTargetCreationOptions } from '../../Materials/Textures/renderTargetCreationOptions';\r\n\r\nimport { ThinEngine } from '../thinEngine';\r\nimport { DepthTextureCreationOptions } from '../depthTextureCreationOptions';\r\n\r\n/**\r\n * Type used to define a render target texture size (either with a number or with a rect width and height)\r\n */\r\nexport type RenderTargetTextureSize = number | { width: number, height: number, layers?: number };\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n\r\n    export interface ThinEngine {\r\n        /**\r\n         * Creates a new render target texture\r\n         * @param size defines the size of the texture\r\n         * @param options defines the options used to create the texture\r\n         * @returns a new render target texture stored in an InternalTexture\r\n         */\r\n        createRenderTargetTexture(size: RenderTargetTextureSize, options: boolean | RenderTargetCreationOptions): InternalTexture;\r\n\r\n        /**\r\n         * Creates a depth stencil texture.\r\n         * This is only available in WebGL 2 or with the depth texture extension available.\r\n         * @param size The size of face edge in the texture.\r\n         * @param options The options defining the texture.\r\n         * @returns The texture\r\n         */\r\n        createDepthStencilTexture(size: RenderTargetTextureSize, options: DepthTextureCreationOptions): InternalTexture;\r\n\r\n        /** @hidden */\r\n        _createDepthStencilTexture(size: RenderTargetTextureSize, options: DepthTextureCreationOptions): InternalTexture;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.createRenderTargetTexture = function(this: ThinEngine, size: RenderTargetTextureSize, options: boolean | RenderTargetCreationOptions): InternalTexture {\r\n    const fullOptions = new RenderTargetCreationOptions();\r\n    if (options !== undefined && typeof options === \"object\") {\r\n        fullOptions.generateMipMaps = options.generateMipMaps;\r\n        fullOptions.generateDepthBuffer = !!options.generateDepthBuffer;\r\n        fullOptions.generateStencilBuffer = !!options.generateStencilBuffer;\r\n        fullOptions.type = options.type === undefined ? 0 : options.type;\r\n        fullOptions.samplingMode = options.samplingMode === undefined ? 3 : options.samplingMode;\r\n        fullOptions.format = options.format === undefined ? 5 : options.format;\r\n    } else {\r\n        fullOptions.generateMipMaps = <boolean>options;\r\n        fullOptions.generateDepthBuffer = true;\r\n        fullOptions.generateStencilBuffer = false;\r\n        fullOptions.type = 0;\r\n        fullOptions.samplingMode = 3;\r\n        fullOptions.format = 5;\r\n    }\r\n\r\n    if (fullOptions.type === 1 && !this._caps.textureFloatLinearFiltering) {\r\n        // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE\r\n        fullOptions.samplingMode = 1;\r\n    }\r\n    else if (fullOptions.type === 2 && !this._caps.textureHalfFloatLinearFiltering) {\r\n        // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\r\n        fullOptions.samplingMode = 1;\r\n    }\r\n    if (fullOptions.type === 1 && !this._caps.textureFloat) {\r\n        fullOptions.type = 0;\r\n        Logger.Warn(\"Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type\");\r\n    }\r\n\r\n    const gl = this._gl;\r\n    const texture = new InternalTexture(this, InternalTextureSource.RenderTarget);\r\n    const width = (<{ width: number, height: number, layers?: number }>size).width || <number>size;\r\n    const height = (<{ width: number, height: number, layers?: number }>size).height || <number>size;\r\n    const layers = (<{ width: number, height: number, layers?: number }>size).layers || 0;\r\n    const filters = this._getSamplingParameters(fullOptions.samplingMode, fullOptions.generateMipMaps ? true : false);\r\n    const target = layers !== 0 ? gl.TEXTURE_2D_ARRAY : gl.TEXTURE_2D;\r\n    const sizedFormat = this._getRGBABufferInternalSizedFormat(fullOptions.type, fullOptions.format);\r\n    const internalFormat = this._getInternalFormat(fullOptions.format);\r\n    const type = this._getWebGLTextureType(fullOptions.type);\r\n\r\n    // Bind\r\n    this._bindTextureDirectly(target, texture);\r\n\r\n    if (layers !== 0) {\r\n        texture.is2DArray = true;\r\n        gl.texImage3D(target, 0, sizedFormat, width, height, layers, 0, internalFormat, type, null);\r\n    }\r\n    else {\r\n        gl.texImage2D(target, 0, sizedFormat, width, height, 0, internalFormat, type, null);\r\n    }\r\n\r\n    gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, filters.mag);\r\n    gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, filters.min);\r\n    gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n    // MipMaps\r\n    if (fullOptions.generateMipMaps) {\r\n        this._gl.generateMipmap(target);\r\n    }\r\n\r\n    this._bindTextureDirectly(target, null);\r\n\r\n    // Create the framebuffer\r\n    const framebuffer = gl.createFramebuffer();\r\n    this._bindUnboundFramebuffer(framebuffer);\r\n    texture._depthStencilBuffer = this._setupFramebufferDepthAttachments(fullOptions.generateStencilBuffer ? true : false, fullOptions.generateDepthBuffer, width, height);\r\n\r\n    // No need to rebind on every frame\r\n    if (!texture.is2DArray) {\r\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture._webGLTexture, 0);\r\n    }\r\n\r\n    this._bindUnboundFramebuffer(null);\r\n\r\n    texture._framebuffer = framebuffer;\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.depth = layers;\r\n    texture.isReady = true;\r\n    texture.samples = 1;\r\n    texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;\r\n    texture.samplingMode = fullOptions.samplingMode;\r\n    texture.type = fullOptions.type;\r\n    texture.format = fullOptions.format;\r\n    texture._generateDepthBuffer = fullOptions.generateDepthBuffer;\r\n    texture._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nThinEngine.prototype.createDepthStencilTexture = function(size: RenderTargetTextureSize, options: DepthTextureCreationOptions): InternalTexture {\r\n    if (options.isCube) {\r\n        let width = (<{ width: number, height: number }>size).width || <number>size;\r\n        return this._createDepthStencilCubeTexture(width, options);\r\n    }\r\n    else {\r\n        return this._createDepthStencilTexture(size, options);\r\n    }\r\n};\r\n\r\nThinEngine.prototype._createDepthStencilTexture = function(size: RenderTargetTextureSize, options: DepthTextureCreationOptions): InternalTexture {\r\n    const gl = this._gl;\r\n    const layers = (<{ width: number, height: number, layers?: number }>size).layers || 0;\r\n    const target = layers !== 0 ? gl.TEXTURE_2D_ARRAY : gl.TEXTURE_2D;\r\n    const internalTexture = new InternalTexture(this, InternalTextureSource.Depth);\r\n    if (!this._caps.depthTextureExtension) {\r\n        Logger.Error(\"Depth texture is not supported by your browser or hardware.\");\r\n        return internalTexture;\r\n    }\r\n\r\n    const internalOptions = {\r\n        bilinearFiltering: false,\r\n        comparisonFunction: 0,\r\n        generateStencil: false,\r\n        ...options\r\n    };\r\n\r\n    this._bindTextureDirectly(target, internalTexture, true);\r\n\r\n    this._setupDepthStencilTexture(internalTexture, size, internalOptions.generateStencil, internalOptions.bilinearFiltering, internalOptions.comparisonFunction);\r\n\r\n    const type = internalOptions.generateStencil ? gl.UNSIGNED_INT_24_8 : gl.UNSIGNED_INT;\r\n    const internalFormat = internalOptions.generateStencil ? gl.DEPTH_STENCIL : gl.DEPTH_COMPONENT;\r\n    let sizedFormat = internalFormat;\r\n    if (this.webGLVersion > 1) {\r\n        sizedFormat = internalOptions.generateStencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;\r\n    }\r\n\r\n    if (internalTexture.is2DArray) {\r\n        gl.texImage3D(target, 0, sizedFormat, internalTexture.width, internalTexture.height, layers, 0, internalFormat, type, null);\r\n    }\r\n    else {\r\n        gl.texImage2D(target, 0, sizedFormat, internalTexture.width, internalTexture.height, 0, internalFormat, type, null);\r\n    }\r\n\r\n    this._bindTextureDirectly(target, null);\r\n\r\n    return internalTexture;\r\n};","import { InternalTexture, InternalTextureSource } from '../../Materials/Textures/internalTexture';\r\nimport { Logger } from '../../Misc/logger';\r\nimport { RenderTargetCreationOptions } from '../../Materials/Textures/renderTargetCreationOptions';\r\n\r\nimport { ThinEngine } from '../thinEngine';\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Creates a new render target cube texture\r\n         * @param size defines the size of the texture\r\n         * @param options defines the options used to create the texture\r\n         * @returns a new render target cube texture stored in an InternalTexture\r\n         */\r\n        createRenderTargetCubeTexture(size: number, options?: Partial<RenderTargetCreationOptions>): InternalTexture;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.createRenderTargetCubeTexture = function(size: number, options?: Partial<RenderTargetCreationOptions>): InternalTexture {\r\n    let fullOptions = {\r\n        generateMipMaps: true,\r\n        generateDepthBuffer: true,\r\n        generateStencilBuffer: false,\r\n        type: 0,\r\n        samplingMode: 3,\r\n        format: 5,\r\n        ...options\r\n    };\r\n    fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && fullOptions.generateStencilBuffer;\r\n\r\n    if (fullOptions.type === 1 && !this._caps.textureFloatLinearFiltering) {\r\n        // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE\r\n        fullOptions.samplingMode = 1;\r\n    }\r\n    else if (fullOptions.type === 2 && !this._caps.textureHalfFloatLinearFiltering) {\r\n        // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\r\n        fullOptions.samplingMode = 1;\r\n    }\r\n    var gl = this._gl;\r\n\r\n    var texture = new InternalTexture(this, InternalTextureSource.RenderTarget);\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n\r\n    var filters = this._getSamplingParameters(fullOptions.samplingMode, fullOptions.generateMipMaps);\r\n\r\n    if (fullOptions.type === 1 && !this._caps.textureFloat) {\r\n        fullOptions.type = 0;\r\n        Logger.Warn(\"Float textures are not supported. Cube render target forced to TEXTURETYPE_UNESIGNED_BYTE type\");\r\n    }\r\n\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n    for (var face = 0; face < 6; face++) {\r\n        gl.texImage2D((gl.TEXTURE_CUBE_MAP_POSITIVE_X + face), 0, this._getRGBABufferInternalSizedFormat(fullOptions.type, fullOptions.format), size, size, 0, this._getInternalFormat(fullOptions.format), this._getWebGLTextureType(fullOptions.type), null);\r\n    }\r\n\r\n    // Create the framebuffer\r\n    var framebuffer = gl.createFramebuffer();\r\n    this._bindUnboundFramebuffer(framebuffer);\r\n\r\n    texture._depthStencilBuffer = this._setupFramebufferDepthAttachments(fullOptions.generateStencilBuffer, fullOptions.generateDepthBuffer, size, size);\r\n\r\n    // MipMaps\r\n    if (fullOptions.generateMipMaps) {\r\n        gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\r\n    }\r\n\r\n    // Unbind\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n    this._bindUnboundFramebuffer(null);\r\n\r\n    texture._framebuffer = framebuffer;\r\n    texture.width = size;\r\n    texture.height = size;\r\n    texture.isReady = true;\r\n    texture.isCube = true;\r\n    texture.samples = 1;\r\n    texture.generateMipMaps = fullOptions.generateMipMaps;\r\n    texture.samplingMode = fullOptions.samplingMode;\r\n    texture.type = fullOptions.type;\r\n    texture.format = fullOptions.format;\r\n    texture._generateDepthBuffer = fullOptions.generateDepthBuffer;\r\n    texture._generateStencilBuffer = fullOptions.generateStencilBuffer;\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};","import { serialize } from \"../../Misc/decorators\";\r\nimport { Observer } from \"../../Misc/observable\";\r\nimport { Nullable } from \"../../types\";\r\nimport { ICameraInput, CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport { KeyboardInfo, KeyboardEventTypes } from \"../../Events/keyboardEvents\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Engine } from \"../../Engines/engine\";\r\n/**\r\n * Manage the keyboard inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\r\nexport class FreeCameraKeyboardMoveInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the forward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysUp = [38];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the upward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysUpward = [33];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the backward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysDown = [40];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the downward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysDownward = [34];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysLeft = [37];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRight = [39];\r\n\r\n    private _keys = new Array<number>();\r\n    private _onCanvasBlurObserver: Nullable<Observer<Engine>>;\r\n    private _onKeyboardObserver: Nullable<Observer<KeyboardInfo>>;\r\n    private _engine: Engine;\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param element Defines the element the controls should be listened from\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(element: HTMLElement, noPreventDefault?: boolean): void {\r\n        if (this._onCanvasBlurObserver) {\r\n            return;\r\n        }\r\n\r\n        this._scene = this.camera.getScene();\r\n        this._engine = this._scene.getEngine();\r\n\r\n        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {\r\n            this._keys = [];\r\n        });\r\n\r\n        this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {\r\n            let evt = info.event;\r\n            if (!evt.metaKey) {\r\n                if (info.type === KeyboardEventTypes.KEYDOWN) {\r\n                    if (this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysUpward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDownward.indexOf(evt.keyCode) !== -1) {\r\n                        var index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index === -1) {\r\n                            this._keys.push(evt.keyCode);\r\n                        }\r\n                        if (!noPreventDefault) {\r\n                            evt.preventDefault();\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysUpward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDownward.indexOf(evt.keyCode) !== -1) {\r\n                        var index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index >= 0) {\r\n                            this._keys.splice(index, 1);\r\n                        }\r\n                        if (!noPreventDefault) {\r\n                            evt.preventDefault();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     * @param element Defines the element to stop listening the inputs from\r\n     */\r\n    public detachControl(element: Nullable<HTMLElement>): void {\r\n        if (this._scene) {\r\n            if (this._onKeyboardObserver) {\r\n                this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);\r\n            }\r\n\r\n            if (this._onCanvasBlurObserver) {\r\n                this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);\r\n            }\r\n            this._onKeyboardObserver = null;\r\n            this._onCanvasBlurObserver = null;\r\n        }\r\n        this._keys = [];\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._onKeyboardObserver) {\r\n            var camera = this.camera;\r\n            // Keyboard\r\n            for (var index = 0; index < this._keys.length; index++) {\r\n                var keyCode = this._keys[index];\r\n                var speed = camera._computeLocalCameraSpeed();\r\n\r\n                if (this.keysLeft.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(-speed, 0, 0);\r\n                } else if (this.keysUp.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, speed);\r\n                } else if (this.keysRight.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(speed, 0, 0);\r\n                } else if (this.keysDown.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, -speed);\r\n                } else if (this.keysUpward.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, speed, 0);\r\n                } else if (this.keysDownward.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, -speed, 0);\r\n                }\r\n\r\n                if (camera.getScene().useRightHandedSystem) {\r\n                    camera._localDirection.z *= -1;\r\n                }\r\n\r\n                camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);\r\n                Vector3.TransformNormalToRef(camera._localDirection, camera._cameraTransformMatrix, camera._transformedDirection);\r\n                camera.cameraDirection.addInPlace(camera._transformedDirection);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current intput.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraKeyboardMoveInput\";\r\n    }\r\n\r\n    /** @hidden */\r\n    public _onLostFocus(): void {\r\n        this._keys = [];\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"keyboard\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraKeyboardMoveInput\"] = FreeCameraKeyboardMoveInput;\r\n","import { Observer, EventState, Observable } from \"../../Misc/observable\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport { Nullable } from \"../../types\";\r\nimport { ICameraInput, CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport { PointerInfo, PointerEventTypes } from \"../../Events/pointerEvents\";\r\n/**\r\n * Manage the mouse inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\r\nexport class FreeCameraMouseInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X and Y axis or how fast is the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibility = 2000.0;\r\n\r\n    private _pointerInput: (p: PointerInfo, s: EventState) => void;\r\n    private _onMouseMove: Nullable<(e: MouseEvent) => any>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private previousPosition: Nullable<{ x: number, y: number }> = null;\r\n\r\n    /**\r\n     * Observable for when a pointer move event occurs containing the move offset\r\n     */\r\n    public onPointerMovedObservable = new Observable<{ offsetX: number, offsetY: number }>();\r\n    /**\r\n     * @hidden\r\n     * If the camera should be rotated automatically based on pointer movement\r\n     */\r\n    public _allowCameraRotation = true;\r\n    /**\r\n     * Manage the mouse inputs to control the movement of a free camera.\r\n     * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n     * @param touchEnabled Defines if touch is enabled or not\r\n     */\r\n    constructor(\r\n        /**\r\n         * Define if touch is enabled in the mouse input\r\n         */\r\n        public touchEnabled = true) {\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param element Defines the element the controls should be listened from\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(element: HTMLElement, noPreventDefault?: boolean): void {\r\n        var engine = this.camera.getEngine();\r\n\r\n        if (!this._pointerInput) {\r\n            this._pointerInput = (p) => {\r\n                var evt = <PointerEvent>p.event;\r\n\r\n                if (engine.isInVRExclusivePointerMode) {\r\n                    return;\r\n                }\r\n\r\n                if (!this.touchEnabled && evt.pointerType === \"touch\") {\r\n                    return;\r\n                }\r\n\r\n                if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {\r\n                    return;\r\n                }\r\n\r\n                let srcElement = <HTMLElement>(evt.srcElement || evt.target);\r\n\r\n                if (p.type === PointerEventTypes.POINTERDOWN && srcElement) {\r\n                    try {\r\n                        srcElement.setPointerCapture(evt.pointerId);\r\n                    } catch (e) {\r\n                        //Nothing to do with the error. Execution will continue.\r\n                    }\r\n\r\n                    this.previousPosition = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY\r\n                    };\r\n\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                        element.focus();\r\n                    }\r\n                }\r\n                else if (p.type === PointerEventTypes.POINTERUP && srcElement) {\r\n                    try {\r\n                        srcElement.releasePointerCapture(evt.pointerId);\r\n                    } catch (e) {\r\n                        //Nothing to do with the error.\r\n                    }\r\n\r\n                    this.previousPosition = null;\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n                }\r\n\r\n                else if (p.type === PointerEventTypes.POINTERMOVE) {\r\n                    if (!this.previousPosition || engine.isPointerLock) {\r\n                        return;\r\n                    }\r\n\r\n                    var offsetX = evt.clientX - this.previousPosition.x;\r\n                    var offsetY = evt.clientY - this.previousPosition.y;\r\n                    if (this.camera.getScene().useRightHandedSystem) { offsetX *= -1; }\r\n                    if (this.camera.parent && this.camera.parent._getWorldMatrixDeterminant() < 0) { offsetX *= -1; }\r\n\r\n                    if (this._allowCameraRotation) {\r\n                        this.camera.cameraRotation.y += offsetX / this.angularSensibility;\r\n                        this.camera.cameraRotation.x += offsetY / this.angularSensibility;\r\n                    }\r\n                    this.onPointerMovedObservable.notifyObservers({offsetX: offsetX, offsetY: offsetY});\r\n\r\n                    this.previousPosition = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY\r\n                    };\r\n\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n                }\r\n            };\r\n        }\r\n\r\n        this._onMouseMove = (evt) => {\r\n            if (!engine.isPointerLock) {\r\n                return;\r\n            }\r\n\r\n            if (engine.isInVRExclusivePointerMode) {\r\n                return;\r\n            }\r\n\r\n            var offsetX = evt.movementX || evt.mozMovementX || evt.webkitMovementX || evt.msMovementX || 0;\r\n            if (this.camera.getScene().useRightHandedSystem) { offsetX *= -1; }\r\n            if (this.camera.parent && this.camera.parent._getWorldMatrixDeterminant() < 0) { offsetX *= -1; }\r\n            this.camera.cameraRotation.y += offsetX / this.angularSensibility;\r\n\r\n            var offsetY = evt.movementY || evt.mozMovementY || evt.webkitMovementY || evt.msMovementY || 0;\r\n            this.camera.cameraRotation.x += offsetY / this.angularSensibility;\r\n\r\n            this.previousPosition = null;\r\n\r\n            if (!noPreventDefault) {\r\n                evt.preventDefault();\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera.getScene().onPointerObservable.add(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\r\n        element.addEventListener(\"mousemove\", this._onMouseMove, false);\r\n\r\n        element.addEventListener(\"contextmenu\",\r\n            <EventListener>this.onContextMenu.bind(this), false);\r\n    }\r\n\r\n    /**\r\n     * Called on JS contextmenu event.\r\n     * Override this method to provide functionality.\r\n     */\r\n    protected onContextMenu(evt: PointerEvent): void {\r\n        evt.preventDefault();\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     * @param element Defines the element to stop listening the inputs from\r\n     */\r\n    public detachControl(element: Nullable<HTMLElement>): void {\r\n        if (this._observer && element) {\r\n            this.camera.getScene().onPointerObservable.remove(this._observer);\r\n\r\n            if (this._onMouseMove) {\r\n                element.removeEventListener(\"mousemove\", this._onMouseMove);\r\n            }\r\n\r\n            if (this.onContextMenu) {\r\n                element.removeEventListener(\"contextmenu\", <EventListener>this.onContextMenu);\r\n            }\r\n\r\n            if (this.onPointerMovedObservable) {\r\n                this.onPointerMovedObservable.clear();\r\n            }\r\n\r\n            this._observer = null;\r\n            this._onMouseMove = null;\r\n            this.previousPosition = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current intput.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraMouseInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mouse\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraMouseInput\"] = FreeCameraMouseInput;\r\n","import { serialize } from \"../../Misc/decorators\";\r\nimport { Observer, EventState } from \"../../Misc/observable\";\r\nimport { Nullable } from \"../../types\";\r\nimport { ICameraInput, CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport { PointerInfo, PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\n/**\r\n * Manage the touch inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\r\nexport class FreeCameraTouchInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Defines the touch sensibility for rotation.\r\n     * The higher the faster.\r\n     */\r\n    @serialize()\r\n    public touchAngularSensibility: number = 200000.0;\r\n\r\n    /**\r\n     * Defines the touch sensibility for move.\r\n     * The higher the faster.\r\n     */\r\n    @serialize()\r\n    public touchMoveSensibility: number = 250.0;\r\n\r\n    private _offsetX: Nullable<number> = null;\r\n    private _offsetY: Nullable<number> = null;\r\n\r\n    private _pointerPressed = new Array<number>();\r\n    private _pointerInput: (p: PointerInfo, s: EventState) => void;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _onLostFocus: Nullable<(e: FocusEvent) => any>;\r\n\r\n    /**\r\n     * Manage the touch inputs to control the movement of a free camera.\r\n     * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n     * @param allowMouse Defines if mouse events can be treated as touch events\r\n     */\r\n    constructor(\r\n        /**\r\n         * Define if mouse events can be treated as touch events\r\n         */\r\n        public allowMouse = false) {\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param element Defines the element the controls should be listened from\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(element: HTMLElement, noPreventDefault?: boolean): void {\r\n        var previousPosition: Nullable<{ x: number, y: number }> = null;\r\n\r\n        if (this._pointerInput === undefined) {\r\n            this._onLostFocus = () => {\r\n                this._offsetX = null;\r\n                this._offsetY = null;\r\n            };\r\n\r\n            this._pointerInput = (p) => {\r\n                var evt = <PointerEvent>p.event;\r\n\r\n                let isMouseEvent = !this.camera.getEngine().hostInformation.isMobile && evt instanceof MouseEvent;\r\n                if (!this.allowMouse && (evt.pointerType === \"mouse\" || isMouseEvent)) {\r\n                    return;\r\n                }\r\n\r\n                if (p.type === PointerEventTypes.POINTERDOWN) {\r\n\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    this._pointerPressed.push(evt.pointerId);\r\n\r\n                    if (this._pointerPressed.length !== 1) {\r\n                        return;\r\n                    }\r\n\r\n                    previousPosition = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY\r\n                    };\r\n                }\r\n\r\n                else if (p.type === PointerEventTypes.POINTERUP) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    var index: number = this._pointerPressed.indexOf(evt.pointerId);\r\n\r\n                    if (index === -1) {\r\n                        return;\r\n                    }\r\n                    this._pointerPressed.splice(index, 1);\r\n\r\n                    if (index != 0) {\r\n                        return;\r\n                    }\r\n                    previousPosition = null;\r\n                    this._offsetX = null;\r\n                    this._offsetY = null;\r\n                }\r\n\r\n                else if (p.type === PointerEventTypes.POINTERMOVE) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    if (!previousPosition) {\r\n                        return;\r\n                    }\r\n\r\n                    var index: number = this._pointerPressed.indexOf(evt.pointerId);\r\n\r\n                    if (index != 0) {\r\n                        return;\r\n                    }\r\n\r\n                    this._offsetX = evt.clientX - previousPosition.x;\r\n                    this._offsetY = -(evt.clientY - previousPosition.y);\r\n                }\r\n            };\r\n        }\r\n\r\n        this._observer = this.camera.getScene().onPointerObservable.add(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\r\n\r\n        if (this._onLostFocus) {\r\n            element.addEventListener(\"blur\", this._onLostFocus);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     * @param element Defines the element to stop listening the inputs from\r\n     */\r\n    public detachControl(element: Nullable<HTMLElement>): void {\r\n        if (this._pointerInput && element) {\r\n            if (this._observer) {\r\n                this.camera.getScene().onPointerObservable.remove(this._observer);\r\n                this._observer = null;\r\n            }\r\n\r\n            if (this._onLostFocus) {\r\n                element.removeEventListener(\"blur\", this._onLostFocus);\r\n                this._onLostFocus = null;\r\n            }\r\n            this._pointerPressed = [];\r\n            this._offsetX = null;\r\n            this._offsetY = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._offsetX && this._offsetY) {\r\n            var camera = this.camera;\r\n            camera.cameraRotation.y += this._offsetX / this.touchAngularSensibility;\r\n\r\n            if (this._pointerPressed.length > 1) {\r\n                camera.cameraRotation.x += -this._offsetY / this.touchAngularSensibility;\r\n            } else {\r\n                var speed = camera._computeLocalCameraSpeed();\r\n                var direction = new Vector3(0, 0, speed * this._offsetY / this.touchMoveSensibility);\r\n\r\n                Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, camera._cameraRotationMatrix);\r\n                camera.cameraDirection.addInPlace(Vector3.TransformCoordinates(direction, camera._cameraRotationMatrix));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current intput.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraTouchInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"touch\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraTouchInput\"] = FreeCameraTouchInput;\r\n","import { Observer, Observable } from \"../../Misc/observable\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { SmartArray } from \"../../Misc/smartArray\";\r\nimport { Nullable, Immutable } from \"../../types\";\r\nimport { Camera } from \"../../Cameras/camera\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from '../../Maths/math.color';\r\nimport { RenderTargetCreationOptions } from \"../../Materials/Textures/renderTargetCreationOptions\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { SubMesh } from \"../../Meshes/subMesh\";\r\nimport { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { PostProcessManager } from \"../../PostProcesses/postProcessManager\";\r\nimport { PostProcess } from \"../../PostProcesses/postProcess\";\r\nimport { RenderingManager } from \"../../Rendering/renderingManager\";\r\n\r\n\r\nimport \"../../Engines/Extensions/engine.renderTarget\";\r\nimport \"../../Engines/Extensions/engine.renderTargetCube\";\r\nimport { InstancedMesh } from '../../Meshes/instancedMesh';\r\nimport { Engine } from '../../Engines/engine';\r\n\r\n/**\r\n * This Helps creating a texture that will be created from a camera in your scene.\r\n * It is basically a dynamic texture that could be used to create special effects for instance.\r\n * Actually, It is the base of lot of effects in the framework like post process, shadows, effect layers and rendering pipelines...\r\n */\r\nexport class RenderTargetTexture extends Texture {\r\n    /**\r\n     * The texture will only be rendered once which can be useful to improve performance if everything in your render is static for instance.\r\n     */\r\n    public static readonly REFRESHRATE_RENDER_ONCE: number = 0;\r\n    /**\r\n     * The texture will only be rendered rendered every frame and is recomended for dynamic contents.\r\n     */\r\n    public static readonly REFRESHRATE_RENDER_ONEVERYFRAME: number = 1;\r\n    /**\r\n     * The texture will be rendered every 2 frames which could be enough if your dynamic objects are not\r\n     * the central point of your effect and can save a lot of performances.\r\n     */\r\n    public static readonly REFRESHRATE_RENDER_ONEVERYTWOFRAMES: number = 2;\r\n\r\n    /**\r\n    * Use this predicate to dynamically define the list of mesh you want to render.\r\n    * If set, the renderList property will be overwritten.\r\n    */\r\n    public renderListPredicate: (AbstractMesh: AbstractMesh) => boolean;\r\n\r\n    private _renderList: Nullable<Array<AbstractMesh>>;\r\n    /**\r\n    * Use this list to define the list of mesh you want to render.\r\n    */\r\n    public get renderList(): Nullable<Array<AbstractMesh>> {\r\n        return this._renderList;\r\n    }\r\n\r\n    public set renderList(value: Nullable<Array<AbstractMesh>>) {\r\n        this._renderList = value;\r\n\r\n        if (this._renderList) {\r\n            this._hookArray(this._renderList);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Use this function to overload the renderList array at rendering time.\r\n     * Return null to render with the curent renderList, else return the list of meshes to use for rendering.\r\n     * For 2DArray RTT, layerOrFace is the index of the layer that is going to be rendered, else it is the faceIndex of\r\n     * the cube (if the RTT is a cube, else layerOrFace=0).\r\n     * The renderList passed to the function is the current render list (the one that will be used if the function returns null).\r\n     * The length of this list is passed through renderListLength: don't use renderList.length directly because the array can\r\n     * hold dummy elements!\r\n    */\r\n    public getCustomRenderList: (layerOrFace: number, renderList: Nullable<Immutable<Array<AbstractMesh>>>, renderListLength: number) => Nullable<Array<AbstractMesh>>;\r\n\r\n    private _hookArray(array: AbstractMesh[]): void {\r\n        var oldPush = array.push;\r\n        array.push = (...items: AbstractMesh[]) => {\r\n            let wasEmpty = array.length === 0;\r\n\r\n            var result = oldPush.apply(array, items);\r\n\r\n            if (wasEmpty && this.getScene()) {\r\n                this.getScene()!.meshes.forEach((mesh) => {\r\n                    mesh._markSubMeshesAsLightDirty();\r\n                });\r\n            }\r\n\r\n            return result;\r\n        };\r\n\r\n        var oldSplice = array.splice;\r\n        array.splice = (index: number, deleteCount?: number) => {\r\n            var deleted = oldSplice.apply(array, [index, deleteCount]);\r\n\r\n            if (array.length === 0) {\r\n                this.getScene()!.meshes.forEach((mesh) => {\r\n                    mesh._markSubMeshesAsLightDirty();\r\n                });\r\n            }\r\n\r\n            return deleted;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Define if particles should be rendered in your texture.\r\n     */\r\n    public renderParticles = true;\r\n    /**\r\n     * Define if sprites should be rendered in your texture.\r\n     */\r\n    public renderSprites = false;\r\n    /**\r\n     * Define the camera used to render the texture.\r\n     */\r\n    public activeCamera: Nullable<Camera>;\r\n    /**\r\n     * Override the mesh isReady function with your own one.\r\n     */\r\n    public customIsReadyFunction: (mesh: AbstractMesh, refreshRate: number) => boolean;\r\n    /**\r\n     * Override the render function of the texture with your own one.\r\n     */\r\n    public customRenderFunction: (opaqueSubMeshes: SmartArray<SubMesh>, alphaTestSubMeshes: SmartArray<SubMesh>, transparentSubMeshes: SmartArray<SubMesh>, depthOnlySubMeshes: SmartArray<SubMesh>, beforeTransparents?: () => void) => void;\r\n    /**\r\n     * Define if camera post processes should be use while rendering the texture.\r\n     */\r\n    public useCameraPostProcesses: boolean;\r\n    /**\r\n     * Define if the camera viewport should be respected while rendering the texture or if the render should be done to the entire texture.\r\n     */\r\n    public ignoreCameraViewport: boolean = false;\r\n\r\n    private _postProcessManager: Nullable<PostProcessManager>;\r\n    private _postProcesses: PostProcess[];\r\n    private _resizeObserver: Nullable<Observer<Engine>>;\r\n\r\n    /**\r\n    * An event triggered when the texture is unbind.\r\n    */\r\n    public onBeforeBindObservable = new Observable<RenderTargetTexture>();\r\n\r\n    /**\r\n    * An event triggered when the texture is unbind.\r\n    */\r\n    public onAfterUnbindObservable = new Observable<RenderTargetTexture>();\r\n\r\n    private _onAfterUnbindObserver: Nullable<Observer<RenderTargetTexture>>;\r\n    /**\r\n     * Set a after unbind callback in the texture.\r\n     * This has been kept for backward compatibility and use of onAfterUnbindObservable is recommended.\r\n     */\r\n    public set onAfterUnbind(callback: () => void) {\r\n        if (this._onAfterUnbindObserver) {\r\n            this.onAfterUnbindObservable.remove(this._onAfterUnbindObserver);\r\n        }\r\n        this._onAfterUnbindObserver = this.onAfterUnbindObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n    * An event triggered before rendering the texture\r\n    */\r\n    public onBeforeRenderObservable = new Observable<number>();\r\n\r\n    private _onBeforeRenderObserver: Nullable<Observer<number>>;\r\n    /**\r\n     * Set a before render callback in the texture.\r\n     * This has been kept for backward compatibility and use of onBeforeRenderObservable is recommended.\r\n     */\r\n    public set onBeforeRender(callback: (faceIndex: number) => void) {\r\n        if (this._onBeforeRenderObserver) {\r\n            this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\r\n        }\r\n        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n    * An event triggered after rendering the texture\r\n    */\r\n    public onAfterRenderObservable = new Observable<number>();\r\n\r\n    private _onAfterRenderObserver: Nullable<Observer<number>>;\r\n    /**\r\n     * Set a after render callback in the texture.\r\n     * This has been kept for backward compatibility and use of onAfterRenderObservable is recommended.\r\n     */\r\n    public set onAfterRender(callback: (faceIndex: number) => void) {\r\n        if (this._onAfterRenderObserver) {\r\n            this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\r\n        }\r\n        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n    * An event triggered after the texture clear\r\n    */\r\n    public onClearObservable = new Observable<Engine>();\r\n\r\n    private _onClearObserver: Nullable<Observer<Engine>>;\r\n    /**\r\n     * Set a clear callback in the texture.\r\n     * This has been kept for backward compatibility and use of onClearObservable is recommended.\r\n     */\r\n    public set onClear(callback: (Engine: Engine) => void) {\r\n        if (this._onClearObserver) {\r\n            this.onClearObservable.remove(this._onClearObserver);\r\n        }\r\n        this._onClearObserver = this.onClearObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the texture is resized.\r\n     */\r\n    public onResizeObservable = new Observable<RenderTargetTexture>();\r\n\r\n    /**\r\n     * Define the clear color of the Render Target if it should be different from the scene.\r\n     */\r\n    public clearColor: Color4;\r\n    protected _size: number | { width: number, height: number, layers?: number };\r\n    protected _initialSizeParameter: number | { width: number, height: number } | { ratio: number };\r\n    protected _sizeRatio: Nullable<number>;\r\n    /** @hidden */\r\n    public _generateMipMaps: boolean;\r\n    protected _renderingManager: RenderingManager;\r\n    /** @hidden */\r\n    public _waitingRenderList?: string[];\r\n    protected _doNotChangeAspectRatio: boolean;\r\n    protected _currentRefreshId = -1;\r\n    protected _refreshRate = 1;\r\n    protected _textureMatrix: Matrix;\r\n    protected _samples = 1;\r\n    protected _renderTargetOptions: RenderTargetCreationOptions;\r\n    /**\r\n     * Gets render target creation options that were used.\r\n     */\r\n    public get renderTargetOptions(): RenderTargetCreationOptions {\r\n        return this._renderTargetOptions;\r\n    }\r\n\r\n    protected _onRatioRescale(): void {\r\n        if (this._sizeRatio) {\r\n            this.resize(this._initialSizeParameter);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the center of the bounding box associated with the texture (when in cube mode)\r\n     * It must define where the camera used to render the texture is set\r\n     */\r\n    public boundingBoxPosition = Vector3.Zero();\r\n\r\n    private _boundingBoxSize: Vector3;\r\n\r\n    /**\r\n     * Gets or sets the size of the bounding box associated with the texture (when in cube mode)\r\n     * When defined, the cubemap will switch to local mode\r\n     * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity\r\n     * @example https://www.babylonjs-playground.com/#RNASML\r\n     */\r\n    public set boundingBoxSize(value: Vector3) {\r\n        if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {\r\n            return;\r\n        }\r\n        this._boundingBoxSize = value;\r\n        let scene = this.getScene();\r\n        if (scene) {\r\n            scene.markAllMaterialsAsDirty(1);\r\n        }\r\n    }\r\n    public get boundingBoxSize(): Vector3 {\r\n        return this._boundingBoxSize;\r\n    }\r\n\r\n    /**\r\n     * In case the RTT has been created with a depth texture, get the associated\r\n     * depth texture.\r\n     * Otherwise, return null.\r\n     */\r\n    public get depthStencilTexture(): Nullable<InternalTexture> {\r\n        return this.getInternalTexture()?._depthStencilTexture || null;\r\n    }\r\n\r\n    /**\r\n     * Instantiate a render target texture. This is mainly used to render of screen the scene to for instance apply post processse\r\n     * or used a shadow, depth texture...\r\n     * @param name The friendly name of the texture\r\n     * @param size The size of the RTT (number if square, or {width: number, height:number} or {ratio:} to define a ratio from the main scene)\r\n     * @param scene The scene the RTT belongs to. The latest created scene will be used if not precised.\r\n     * @param generateMipMaps True if mip maps need to be generated after render.\r\n     * @param doNotChangeAspectRatio True to not change the aspect ratio of the scene in the RTT\r\n     * @param type The type of the buffer in the RTT (int, half float, float...)\r\n     * @param isCube True if a cube texture needs to be created\r\n     * @param samplingMode The sampling mode to be usedwith the render target (Linear, Nearest...)\r\n     * @param generateDepthBuffer True to generate a depth buffer\r\n     * @param generateStencilBuffer True to generate a stencil buffer\r\n     * @param isMulti True if multiple textures need to be created (Draw Buffers)\r\n     * @param format The internal format of the buffer in the RTT (RED, RG, RGB, RGBA, ALPHA...)\r\n     * @param delayAllocation if the texture allocation should be delayed (default: false)\r\n     */\r\n    constructor(name: string, size: number | { width: number, height: number, layers?: number } | { ratio: number }, scene: Nullable<Scene>, generateMipMaps?: boolean, doNotChangeAspectRatio: boolean = true, type: number = 0, isCube = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, generateDepthBuffer = true, generateStencilBuffer = false, isMulti = false, format = 5, delayAllocation = false) {\r\n        super(null, scene, !generateMipMaps);\r\n        scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        this._coordinatesMode = Texture.PROJECTION_MODE;\r\n        this.renderList = new Array<AbstractMesh>();\r\n        this.name = name;\r\n        this.isRenderTarget = true;\r\n        this._initialSizeParameter = size;\r\n\r\n        this._processSizeParameter(size);\r\n\r\n        this._resizeObserver = this.getScene()!.getEngine().onResizeObservable.add(() => {\r\n        });\r\n\r\n        this._generateMipMaps = generateMipMaps ? true : false;\r\n        this._doNotChangeAspectRatio = doNotChangeAspectRatio;\r\n\r\n        // Rendering groups\r\n        this._renderingManager = new RenderingManager(scene);\r\n        this._renderingManager._useSceneAutoClearSetup = true;\r\n\r\n        if (isMulti) {\r\n            return;\r\n        }\r\n\r\n        this._renderTargetOptions = {\r\n            generateMipMaps: generateMipMaps,\r\n            type: type,\r\n            format: format,\r\n            samplingMode: samplingMode,\r\n            generateDepthBuffer: generateDepthBuffer,\r\n            generateStencilBuffer: generateStencilBuffer\r\n        };\r\n\r\n        if (samplingMode === Texture.NEAREST_SAMPLINGMODE) {\r\n            this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n            this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        }\r\n\r\n        if (!delayAllocation) {\r\n            if (isCube) {\r\n                this._texture = scene.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions);\r\n                this.coordinatesMode = Texture.INVCUBIC_MODE;\r\n                this._textureMatrix = Matrix.Identity();\r\n            } else {\r\n                this._texture = scene.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a depth stencil texture.\r\n     * This is only available in WebGL 2 or with the depth texture extension available.\r\n     * @param comparisonFunction Specifies the comparison function to set on the texture. If 0 or undefined, the texture is not in comparison mode\r\n     * @param bilinearFiltering Specifies whether or not bilinear filtering is enable on the texture\r\n     * @param generateStencil Specifies whether or not a stencil should be allocated in the texture\r\n     */\r\n    public createDepthStencilTexture(comparisonFunction: number = 0, bilinearFiltering: boolean = true, generateStencil: boolean = false): void {\r\n        const internalTexture = this.getInternalTexture();\r\n        if (!this.getScene() || !internalTexture) {\r\n            return;\r\n        }\r\n\r\n        var engine = this.getScene()!.getEngine();\r\n        internalTexture._depthStencilTexture = engine.createDepthStencilTexture(this._size, {\r\n            bilinearFiltering,\r\n            comparisonFunction,\r\n            generateStencil,\r\n            isCube: this.isCube\r\n        });\r\n    }\r\n\r\n    private _processSizeParameter(size: number | { width: number, height: number } | { ratio: number }): void {\r\n        if ((<{ ratio: number }>size).ratio) {\r\n            this._sizeRatio = (<{ ratio: number }>size).ratio;\r\n            const engine = this._getEngine()!;\r\n            this._size = {\r\n                width: this._bestReflectionRenderTargetDimension(engine.getRenderWidth(), this._sizeRatio),\r\n                height: this._bestReflectionRenderTargetDimension(engine.getRenderHeight(), this._sizeRatio)\r\n            };\r\n        } else {\r\n            this._size = <number | { width: number, height: number, layers?: number }>size;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define the number of samples to use in case of MSAA.\r\n     * It defaults to one meaning no MSAA has been enabled.\r\n     */\r\n    public get samples(): number {\r\n        return this._samples;\r\n    }\r\n\r\n    public set samples(value: number) {\r\n        if (this._samples === value) {\r\n            return;\r\n        }\r\n\r\n        let scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        this._samples = scene.getEngine().updateRenderTargetTextureSampleCount(this._texture, value);\r\n    }\r\n\r\n    /**\r\n     * Resets the refresh counter of the texture and start bak from scratch.\r\n     * Could be useful to regenerate the texture if it is setup to render only once.\r\n     */\r\n    public resetRefreshCounter(): void {\r\n        this._currentRefreshId = -1;\r\n    }\r\n\r\n    /**\r\n     * Define the refresh rate of the texture or the rendering frequency.\r\n     * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...\r\n     */\r\n    public get refreshRate(): number {\r\n        return this._refreshRate;\r\n    }\r\n    public set refreshRate(value: number) {\r\n        this._refreshRate = value;\r\n        this.resetRefreshCounter();\r\n    }\r\n\r\n    /**\r\n     * Adds a post process to the render target rendering passes.\r\n     * @param postProcess define the post process to add\r\n     */\r\n    public addPostProcess(postProcess: PostProcess): void {\r\n        if (!this._postProcessManager) {\r\n            let scene = this.getScene();\r\n\r\n            if (!scene) {\r\n                return;\r\n            }\r\n            this._postProcessManager = new PostProcessManager(scene);\r\n            this._postProcesses = new Array<PostProcess>();\r\n        }\r\n\r\n        this._postProcesses.push(postProcess);\r\n        this._postProcesses[0].autoClear = false;\r\n    }\r\n\r\n    /**\r\n     * Clear all the post processes attached to the render target\r\n     * @param dispose define if the cleared post processesshould also be disposed (false by default)\r\n     */\r\n    public clearPostProcesses(dispose: boolean = false): void {\r\n        if (!this._postProcesses) {\r\n            return;\r\n        }\r\n\r\n        if (dispose) {\r\n            for (var postProcess of this._postProcesses) {\r\n                postProcess.dispose();\r\n            }\r\n        }\r\n\r\n        this._postProcesses = [];\r\n    }\r\n\r\n    /**\r\n     * Remove one of the post process from the list of attached post processes to the texture\r\n     * @param postProcess define the post process to remove from the list\r\n     */\r\n    public removePostProcess(postProcess: PostProcess): void {\r\n        if (!this._postProcesses) {\r\n            return;\r\n        }\r\n\r\n        var index = this._postProcesses.indexOf(postProcess);\r\n\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        this._postProcesses.splice(index, 1);\r\n\r\n        if (this._postProcesses.length > 0) {\r\n            this._postProcesses[0].autoClear = false;\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _shouldRender(): boolean {\r\n        if (this._currentRefreshId === -1) { // At least render once\r\n            this._currentRefreshId = 1;\r\n            return true;\r\n        }\r\n\r\n        if (this.refreshRate === this._currentRefreshId) {\r\n            this._currentRefreshId = 1;\r\n            return true;\r\n        }\r\n\r\n        this._currentRefreshId++;\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets the actual render size of the texture.\r\n     * @returns the width of the render size\r\n     */\r\n    public getRenderSize(): number {\r\n        return this.getRenderWidth();\r\n    }\r\n\r\n    /**\r\n     * Gets the actual render width of the texture.\r\n     * @returns the width of the render size\r\n     */\r\n    public getRenderWidth(): number {\r\n        if ((<{ width: number, height: number }>this._size).width) {\r\n            return (<{ width: number, height: number }>this._size).width;\r\n        }\r\n\r\n        return <number>this._size;\r\n    }\r\n\r\n    /**\r\n     * Gets the actual render height of the texture.\r\n     * @returns the height of the render size\r\n     */\r\n    public getRenderHeight(): number {\r\n        if ((<{ width: number, height: number }>this._size).width) {\r\n            return (<{ width: number, height: number }>this._size).height;\r\n        }\r\n\r\n        return <number>this._size;\r\n    }\r\n\r\n    /**\r\n     * Gets the actual number of layers of the texture.\r\n     * @returns the number of layers\r\n     */\r\n    public getRenderLayers(): number {\r\n        const layers = (<{ width: number, height: number, layers?: number }>this._size).layers;\r\n        if (layers) {\r\n            return layers;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Get if the texture can be rescaled or not.\r\n     */\r\n    public get canRescale(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Resize the texture using a ratio.\r\n     * @param ratio the ratio to apply to the texture size in order to compute the new target size\r\n     */\r\n    public scale(ratio: number): void {\r\n        var newSize = Math.max(1, this.getRenderSize() * ratio);\r\n\r\n        this.resize(newSize);\r\n    }\r\n\r\n    /**\r\n     * Get the texture reflection matrix used to rotate/transform the reflection.\r\n     * @returns the reflection matrix\r\n     */\r\n    public getReflectionTextureMatrix(): Matrix {\r\n        if (this.isCube) {\r\n            return this._textureMatrix;\r\n        }\r\n\r\n        return super.getReflectionTextureMatrix();\r\n    }\r\n\r\n    /**\r\n     * Resize the texture to a new desired size.\r\n     * Be carrefull as it will recreate all the data in the new texture.\r\n     * @param size Define the new size. It can be:\r\n     *   - a number for squared texture,\r\n     *   - an object containing { width: number, height: number }\r\n     *   - or an object containing a ratio { ratio: number }\r\n     */\r\n    public resize(size: number | { width: number, height: number } | { ratio: number }): void {\r\n        var wasCube = this.isCube;\r\n\r\n        this.releaseInternalTexture();\r\n        let scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        this._processSizeParameter(size);\r\n\r\n        if (wasCube) {\r\n            this._texture = scene.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions);\r\n        } else {\r\n            this._texture = scene.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions);\r\n        }\r\n\r\n        if (this.onResizeObservable.hasObservers()) {\r\n            this.onResizeObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    private _defaultRenderListPrepared: boolean;\r\n\r\n    /**\r\n     * Renders all the objects from the render list into the texture.\r\n     * @param useCameraPostProcess Define if camera post processes should be used during the rendering\r\n     * @param dumpForDebug Define if the rendering result should be dumped (copied) for debugging purpose\r\n     */\r\n    public render(useCameraPostProcess: boolean = false, dumpForDebug: boolean = false): void {\r\n        var scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        var engine = scene.getEngine();\r\n\r\n        if (this.useCameraPostProcesses !== undefined) {\r\n            useCameraPostProcess = this.useCameraPostProcesses;\r\n        }\r\n\r\n        if (this._waitingRenderList) {\r\n            this.renderList = [];\r\n            for (var index = 0; index < this._waitingRenderList.length; index++) {\r\n                var id = this._waitingRenderList[index];\r\n                let mesh = scene.getMeshByID(id);\r\n                if (mesh) {\r\n                    this.renderList.push(mesh);\r\n                }\r\n            }\r\n\r\n            this._waitingRenderList = undefined;\r\n        }\r\n\r\n        // Is predicate defined?\r\n        if (this.renderListPredicate) {\r\n            if (this.renderList) {\r\n                this.renderList.length = 0; // Clear previous renderList\r\n            } else {\r\n                this.renderList = [];\r\n            }\r\n\r\n            var scene = this.getScene();\r\n\r\n            if (!scene) {\r\n                return;\r\n            }\r\n\r\n            var sceneMeshes = scene.meshes;\r\n\r\n            for (var index = 0; index < sceneMeshes.length; index++) {\r\n                var mesh = sceneMeshes[index];\r\n                if (this.renderListPredicate(mesh)) {\r\n                    this.renderList.push(mesh);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.onBeforeBindObservable.notifyObservers(this);\r\n\r\n        // Set custom projection.\r\n        // Needs to be before binding to prevent changing the aspect ratio.\r\n        let camera: Nullable<Camera>;\r\n        if (this.activeCamera) {\r\n            camera = this.activeCamera;\r\n            engine.setViewport(this.activeCamera.viewport, this.getRenderWidth(), this.getRenderHeight());\r\n\r\n            if (this.activeCamera !== scene.activeCamera) {\r\n                scene.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix(true));\r\n            }\r\n        }\r\n        else {\r\n            camera = scene.activeCamera;\r\n            if (camera) {\r\n                engine.setViewport(camera.viewport, this.getRenderWidth(), this.getRenderHeight());\r\n            }\r\n        }\r\n\r\n        this._defaultRenderListPrepared = false;\r\n\r\n        if (this.is2DArray) {\r\n            for (let layer = 0; layer < this.getRenderLayers(); layer++) {\r\n                this.renderToTarget(0, useCameraPostProcess, dumpForDebug, layer, camera);\r\n                scene.incrementRenderId();\r\n                scene.resetCachedMaterial();\r\n            }\r\n        }\r\n        else if (this.isCube) {\r\n            for (var face = 0; face < 6; face++) {\r\n                this.renderToTarget(face, useCameraPostProcess, dumpForDebug, undefined, camera);\r\n                scene.incrementRenderId();\r\n                scene.resetCachedMaterial();\r\n            }\r\n        } else {\r\n            this.renderToTarget(0, useCameraPostProcess, dumpForDebug, undefined, camera);\r\n        }\r\n\r\n        this.onAfterUnbindObservable.notifyObservers(this);\r\n\r\n        if (scene.activeCamera) {\r\n            // Do not avoid setting uniforms when multiple scenes are active as another camera may have overwrite these\r\n            if (scene.getEngine().scenes.length > 1 || (this.activeCamera && this.activeCamera !== scene.activeCamera)) {\r\n                scene.setTransformMatrix(scene.activeCamera.getViewMatrix(), scene.activeCamera.getProjectionMatrix(true));\r\n            }\r\n            engine.setViewport(scene.activeCamera.viewport);\r\n        }\r\n\r\n        scene.resetCachedMaterial();\r\n    }\r\n\r\n    private _bestReflectionRenderTargetDimension(renderDimension: number, scale: number): number {\r\n        let minimum = 128;\r\n        let x = renderDimension * scale;\r\n        let curved = Engine.NearestPOT(x + (minimum * minimum / (minimum + x)));\r\n\r\n        // Ensure we don't exceed the render dimension (while staying POT)\r\n        return Math.min(Engine.FloorPOT(renderDimension), curved);\r\n    }\r\n\r\n    private _prepareRenderingManager(currentRenderList: Array<AbstractMesh>, currentRenderListLength: number, camera: Nullable<Camera>, checkLayerMask: boolean): void {\r\n        var scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        this._renderingManager.reset();\r\n\r\n        var sceneRenderId = scene.getRenderId();\r\n        for (var meshIndex = 0; meshIndex < currentRenderListLength; meshIndex++) {\r\n            var mesh = currentRenderList[meshIndex];\r\n\r\n            if (mesh) {\r\n                if (this.customIsReadyFunction) {\r\n                    if (!this.customIsReadyFunction(mesh, this.refreshRate)) {\r\n                        this.resetRefreshCounter();\r\n                        continue;\r\n                    }\r\n                }\r\n                else if (!mesh.isReady(this.refreshRate === 0)) {\r\n                    this.resetRefreshCounter();\r\n                    continue;\r\n                }\r\n\r\n                mesh._preActivateForIntermediateRendering(sceneRenderId);\r\n\r\n                let isMasked;\r\n                if (checkLayerMask && camera) {\r\n                    isMasked = ((mesh.layerMask & camera.layerMask) === 0);\r\n                } else {\r\n                    isMasked = false;\r\n                }\r\n\r\n                if (mesh.isEnabled() && mesh.isVisible && mesh.subMeshes && !isMasked) {\r\n                    if (mesh._activate(sceneRenderId, true) && mesh.subMeshes.length) {\r\n                        if (!mesh.isAnInstance) {\r\n                            mesh._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = false;\r\n                        } else {\r\n                            if (!mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {\r\n                                mesh = (mesh as InstancedMesh).sourceMesh;\r\n                            }\r\n                        }\r\n                        mesh._internalAbstractMeshDataInfo._isActiveIntermediate = true;\r\n\r\n                        for (var subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {\r\n                            var subMesh = mesh.subMeshes[subIndex];\r\n                            this._renderingManager.dispatch(subMesh, mesh);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        for (var particleIndex = 0; particleIndex < scene.particleSystems.length; particleIndex++) {\r\n            var particleSystem = scene.particleSystems[particleIndex];\r\n\r\n            let emitter: any = particleSystem.emitter;\r\n            if (!particleSystem.isStarted() || !emitter || !emitter.position || !emitter.isEnabled()) {\r\n                continue;\r\n            }\r\n\r\n            if (currentRenderList.indexOf(emitter) >= 0) {\r\n                this._renderingManager.dispatchParticles(particleSystem);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * @param faceIndex face index to bind to if this is a cubetexture\r\n     * @param layer defines the index of the texture to bind in the array\r\n     */\r\n    public _bindFrameBuffer(faceIndex: number = 0, layer = 0) {\r\n        var scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        var engine = scene.getEngine();\r\n        if (this._texture) {\r\n            engine.bindFramebuffer(this._texture, this.isCube ? faceIndex : undefined, undefined, undefined, this.ignoreCameraViewport, 0, layer);\r\n        }\r\n    }\r\n\r\n    protected unbindFrameBuffer(engine: Engine, faceIndex: number): void {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n        engine.unBindFramebuffer(this._texture, this.isCube, () => {\r\n            this.onAfterRenderObservable.notifyObservers(faceIndex);\r\n        });\r\n    }\r\n\r\n    private renderToTarget(faceIndex: number, useCameraPostProcess: boolean, dumpForDebug: boolean, layer = 0, camera: Nullable<Camera> = null): void {\r\n        var scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        var engine = scene.getEngine();\r\n\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        // Bind\r\n        if (this._postProcessManager) {\r\n            this._postProcessManager._prepareFrame(this._texture, this._postProcesses);\r\n        }\r\n        else if (!useCameraPostProcess || !scene.postProcessManager._prepareFrame(this._texture)) {\r\n            this._bindFrameBuffer(faceIndex, layer);\r\n        }\r\n\r\n        if (this.is2DArray) {\r\n            this.onBeforeRenderObservable.notifyObservers(layer);\r\n        }\r\n        else {\r\n            this.onBeforeRenderObservable.notifyObservers(faceIndex);\r\n        }\r\n\r\n        // Get the list of meshes to render\r\n        let currentRenderList: Nullable<Array<AbstractMesh>> = null;\r\n        let defaultRenderList = this.renderList ? this.renderList : scene.getActiveMeshes().data;\r\n        let defaultRenderListLength = this.renderList ? this.renderList.length : scene.getActiveMeshes().length;\r\n\r\n        if (this.getCustomRenderList) {\r\n            currentRenderList = this.getCustomRenderList(this.is2DArray ? layer : faceIndex, defaultRenderList, defaultRenderListLength);\r\n        }\r\n\r\n        if (!currentRenderList) {\r\n            // No custom render list provided, we prepare the rendering for the default list, but check\r\n            // first if we did not already performed the preparation before so as to avoid re-doing it several times\r\n            if (!this._defaultRenderListPrepared) {\r\n                this._prepareRenderingManager(defaultRenderList, defaultRenderListLength, camera, !this.renderList);\r\n                this._defaultRenderListPrepared = true;\r\n            }\r\n            currentRenderList = defaultRenderList;\r\n        } else {\r\n            // Prepare the rendering for the custom render list provided\r\n            this._prepareRenderingManager(currentRenderList, currentRenderList.length, camera, false);\r\n        }\r\n\r\n        // Clear\r\n        if (this.onClearObservable.hasObservers()) {\r\n            this.onClearObservable.notifyObservers(engine);\r\n        } else {\r\n            engine.clear(this.clearColor || scene.clearColor, true, true, true);\r\n        }\r\n\r\n        if (!this._doNotChangeAspectRatio) {\r\n            scene.updateTransformMatrix(true);\r\n        }\r\n\r\n        // Before Camera Draw\r\n        for (let step of scene._beforeRenderTargetDrawStage) {\r\n            step.action(this);\r\n        }\r\n\r\n        // Render\r\n        this._renderingManager.render(this.customRenderFunction, currentRenderList, this.renderParticles, this.renderSprites);\r\n\r\n        // After Camera Draw\r\n        for (let step of scene._afterRenderTargetDrawStage) {\r\n            step.action(this);\r\n        }\r\n\r\n        if (this._postProcessManager) {\r\n            this._postProcessManager._finalizeFrame(false, this._texture, faceIndex, this._postProcesses, this.ignoreCameraViewport);\r\n        }\r\n        else if (useCameraPostProcess) {\r\n            scene.postProcessManager._finalizeFrame(false, this._texture, faceIndex);\r\n        }\r\n\r\n        if (!this._doNotChangeAspectRatio) {\r\n            scene.updateTransformMatrix(true);\r\n        }\r\n\r\n        // Dump ?\r\n        if (dumpForDebug) {\r\n            Tools.DumpFramebuffer(this.getRenderWidth(), this.getRenderHeight(), engine);\r\n        }\r\n\r\n        // Unbind\r\n        if (!this.isCube || faceIndex === 5) {\r\n            if (this.isCube) {\r\n\r\n                if (faceIndex === 5) {\r\n                    engine.generateMipMapsForCubemap(this._texture);\r\n                }\r\n            }\r\n\r\n            this.unbindFrameBuffer(engine, faceIndex);\r\n\r\n        } else {\r\n            this.onAfterRenderObservable.notifyObservers(faceIndex);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Overrides the default sort function applied in the renderging group to prepare the meshes.\r\n     * This allowed control for front to back rendering or reversly depending of the special needs.\r\n     *\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\r\n     * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\r\n     * @param transparentSortCompareFn The transparent queue comparison function use to sort.\r\n     */\r\n    public setRenderingOrder(renderingGroupId: number,\r\n        opaqueSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        alphaTestSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        transparentSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null): void {\r\n\r\n        this._renderingManager.setRenderingOrder(renderingGroupId,\r\n            opaqueSortCompareFn,\r\n            alphaTestSortCompareFn,\r\n            transparentSortCompareFn);\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\r\n     *\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\r\n     */\r\n    public setRenderingAutoClearDepthStencil(renderingGroupId: number, autoClearDepthStencil: boolean): void {\r\n        this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);\r\n        this._renderingManager._useSceneAutoClearSetup = false;\r\n    }\r\n\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): RenderTargetTexture {\r\n        var textureSize = this.getSize();\r\n        var newTexture = new RenderTargetTexture(\r\n            this.name,\r\n            textureSize,\r\n            this.getScene(),\r\n            this._renderTargetOptions.generateMipMaps,\r\n            this._doNotChangeAspectRatio,\r\n            this._renderTargetOptions.type,\r\n            this.isCube,\r\n            this._renderTargetOptions.samplingMode,\r\n            this._renderTargetOptions.generateDepthBuffer,\r\n            this._renderTargetOptions.generateStencilBuffer\r\n        );\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // RenderTarget Texture\r\n        newTexture.coordinatesMode = this.coordinatesMode;\r\n        if (this.renderList) {\r\n            newTexture.renderList = this.renderList.slice(0);\r\n        }\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Serialize the texture to a JSON representation we can easily use in the resepective Parse function.\r\n     * @returns The JSON representation of the texture\r\n     */\r\n    public serialize(): any {\r\n        if (!this.name) {\r\n            return null;\r\n        }\r\n\r\n        var serializationObject = super.serialize();\r\n\r\n        serializationObject.renderTargetSize = this.getRenderSize();\r\n        serializationObject.renderList = [];\r\n\r\n        if (this.renderList) {\r\n            for (var index = 0; index < this.renderList.length; index++) {\r\n                serializationObject.renderList.push(this.renderList[index].id);\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     *  This will remove the attached framebuffer objects. The texture will not be able to be used as render target anymore\r\n     */\r\n    public disposeFramebufferObjects(): void {\r\n        let objBuffer = this.getInternalTexture();\r\n        let scene = this.getScene();\r\n        if (objBuffer && scene) {\r\n            scene.getEngine()._releaseFramebufferObjects(objBuffer);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        this.onResizeObservable.clear();\r\n        this.onClearObservable.clear();\r\n        this.onAfterRenderObservable.clear();\r\n        this.onAfterUnbindObservable.clear();\r\n        this.onBeforeBindObservable.clear();\r\n        this.onBeforeRenderObservable.clear();\r\n\r\n        if (this._postProcessManager) {\r\n            this._postProcessManager.dispose();\r\n            this._postProcessManager = null;\r\n        }\r\n\r\n        this.clearPostProcesses(true);\r\n\r\n        if (this._resizeObserver) {\r\n            this.getScene()!.getEngine().onResizeObservable.remove(this._resizeObserver);\r\n            this._resizeObserver = null;\r\n        }\r\n\r\n        this.renderList = null;\r\n\r\n        // Remove from custom render targets\r\n        var scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        var index = scene.customRenderTargets.indexOf(this);\r\n\r\n        if (index >= 0) {\r\n            scene.customRenderTargets.splice(index, 1);\r\n        }\r\n\r\n        for (var camera of scene.cameras) {\r\n            index = camera.customRenderTargets.indexOf(this);\r\n\r\n            if (index >= 0) {\r\n                camera.customRenderTargets.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        if (this.depthStencilTexture) {\r\n            this.getScene()!.getEngine()._releaseTexture(this.depthStencilTexture);\r\n        }\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    /** @hidden */\r\n    public _rebuild(): void {\r\n        if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {\r\n            this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;\r\n        }\r\n\r\n        if (this._postProcessManager) {\r\n            this._postProcessManager._rebuild();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear the info related to rendering groups preventing retention point in material dispose.\r\n     */\r\n    public freeRenderingGroups(): void {\r\n        if (this._renderingManager) {\r\n            this._renderingManager.freeRenderingGroups();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the number of views the corresponding to the texture (eg. a MultiviewRenderTarget will have > 1)\r\n     * @returns the view count\r\n     */\r\n    public getViewCount() {\r\n        return 1;\r\n    }\r\n}\r\n\r\nTexture._CreateRenderTargetTexture = (name: string, renderTargetSize: number, scene: Scene, generateMipMaps: boolean) => {\r\n    return new RenderTargetTexture(name, renderTargetSize, scene, generateMipMaps);\r\n};\r\n","import { Nullable } from \"../types\";\r\nimport { serializeAsVector3, serialize } from \"../Misc/decorators\";\r\nimport { Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { TargetCamera } from \"./targetCamera\";\r\nimport { FreeCameraInputsManager } from \"./freeCameraInputsManager\";\r\nimport { FreeCameraMouseInput } from \"../Cameras/Inputs/freeCameraMouseInput\";\r\nimport { FreeCameraKeyboardMoveInput } from \"../Cameras/Inputs/freeCameraKeyboardMoveInput\";\r\n\r\ndeclare type Collider = import(\"../Collisions/collider\").Collider;\r\n\r\n/**\r\n * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\r\n * Please consider using the new UniversalCamera instead as it adds more functionality like the gamepad.\r\n * @see https://doc.babylonjs.com/features/cameras#universal-camera\r\n */\r\nexport class FreeCamera extends TargetCamera {\r\n    /**\r\n     * Define the collision ellipsoid of the camera.\r\n     * This is helpful to simulate a camera body like the player body around the camera\r\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity#arcrotatecamera\r\n     */\r\n    @serializeAsVector3()\r\n    public ellipsoid = new Vector3(0.5, 1, 0.5);\r\n\r\n    /**\r\n     * Define an offset for the position of the ellipsoid around the camera.\r\n     * This can be helpful to determine the center of the body near the gravity center of the body\r\n     * instead of its head.\r\n     */\r\n    @serializeAsVector3()\r\n    public ellipsoidOffset = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Enable or disable collisions of the camera with the rest of the scene objects.\r\n     */\r\n    @serialize()\r\n    public checkCollisions = false;\r\n\r\n    /**\r\n     * Enable or disable gravity on the camera.\r\n     */\r\n    @serialize()\r\n    public applyGravity = false;\r\n\r\n    /**\r\n     * Define the input manager associated to the camera.\r\n     */\r\n    public inputs: FreeCameraInputsManager;\r\n\r\n    /**\r\n     * Gets the input sensibility for a mouse input. (default is 2000.0)\r\n     * Higher values reduce sensitivity.\r\n     */\r\n    public get angularSensibility(): number {\r\n        var mouse = <FreeCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            return mouse.angularSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the input sensibility for a mouse input. (default is 2000.0)\r\n     * Higher values reduce sensitivity.\r\n     */\r\n    public set angularSensibility(value: number) {\r\n        var mouse = <FreeCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            mouse.angularSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the forward move of the camera.\r\n     */\r\n    public get keysUp(): number[] {\r\n        var keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUp;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysUp(value: number[]) {\r\n        var keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUp = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the upward move of the camera.\r\n     */\r\n    public get keysUpward(): number[] {\r\n        var keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUpward;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysUpward(value: number[]) {\r\n        var keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUpward = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the backward move of the camera.\r\n     */\r\n    public get keysDown(): number[] {\r\n        var keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDown;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysDown(value: number[]) {\r\n        var keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDown = value;\r\n        }\r\n    }\r\n\r\n     /**\r\n     * Gets or Set the list of keyboard keys used to control the downward move of the camera.\r\n     */\r\n    public get keysDownward(): number[] {\r\n        var keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDownward;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysDownward(value: number[]) {\r\n        var keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDownward = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.\r\n     */\r\n    public get keysLeft(): number[] {\r\n        var keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysLeft;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysLeft(value: number[]) {\r\n        var keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysLeft = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.\r\n     */\r\n    public get keysRight(): number[] {\r\n        var keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRight;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRight(value: number[]) {\r\n        var keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRight = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Event raised when the camera collide with a mesh in the scene.\r\n     */\r\n    public onCollide: (collidedMesh: AbstractMesh) => void;\r\n\r\n    private _collider: Collider;\r\n    private _needMoveForGravity = false;\r\n    private _oldPosition = Vector3.Zero();\r\n    private _diffPosition = Vector3.Zero();\r\n    private _newPosition = Vector3.Zero();\r\n\r\n    /** @hidden */\r\n    public _localDirection: Vector3;\r\n    /** @hidden */\r\n    public _transformedDirection: Vector3;\r\n\r\n    /**\r\n     * Instantiates a Free Camera.\r\n     * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\r\n     * Please consider using the new UniversalCamera instead as it adds more functionality like touch to this camera.\r\n     * @see https://doc.babylonjs.com/features/cameras#universal-camera\r\n     * @param name Define the name of the camera in the scene\r\n     * @param position Define the start position of the camera in the scene\r\n     * @param scene Define the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines wheter the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    constructor(name: string, position: Vector3, scene: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\r\n        this.inputs = new FreeCameraInputsManager(this);\r\n        this.inputs.addKeyboard().addMouse();\r\n    }\r\n\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param element Defines the element the controls should be listened from\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(element: HTMLElement, noPreventDefault?: boolean): void {\r\n        this.inputs.attachElement(element, noPreventDefault);\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the camera.\r\n     * The camera will stop reacting to inputs.\r\n     * @param element Defines the element to stop listening the inputs from\r\n     */\r\n    public detachControl(element: HTMLElement): void {\r\n        this.inputs.detachElement(element);\r\n\r\n        this.cameraDirection = new Vector3(0, 0, 0);\r\n        this.cameraRotation = new Vector2(0, 0);\r\n    }\r\n\r\n    // Collisions\r\n    private _collisionMask = -1;\r\n\r\n    /**\r\n     * Define a collision mask to limit the list of object the camera can collide with\r\n     */\r\n    public get collisionMask(): number {\r\n        return this._collisionMask;\r\n    }\r\n\r\n    public set collisionMask(mask: number) {\r\n        this._collisionMask = !isNaN(mask) ? mask : -1;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _collideWithWorld(displacement: Vector3): void {\r\n        var globalPosition: Vector3;\r\n\r\n        if (this.parent) {\r\n            globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());\r\n        } else {\r\n            globalPosition = this.position;\r\n        }\r\n\r\n        globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);\r\n        this._oldPosition.addInPlace(this.ellipsoidOffset);\r\n\r\n        let coordinator = this.getScene().collisionCoordinator;\r\n        if (!this._collider) {\r\n            this._collider = coordinator.createCollider();\r\n        }\r\n\r\n        this._collider._radius = this.ellipsoid;\r\n        this._collider.collisionMask = this._collisionMask;\r\n\r\n        //no need for clone, as long as gravity is not on.\r\n        var actualDisplacement = displacement;\r\n\r\n        //add gravity to the direction to prevent the dual-collision checking\r\n        if (this.applyGravity) {\r\n            //this prevents mending with cameraDirection, a global variable of the free camera class.\r\n            actualDisplacement = displacement.add(this.getScene().gravity);\r\n        }\r\n\r\n        coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\r\n\r\n    }\r\n\r\n    private _onCollisionPositionChange = (collisionId: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh> = null) => {\r\n\r\n        var updatePosition = (newPos: Vector3) => {\r\n            this._newPosition.copyFrom(newPos);\r\n\r\n            this._newPosition.subtractToRef(this._oldPosition, this._diffPosition);\r\n\r\n            if (this._diffPosition.length() > Engine.CollisionsEpsilon) {\r\n                this.position.addInPlace(this._diffPosition);\r\n                if (this.onCollide && collidedMesh) {\r\n                    this.onCollide(collidedMesh);\r\n                }\r\n            }\r\n        };\r\n\r\n        updatePosition(newPosition);\r\n    }\r\n\r\n    /** @hidden */\r\n    public _checkInputs(): void {\r\n        if (!this._localDirection) {\r\n            this._localDirection = Vector3.Zero();\r\n            this._transformedDirection = Vector3.Zero();\r\n        }\r\n\r\n        this.inputs.checkInputs();\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    /** @hidden */\r\n    public _decideIfNeedsToMove(): boolean {\r\n        return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _updatePosition(): void {\r\n        if (this.checkCollisions && this.getScene().collisionsEnabled) {\r\n            this._collideWithWorld(this.cameraDirection);\r\n        } else {\r\n            super._updatePosition();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy the camera and release the current resources hold by it.\r\n     */\r\n    public dispose(): void {\r\n        this.inputs.clear();\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @return the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCamera\";\r\n    }\r\n}\r\n"],"sourceRoot":""}