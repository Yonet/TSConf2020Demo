{"version":3,"sources":["webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/clipPlaneFragment.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/morphTargetsVertex.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/clipPlaneVertex.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/lightFragmentDeclaration.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/lightUboDeclaration.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/imageProcessingDeclaration.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/imageProcessingFunctions.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration.ts","webpack:///../../../sourceES6/core/Materials/pushMaterial.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/logDepthDeclaration.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/fogFragmentDeclaration.ts","webpack:///../../../sourceES6/core/Materials/thinMaterialHelper.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/shadowsFragmentFunctions.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/reflectionFunction.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/bumpFragmentMainFunctions.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/bumpFragmentFunctions.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/bumpFragment.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/lightFragment.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/fogFragment.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/fogVertexDeclaration.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/shadowsVertex.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/lightsFragmentFunctions.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/logDepthFragment.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/bumpVertex.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/fogVertex.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/logDepthVertex.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/prePassDeclaration.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/fresnelFunction.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/depthPrePass.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/bumpVertexDeclaration.ts","webpack:///../../../sourceES6/core/Materials/material.detailMapConfiguration.ts","webpack:///../../../sourceES6/core/Materials/materialHelper.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/defaultFragmentDeclaration.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/defaultUboDeclaration.ts","webpack:///../../../sourceES6/core/Shaders/default.fragment.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/defaultVertexDeclaration.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/pointCloudVertex.ts","webpack:///../../../sourceES6/core/Shaders/default.vertex.ts","webpack:///../../../sourceES6/core/Materials/standardMaterial.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/helperFunctions.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/bonesDeclaration.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/instancesDeclaration.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/instancesVertex.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/bonesVertex.ts","webpack:///../../../sourceES6/core/Materials/materialFlags.ts","webpack:///../../../sourceES6/core/Materials/shaderMaterial.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/morphTargetsVertexGlobalDeclaration.ts","webpack:///../../../../sourceES6/core/Shaders/ShadersInclude/morphTargetsVertexDeclaration.ts","webpack:///../../../sourceES6/core/Materials/effectFallbacks.ts"],"names":["name","shader","IncludesShadersStore","scene","_normalMatrix","_storeEffectOnSubMeshes","getEffect","this","_activeEffect","isReady","mesh","useInstances","subMeshes","length","isReadyForSubMesh","_isReadyForSubMesh","subMesh","defines","_materialDefines","checkReadyOnEveryCall","effect","_renderId","getScene","getRenderId","bindOnlyWorldMatrix","world","setMatrix","bindOnlyNormalMatrix","normalMatrix","bind","bindForSubMesh","_afterBind","_cachedEffect","_mustRebind","visibility","isCachedMaterialInvalid","BindClipPlane","holder","clipPlane","setFloat4","normal","x","y","z","d","clipPlane2","clipPlane3","clipPlane4","clipPlane5","clipPlane6","markAllSubMeshesAsTexturesDirty","_texture","diffuseBlendLevel","roughnessBlendLevel","bumpLevel","_normalBlendMethod","MATERIAL_NORMALBLENDMETHOD_WHITEOUT","_isEnabled","isEnabled","_internalMarkAllSubMeshesAsTexturesDirty","_markAllSubMeshesAsTexturesDirty","engine","getEngine","_areTexturesDirty","texturesEnabled","getCaps","standardDerivatives","DetailTextureEnabled","prepareDefines","DETAIL_NORMALBLENDMETHOD","PrepareDefinesForMergedUV","DETAIL","uniformBuffer","isFrozen","useUbo","isSync","updateFloat4","coordinatesIndex","BindTextureMatrix","setTexture","hasTexture","texture","getActiveTextures","activeTextures","push","getAnimatables","animatables","animations","dispose","forceDisposeTextures","getClassName","AddUniforms","uniforms","AddSamplers","samplers","PrepareUniformBuffer","addUniform","copyTo","detailMap","Clone","serialize","Serialize","parse","source","rootUrl","Parse","BindEyePosition","variableName","_forcedViewPosition","setVector3","globalPosition","activeCamera","devicePosition","_mirroredCameraPosition","key","_needUVs","getTextureMatrix","isIdentityAs3x2","matrix","updateMatrix","GetFogState","fogEnabled","applyFog","fogMode","FOGMODE_NONE","PrepareDefinesForMisc","useLogarithmicDepth","pointsCloud","alphaTest","_areMiscDirty","nonUniformScaling","PrepareDefinesForFrameBoundValues","useClipPlane","useThinInstances","useClipPlane1","useClipPlane2","useClipPlane3","useClipPlane4","useClipPlane5","useClipPlane6","changed","undefined","getColorWrite","markAsUnprocessed","PrepareDefinesForBones","useBones","computeBonesUsingShaders","skeleton","numBoneInfluencers","materialSupportsBoneTexture","isUsingTextureForMatrices","bones","PrepareDefinesForMorphTargets","manager","morphTargetManager","supportsUVs","supportsTangents","supportsNormals","numInfluencers","PrepareDefinesForAttributes","useVertexColor","useMorphTargets","useVertexAlpha","_areAttributesDirty","_needNormals","_normals","_uvs","isVerticesDataPresent","NormalKind","TangentKind","UVKind","UV2Kind","hasVertexColors","useVertexColors","ColorKind","hasVertexAlpha","PrepareDefinesForMultiview","previousMultiview","MULTIVIEW","outputRenderTarget","getViewCount","PrepareDefinesForPrePass","canRenderToMRT","previousPrePass","PREPASS","prePassRenderer","enabled","SCENE_MRT_COUNT","mrtCount","irradianceIndex","getIndex","PREPASS_IRRADIANCE","PREPASS_IRRADIANCE_INDEX","albedoIndex","PREPASS_ALBEDO","PREPASS_ALBEDO_INDEX","depthNormalIndex","PREPASS_DEPTHNORMAL","PREPASS_DEPTHNORMAL_INDEX","markAsImageProcessingDirty","PrepareDefinesForLight","light","lightIndex","specularSupported","state","needNormals","needRebuild","prepareLightSpecificDefines","falloffType","FALLOFF_GLTF","FALLOFF_PHYSICAL","FALLOFF_STANDARD","specular","equalsFloats","specularEnabled","receiveShadows","shadowsEnabled","shadowEnabled","shadowGenerator","getShadowGenerator","shadowMap","getShadowMap","renderList","lightmapMode","LIGHTMAP_DEFAULT","LIGHTMAP_SHADOWSONLY","PrepareDefinesForLights","maxSimultaneousLights","disableLighting","_areLightsDirty","lightsEnabled","lightSources","index","caps","textureFloatRender","textureFloatLinearFiltering","textureHalfFloatRender","textureHalfFloatLinearFiltering","rebuild","PrepareUniformsAndSamplersForLight","uniformsList","samplersList","projectedLightTexture","uniformBuffersList","PrepareUniformsAndSamplersList","uniformsListOrOptions","uniformsNames","options","uniformBuffersNames","HandleFallbacksForShadows","fallbacks","rank","lightFallbackRank","addFallback","PrepareAttributesForMorphTargetsInfluencers","attribs","influencers","_TmpMorphInfluencers","NUM_MORPH_INFLUENCERS","PrepareAttributesForMorphTargets","LastCreatedEngine","maxAttributesCount","maxVertexAttribs","tangent","uv","PositionKind","Error","PrepareAttributesForBones","addCPUSkinningFallback","MatricesIndicesKind","MatricesWeightsKind","MatricesIndicesExtraKind","MatricesWeightsExtraKind","PrepareAttributesForInstances","PushAttributesForInstances","BindLightProperties","transferToEffect","BindLight","useSpecular","rebuildInParallel","_bindLight","BindLights","len","Math","min","i","BindFogParameters","linearSpace","fogStart","fogEnd","fogDensity","fogColor","toLinearSpaceToRef","_tempFogColor","setColor3","BindBonesParameters","_bonesComputationForcedToCPU","getUniformIndex","boneTexture","getTransformMatrixTexture","setFloat","matrices","getTransformMatrices","setMatrices","BindMorphTargetParameters","abstractMesh","setFloatArray","influences","BindLogDepth","log","maxZ","LN2","Black","ShadersStore","onCreatedEffectParameters","MAINUV1","MAINUV2","DIFFUSE","DIFFUSEDIRECTUV","DETAILDIRECTUV","AMBIENT","AMBIENTDIRECTUV","OPACITY","OPACITYDIRECTUV","OPACITYRGB","REFLECTION","EMISSIVE","EMISSIVEDIRECTUV","SPECULAR","SPECULARDIRECTUV","BUMP","BUMPDIRECTUV","PARALLAX","PARALLAXOCCLUSION","SPECULAROVERALPHA","CLIPPLANE","CLIPPLANE2","CLIPPLANE3","CLIPPLANE4","CLIPPLANE5","CLIPPLANE6","ALPHATEST","DEPTHPREPASS","ALPHAFROMDIFFUSE","POINTSIZE","FOG","SPECULARTERM","DIFFUSEFRESNEL","OPACITYFRESNEL","REFLECTIONFRESNEL","REFRACTIONFRESNEL","EMISSIVEFRESNEL","FRESNEL","NORMAL","UV1","UV2","VERTEXCOLOR","VERTEXALPHA","NUM_BONE_INFLUENCERS","BonesPerMesh","BONETEXTURE","INSTANCES","THIN_INSTANCES","GLOSSINESS","ROUGHNESS","EMISSIVEASILLUMINATION","LINKEMISSIVEWITHDIFFUSE","REFLECTIONFRESNELFROMSPECULAR","LIGHTMAP","LIGHTMAPDIRECTUV","OBJECTSPACE_NORMALMAP","USELIGHTMAPASSHADOWMAP","REFLECTIONMAP_3D","REFLECTIONMAP_SPHERICAL","REFLECTIONMAP_PLANAR","REFLECTIONMAP_CUBIC","USE_LOCAL_REFLECTIONMAP_CUBIC","REFLECTIONMAP_PROJECTION","REFLECTIONMAP_SKYBOX","REFLECTIONMAP_EXPLICIT","REFLECTIONMAP_EQUIRECTANGULAR","REFLECTIONMAP_EQUIRECTANGULAR_FIXED","REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED","INVERTCUBICMAP","LOGARITHMICDEPTH","REFRACTION","REFRACTIONMAP_3D","REFLECTIONOVERALPHA","TWOSIDEDLIGHTING","SHADOWFLOAT","MORPHTARGETS","MORPHTARGETS_NORMAL","MORPHTARGETS_TANGENT","MORPHTARGETS_UV","NONUNIFORMSCALING","PREMULTIPLYALPHA","ALPHATEST_AFTERALLALPHACOMPUTATIONS","ALPHABLEND","RGBDLIGHTMAP","RGBDREFLECTION","RGBDREFRACTION","IMAGEPROCESSING","VIGNETTE","VIGNETTEBLENDMODEMULTIPLY","VIGNETTEBLENDMODEOPAQUE","TONEMAPPING","TONEMAPPING_ACES","CONTRAST","COLORCURVES","COLORGRADING","COLORGRADING3D","SAMPLER3DGREENDEPTH","SAMPLER3DBGRMAP","IMAGEPROCESSINGPOSTPROCESS","IS_REFLECTION_LINEAR","IS_REFRACTION_LINEAR","EXPOSURE","setReflectionMode","modeToEnable","mode","_diffuseTexture","_ambientTexture","_opacityTexture","_reflectionTexture","_emissiveTexture","_specularTexture","_bumpTexture","_lightmapTexture","_refractionTexture","ambientColor","diffuseColor","specularColor","emissiveColor","specularPower","_useAlphaFromDiffuseTexture","_useEmissiveAsIllumination","_linkEmissiveWithDiffuse","_useSpecularOverAlpha","_useReflectionOverAlpha","_disableLighting","_useObjectSpaceNormalMap","_useParallax","_useParallaxOcclusion","parallaxScaleBias","_roughness","indexOfRefraction","invertRefractionY","alphaCutOff","_useLightmapAsShadowmap","_useReflectionFresnelFromSpecular","_useGlossinessFromSpecularMapAlpha","_maxSimultaneousLights","_invertNormalMapX","_invertNormalMapY","_twoSidedLighting","_renderTargets","_worldViewProjectionMatrix","Zero","_globalAmbientColor","_rebuildInParallel","_attachImageProcessingConfiguration","getRenderTargetTextures","reset","StandardMaterial","ReflectionTextureEnabled","isRenderTarget","RefractionTextureEnabled","_imageProcessingConfiguration","value","configuration","_imageProcessingObserver","onUpdateParameters","remove","imageProcessingConfiguration","add","_markAllSubMeshesAsImageProcessingDirty","colorCurvesEnabled","colorGradingEnabled","toneMappingEnabled","exposure","contrast","colorGradingTexture","colorCurves","_useLogarithmicDepth","fragmentDepthSupported","_markAllSubMeshesAsMiscDirty","needAlphaBlending","_disableAlphaBlending","alpha","_shouldUseAlphaFromDiffuseTexture","_opacityFresnelParameters","needAlphaTesting","_forceAlphaTest","hasAlpha","_transparencyMode","MATERIAL_ALPHATEST","MATERIAL_OPAQUE","getAlphaTestTexture","_wasPreviouslyReady","DiffuseTextureEnabled","isReadyOrNotBlocking","AmbientTextureEnabled","OpacityTextureEnabled","getAlphaFromRGB","coordinatesMode","INVCUBIC_MODE","isCube","isRGBD","EXPLICIT_MODE","PLANAR_MODE","PROJECTION_MODE","SKYBOX_MODE","SPHERICAL_MODE","EQUIRECTANGULAR_MODE","FIXED_EQUIRECTANGULAR_MODE","FIXED_EQUIRECTANGULAR_MIRRORED_MODE","CUBIC_MODE","boundingBoxSize","EmissiveTextureEnabled","LightmapTextureEnabled","SpecularTextureEnabled","BumpTextureEnabled","_backFaceCulling","alphaMode","transparencyMode","needAlphaBlendingForMesh","_areImageProcessingDirty","reflectionTexture","gammaSpace","refractionTexture","_areFresnelDirty","FresnelEnabled","_diffuseFresnelParameters","_emissiveFresnelParameters","_refractionFresnelParameters","_reflectionFresnelParameters","_shouldTurnAlphaTestOn","getRenderingMesh","hasThinInstances","isDirty","lightDisposed","_areLightsDisposed","markAsProcessed","shaderName","uniformBuffers","PrepareUniforms","PrepareSamplers","csnrOptions","customShaderNameResolve","join","toString","previousEffect","createEffect","attributes","onCompiled","onError","indexParameters","maxSimultaneousMorphTargets","processFinalCode","multiTarget","_onEffectCreatedObservable","notifyObservers","allowShaderHotSwapping","resetCachedMaterial","setEffect","buildUniformLayout","ubo","_uniformBuffer","create","unbind","needFlag","toNormalMatrix","mustRebind","bindToEffect","bindViewProjection","diffuseFresnelParameters","updateColor4","leftColor","power","rightColor","bias","opacityFresnelParameters","toLuminance","reflectionFresnelParameters","refractionFresnelParameters","emissiveFresnelParameters","updateFloat2","level","roughness","getReflectionTextureMatrix","cubeTexture","updateVector3","boundingBoxPosition","updateFloat3","depth","updateFloat","pointSize","updateColor3","BlackReadOnly","multiplyToRef","bindView","applyByPostProcess","update","results","forceDisposeEffect","clone","result","id","ColorGradingTextureEnabled","RegisteredTypes","DefaultMaterialFactory","_DiffuseTextureEnabled","MarkAllMaterialsAsDirty","_DetailTextureEnabled","_AmbientTextureEnabled","_OpacityTextureEnabled","_ReflectionTextureEnabled","_EmissiveTextureEnabled","_SpecularTextureEnabled","_BumpTextureEnabled","_LightmapTextureEnabled","_RefractionTextureEnabled","_ColorGradingTextureEnabled","_FresnelEnabled","_ClearCoatTextureEnabled","_ClearCoatBumpTextureEnabled","_ClearCoatTintTextureEnabled","_SheenTextureEnabled","_AnisotropicTextureEnabled","_ThicknessTextureEnabled","shaderPath","_textures","_textureArrays","_floats","_ints","_floatsArrays","_colors3","_colors3Arrays","_colors4","_colors4Arrays","_vectors2","_vectors3","_vectors4","_matrices","_matrixArrays","_matrices3x3","_matrices2x2","_vectors2Arrays","_vectors3Arrays","_vectors4Arrays","_cachedWorldViewMatrix","_cachedWorldViewProjectionMatrix","_multiview","_shaderPath","_options","_checkUniform","uniformName","indexOf","setTextureArray","textures","setInt","setFloats","setColor3Array","reduce","arr","color","toArray","setColor4","setColor4Array","setVector2","setVector4","float32Array","Float32Array","copyToArray","setMatrix3x3","setMatrix2x2","setArray2","setArray3","setArray4","_checkCache","_effect","multiview","slice","_cachedDefines","effectOverride","getViewMatrix","getTransformMatrix","_effectOverride","getCachedMaterial","getProjectionMatrix","_transformMatrixR","setArray","r","g","b","a","seffect","array","ShaderMaterial","Object","keys","forEach","propName","propValue","Array","isArray","notBoundToMesh","serializationObject","customType","textureArrays","floats","FloatArrays","colors3","asArray","colors3Arrays","colors4","colors4Arrays","vectors2","vectors3","vectors4","matrixArray","matrices3x3","matrices2x2","vectors2Arrays","vectors3Arrays","vectors4Arrays","material","textureArray","floatsArrays","FromArray","colors","num","map","ParseFromFileAsync","url","Promise","resolve","reject","request","addEventListener","readyState","status","JSON","responseText","output","LastCreatedScene","open","send","CreateFromSnippetAsync","snippetId","snippet","jsonPayload","shaderMaterial","SnippetUrl","replace","_defines","_currentRank","_maxRank","_mesh","unBindMesh","define","currentDefines","meshes","otherMesh","currentFallbacks"],"mappings":"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","file":"js/1.babylonBundle.js","sourcesContent":["import { Effect } from \"../../Materials/effect\";\n\nlet name = 'clipPlaneFragment';\nlet shader = `#ifdef CLIPPLANE\nif (fClipDistance>0.0)\n{\ndiscard;\n}\n#endif\n#ifdef CLIPPLANE2\nif (fClipDistance2>0.0)\n{\ndiscard;\n}\n#endif\n#ifdef CLIPPLANE3\nif (fClipDistance3>0.0)\n{\ndiscard;\n}\n#endif\n#ifdef CLIPPLANE4\nif (fClipDistance4>0.0)\n{\ndiscard;\n}\n#endif\n#ifdef CLIPPLANE5\nif (fClipDistance5>0.0)\n{\ndiscard;\n}\n#endif\n#ifdef CLIPPLANE6\nif (fClipDistance6>0.0)\n{\ndiscard;\n}\n#endif`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var clipPlaneFragment = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'morphTargetsVertex';\nlet shader = `#ifdef MORPHTARGETS\npositionUpdated+=(position{X}-position)*morphTargetInfluences[{X}];\n#ifdef MORPHTARGETS_NORMAL\nnormalUpdated+=(normal{X}-normal)*morphTargetInfluences[{X}];\n#endif\n#ifdef MORPHTARGETS_TANGENT\ntangentUpdated.xyz+=(tangent{X}-tangent.xyz)*morphTargetInfluences[{X}];\n#endif\n#ifdef MORPHTARGETS_UV\nuvUpdated+=(uv_{X}-uv)*morphTargetInfluences[{X}];\n#endif\n#endif`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var morphTargetsVertex = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'clipPlaneVertex';\nlet shader = `#ifdef CLIPPLANE\nfClipDistance=dot(worldPos,vClipPlane);\n#endif\n#ifdef CLIPPLANE2\nfClipDistance2=dot(worldPos,vClipPlane2);\n#endif\n#ifdef CLIPPLANE3\nfClipDistance3=dot(worldPos,vClipPlane3);\n#endif\n#ifdef CLIPPLANE4\nfClipDistance4=dot(worldPos,vClipPlane4);\n#endif\n#ifdef CLIPPLANE5\nfClipDistance5=dot(worldPos,vClipPlane5);\n#endif\n#ifdef CLIPPLANE6\nfClipDistance6=dot(worldPos,vClipPlane6);\n#endif`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var clipPlaneVertex = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'lightFragmentDeclaration';\nlet shader = `#ifdef LIGHT{X}\nuniform vec4 vLightData{X};\nuniform vec4 vLightDiffuse{X};\n#ifdef SPECULARTERM\nuniform vec4 vLightSpecular{X};\n#else\nvec4 vLightSpecular{X}=vec4(0.);\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float cascadeBlendFactor{X};\nvarying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying vec4 vPositionFromCamera{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\nuniform highp sampler2DArray depthSampler{X};\nuniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float penumbraDarkness{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\n#else\nuniform highp sampler2DArray shadowSampler{X};\n#endif\n#ifdef SHADOWCSMDEBUG{X}\nconst vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]\n(\nvec3 ( 1.5,0.0,0.0 ),\nvec3 ( 0.0,1.5,0.0 ),\nvec3 ( 0.0,0.0,5.5 ),\nvec3 ( 1.5,0.0,5.5 ),\nvec3 ( 1.5,1.5,0.0 ),\nvec3 ( 1.0,1.0,1.0 ),\nvec3 ( 0.0,1.0,5.5 ),\nvec3 ( 0.5,3.5,0.75 )\n);\nvec3 shadowDebug{X};\n#endif\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nint index{X}=-1;\n#else\nint index{X}=SHADOWCSMNUM_CASCADES{X}-1;\n#endif\nfloat diff{X}=0.;\n#elif defined(SHADOWCUBE{X})\nuniform samplerCube shadowSampler{X};\n#else\nvarying vec4 vPositionFromLight{X};\nvarying float vDepthMetric{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DShadow shadowSampler{X};\nuniform highp sampler2D depthSampler{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DShadow shadowSampler{X};\n#else\nuniform sampler2D shadowSampler{X};\n#endif\nuniform mat4 lightMatrix{X};\n#endif\nuniform vec4 shadowsInfo{X};\nuniform vec2 depthValues{X};\n#endif\n#ifdef SPOTLIGHT{X}\nuniform vec4 vLightDirection{X};\nuniform vec4 vLightFalloff{X};\n#elif defined(POINTLIGHT{X})\nuniform vec4 vLightFalloff{X};\n#elif defined(HEMILIGHT{X})\nuniform vec3 vLightGround{X};\n#endif\n#ifdef PROJECTEDLIGHTTEXTURE{X}\nuniform mat4 textureProjectionMatrix{X};\nuniform sampler2D projectionLightSampler{X};\n#endif\n#endif`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var lightFragmentDeclaration = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'lightUboDeclaration';\nlet shader = `#ifdef LIGHT{X}\nuniform Light{X}\n{\nvec4 vLightData;\nvec4 vLightDiffuse;\nvec4 vLightSpecular;\n#ifdef SPOTLIGHT{X}\nvec4 vLightDirection;\nvec4 vLightFalloff;\n#elif defined(POINTLIGHT{X})\nvec4 vLightFalloff;\n#elif defined(HEMILIGHT{X})\nvec3 vLightGround;\n#endif\nvec4 shadowsInfo;\nvec2 depthValues;\n} light{X};\n#ifdef PROJECTEDLIGHTTEXTURE{X}\nuniform mat4 textureProjectionMatrix{X};\nuniform sampler2D projectionLightSampler{X};\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float cascadeBlendFactor{X};\nvarying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying vec4 vPositionFromCamera{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\nuniform highp sampler2DArray depthSampler{X};\nuniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float penumbraDarkness{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\n#else\nuniform highp sampler2DArray shadowSampler{X};\n#endif\n#ifdef SHADOWCSMDEBUG{X}\nconst vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]\n(\nvec3 ( 1.5,0.0,0.0 ),\nvec3 ( 0.0,1.5,0.0 ),\nvec3 ( 0.0,0.0,5.5 ),\nvec3 ( 1.5,0.0,5.5 ),\nvec3 ( 1.5,1.5,0.0 ),\nvec3 ( 1.0,1.0,1.0 ),\nvec3 ( 0.0,1.0,5.5 ),\nvec3 ( 0.5,3.5,0.75 )\n);\nvec3 shadowDebug{X};\n#endif\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nint index{X}=-1;\n#else\nint index{X}=SHADOWCSMNUM_CASCADES{X}-1;\n#endif\nfloat diff{X}=0.;\n#elif defined(SHADOWCUBE{X})\nuniform samplerCube shadowSampler{X};\n#else\nvarying vec4 vPositionFromLight{X};\nvarying float vDepthMetric{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DShadow shadowSampler{X};\nuniform highp sampler2D depthSampler{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DShadow shadowSampler{X};\n#else\nuniform sampler2D shadowSampler{X};\n#endif\nuniform mat4 lightMatrix{X};\n#endif\n#endif\n#endif`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var lightUboDeclaration = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'imageProcessingDeclaration';\nlet shader = `#ifdef EXPOSURE\nuniform float exposureLinear;\n#endif\n#ifdef CONTRAST\nuniform float contrast;\n#endif\n#ifdef VIGNETTE\nuniform vec2 vInverseScreenSize;\nuniform vec4 vignetteSettings1;\nuniform vec4 vignetteSettings2;\n#endif\n#ifdef COLORCURVES\nuniform vec4 vCameraColorCurveNegative;\nuniform vec4 vCameraColorCurveNeutral;\nuniform vec4 vCameraColorCurvePositive;\n#endif\n#ifdef COLORGRADING\n#ifdef COLORGRADING3D\nuniform highp sampler3D txColorTransform;\n#else\nuniform sampler2D txColorTransform;\n#endif\nuniform vec4 colorTransformSettings;\n#endif`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var imageProcessingDeclaration = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'imageProcessingFunctions';\nlet shader = `#if defined(COLORGRADING) && !defined(COLORGRADING3D)\n\n#define inline\nvec3 sampleTexture3D(sampler2D colorTransform,vec3 color,vec2 sampler3dSetting)\n{\nfloat sliceSize=2.0*sampler3dSetting.x;\n#ifdef SAMPLER3DGREENDEPTH\nfloat sliceContinuous=(color.g-sampler3dSetting.x)*sampler3dSetting.y;\n#else\nfloat sliceContinuous=(color.b-sampler3dSetting.x)*sampler3dSetting.y;\n#endif\nfloat sliceInteger=floor(sliceContinuous);\n\n\nfloat sliceFraction=sliceContinuous-sliceInteger;\n#ifdef SAMPLER3DGREENDEPTH\nvec2 sliceUV=color.rb;\n#else\nvec2 sliceUV=color.rg;\n#endif\nsliceUV.x*=sliceSize;\nsliceUV.x+=sliceInteger*sliceSize;\nsliceUV=saturate(sliceUV);\nvec4 slice0Color=texture2D(colorTransform,sliceUV);\nsliceUV.x+=sliceSize;\nsliceUV=saturate(sliceUV);\nvec4 slice1Color=texture2D(colorTransform,sliceUV);\nvec3 result=mix(slice0Color.rgb,slice1Color.rgb,sliceFraction);\n#ifdef SAMPLER3DBGRMAP\ncolor.rgb=result.rgb;\n#else\ncolor.rgb=result.bgr;\n#endif\nreturn color;\n}\n#endif\n#ifdef TONEMAPPING_ACES\n\n\n\n\n\nconst mat3 ACESInputMat=mat3(\nvec3(0.59719,0.07600,0.02840),\nvec3(0.35458,0.90834,0.13383),\nvec3(0.04823,0.01566,0.83777)\n);\n\nconst mat3 ACESOutputMat=mat3(\nvec3( 1.60475,-0.10208,-0.00327),\nvec3(-0.53108,1.10813,-0.07276),\nvec3(-0.07367,-0.00605,1.07602)\n);\nvec3 RRTAndODTFit(vec3 v)\n{\nvec3 a=v*(v+0.0245786)-0.000090537;\nvec3 b=v*(0.983729*v+0.4329510)+0.238081;\nreturn a/b;\n}\nvec3 ACESFitted(vec3 color)\n{\ncolor=ACESInputMat*color;\n\ncolor=RRTAndODTFit(color);\ncolor=ACESOutputMat*color;\n\ncolor=saturate(color);\nreturn color;\n}\n#endif\nvec4 applyImageProcessing(vec4 result) {\n#ifdef EXPOSURE\nresult.rgb*=exposureLinear;\n#endif\n#ifdef VIGNETTE\n\nvec2 viewportXY=gl_FragCoord.xy*vInverseScreenSize;\nviewportXY=viewportXY*2.0-1.0;\nvec3 vignetteXY1=vec3(viewportXY*vignetteSettings1.xy+vignetteSettings1.zw,1.0);\nfloat vignetteTerm=dot(vignetteXY1,vignetteXY1);\nfloat vignette=pow(vignetteTerm,vignetteSettings2.w);\n\nvec3 vignetteColor=vignetteSettings2.rgb;\n#ifdef VIGNETTEBLENDMODEMULTIPLY\nvec3 vignetteColorMultiplier=mix(vignetteColor,vec3(1,1,1),vignette);\nresult.rgb*=vignetteColorMultiplier;\n#endif\n#ifdef VIGNETTEBLENDMODEOPAQUE\nresult.rgb=mix(vignetteColor,result.rgb,vignette);\n#endif\n#endif\n#ifdef TONEMAPPING\n#ifdef TONEMAPPING_ACES\nresult.rgb=ACESFitted(result.rgb);\n#else\nconst float tonemappingCalibration=1.590579;\nresult.rgb=1.0-exp2(-tonemappingCalibration*result.rgb);\n#endif\n#endif\n\nresult.rgb=toGammaSpace(result.rgb);\nresult.rgb=saturate(result.rgb);\n#ifdef CONTRAST\n\nvec3 resultHighContrast=result.rgb*result.rgb*(3.0-2.0*result.rgb);\nif (contrast<1.0) {\n\nresult.rgb=mix(vec3(0.5,0.5,0.5),result.rgb,contrast);\n} else {\n\nresult.rgb=mix(result.rgb,resultHighContrast,contrast-1.0);\n}\n#endif\n\n#ifdef COLORGRADING\nvec3 colorTransformInput=result.rgb*colorTransformSettings.xxx+colorTransformSettings.yyy;\n#ifdef COLORGRADING3D\nvec3 colorTransformOutput=texture(txColorTransform,colorTransformInput).rgb;\n#else\nvec3 colorTransformOutput=sampleTexture3D(txColorTransform,colorTransformInput,colorTransformSettings.yz).rgb;\n#endif\nresult.rgb=mix(result.rgb,colorTransformOutput,colorTransformSettings.www);\n#endif\n#ifdef COLORCURVES\n\nfloat luma=getLuminance(result.rgb);\nvec2 curveMix=clamp(vec2(luma*3.0-1.5,luma*-3.0+1.5),vec2(0.0),vec2(1.0));\nvec4 colorCurve=vCameraColorCurveNeutral+curveMix.x*vCameraColorCurvePositive-curveMix.y*vCameraColorCurveNegative;\nresult.rgb*=colorCurve.rgb;\nresult.rgb=mix(vec3(luma),result.rgb,colorCurve.a);\n#endif\nreturn result;\n}`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var imageProcessingFunctions = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'clipPlaneFragmentDeclaration';\nlet shader = `#ifdef CLIPPLANE\nvarying float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nvarying float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nvarying float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nvarying float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nvarying float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nvarying float fClipDistance6;\n#endif`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var clipPlaneFragmentDeclaration = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'clipPlaneVertexDeclaration';\nlet shader = `#ifdef CLIPPLANE\nuniform vec4 vClipPlane;\nvarying float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nuniform vec4 vClipPlane2;\nvarying float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nuniform vec4 vClipPlane3;\nvarying float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nuniform vec4 vClipPlane4;\nvarying float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nuniform vec4 vClipPlane5;\nvarying float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nuniform vec4 vClipPlane6;\nvarying float fClipDistance6;\n#endif`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var clipPlaneVertexDeclaration = { name, shader };\n","import { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Matrix } from \"../Maths/math.vector\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { SubMesh } from '../Meshes/subMesh';\r\n/**\r\n * Base class of materials working in push mode in babylon JS\r\n * @hidden\r\n */\r\nexport class PushMaterial extends Material {\r\n\r\n    protected _activeEffect: Effect;\r\n\r\n    protected _normalMatrix: Matrix = new Matrix();\r\n\r\n    constructor(name: string, scene: Scene) {\r\n        super(name, scene);\r\n        this._storeEffectOnSubMeshes = true;\r\n    }\r\n\r\n    public getEffect(): Effect {\r\n        return this._activeEffect;\r\n    }\r\n\r\n    public isReady(mesh?: AbstractMesh, useInstances?: boolean): boolean {\r\n        if (!mesh) {\r\n            return false;\r\n        }\r\n\r\n        if (!mesh.subMeshes || mesh.subMeshes.length === 0) {\r\n            return true;\r\n        }\r\n\r\n        return this.isReadyForSubMesh(mesh, mesh.subMeshes[0], useInstances);\r\n    }\r\n\r\n    protected _isReadyForSubMesh(subMesh: SubMesh) {\r\n        const defines = subMesh._materialDefines;\r\n        if (!this.checkReadyOnEveryCall && subMesh.effect && defines) {\r\n            if (defines._renderId === this.getScene().getRenderId()) {\r\n                    return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * Binds the given world matrix to the active effect\r\n    *\r\n    * @param world the matrix to bind\r\n    */\r\n    public bindOnlyWorldMatrix(world: Matrix): void {\r\n        this._activeEffect.setMatrix(\"world\", world);\r\n    }\r\n\r\n    /**\r\n     * Binds the given normal matrix to the active effect\r\n     *\r\n     * @param normalMatrix the matrix to bind\r\n     */\r\n    public bindOnlyNormalMatrix(normalMatrix: Matrix): void {\r\n        this._activeEffect.setMatrix(\"normalMatrix\", normalMatrix);\r\n    }\r\n\r\n    public bind(world: Matrix, mesh?: Mesh): void {\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n\r\n        this.bindForSubMesh(world, mesh, mesh.subMeshes[0]);\r\n    }\r\n\r\n    protected _afterBind(mesh: Mesh, effect: Nullable<Effect> = null): void {\r\n        super._afterBind(mesh);\r\n        this.getScene()._cachedEffect = effect;\r\n    }\r\n\r\n    protected _mustRebind(scene: Scene, effect: Effect, visibility: number = 1) {\r\n        return scene.isCachedMaterialInvalid(this, effect, visibility);\r\n    }\r\n}\r\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'logDepthDeclaration';\nlet shader = `#ifdef LOGARITHMICDEPTH\nuniform float logarithmicDepthConstant;\nvarying float vFragmentDepth;\n#endif`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var logDepthDeclaration = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'fogFragmentDeclaration';\nlet shader = `#ifdef FOG\n#define FOGMODE_NONE 0.\n#define FOGMODE_EXP 1.\n#define FOGMODE_EXP2 2.\n#define FOGMODE_LINEAR 3.\n#define E 2.71828\nuniform vec4 vFogInfos;\nuniform vec3 vFogColor;\nvarying vec3 vFogDistance;\nfloat CalcFogFactor()\n{\nfloat fogCoeff=1.0;\nfloat fogStart=vFogInfos.y;\nfloat fogEnd=vFogInfos.z;\nfloat fogDensity=vFogInfos.w;\nfloat fogDistance=length(vFogDistance);\nif (FOGMODE_LINEAR == vFogInfos.x)\n{\nfogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);\n}\nelse if (FOGMODE_EXP == vFogInfos.x)\n{\nfogCoeff=1.0/pow(E,fogDistance*fogDensity);\n}\nelse if (FOGMODE_EXP2 == vFogInfos.x)\n{\nfogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);\n}\nreturn clamp(fogCoeff,0.0,1.0);\n}\n#endif`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var fogFragmentDeclaration = { name, shader };\n","import { Effect } from './effect';\r\nimport { IClipPlanesHolder } from '../Misc/interfaces/iClipPlanesHolder';\r\n\r\n/**\r\n * \"Static Class\" containing a few commonly used helper while dealing with material for rendering purpose.\r\n *\r\n * It is complementary with MaterialHelper but provides completely independent functions (for tree shaking sake)\r\n *\r\n * This works by convention in BabylonJS but is meant to be use only with shader following the in place naming rules and conventions.\r\n */\r\nexport class ThinMaterialHelper {\r\n    /**\r\n     * Binds the clip plane information from the holder to the effect.\r\n     * @param effect The effect we are binding the data to\r\n     * @param holder The entity containing the clip plane information\r\n     */\r\n    public static BindClipPlane(effect: Effect, holder: IClipPlanesHolder): void {\r\n        if (holder.clipPlane) {\r\n            let clipPlane = holder.clipPlane;\r\n            effect.setFloat4(\"vClipPlane\", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);\r\n        }\r\n        if (holder.clipPlane2) {\r\n            let clipPlane = holder.clipPlane2;\r\n            effect.setFloat4(\"vClipPlane2\", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);\r\n        }\r\n        if (holder.clipPlane3) {\r\n            let clipPlane = holder.clipPlane3;\r\n            effect.setFloat4(\"vClipPlane3\", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);\r\n        }\r\n        if (holder.clipPlane4) {\r\n            let clipPlane = holder.clipPlane4;\r\n            effect.setFloat4(\"vClipPlane4\", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);\r\n        }\r\n        if (holder.clipPlane5) {\r\n            let clipPlane = holder.clipPlane5;\r\n            effect.setFloat4(\"vClipPlane5\", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);\r\n        }\r\n        if (holder.clipPlane6) {\r\n            let clipPlane = holder.clipPlane6;\r\n            effect.setFloat4(\"vClipPlane6\", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);\r\n        }\r\n    }\r\n}","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'shadowsFragmentFunctions';\nlet shader = `#ifdef SHADOWS\n#ifndef SHADOWFLOAT\n\nfloat unpack(vec4 color)\n{\nconst vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);\nreturn dot(color,bit_shift);\n}\n#endif\nfloat computeFallOff(float value,vec2 clipSpace,float frustumEdgeFalloff)\n{\nfloat mask=smoothstep(1.0-frustumEdgeFalloff,1.00000012,clamp(dot(clipSpace,clipSpace),0.,1.));\nreturn mix(value,1.0,mask);\n}\n#define inline\nfloat computeShadowCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,vec2 depthValues)\n{\nvec3 directionToLight=vPositionW-lightPosition;\nfloat depth=length(directionToLight);\ndepth=(depth+depthValues.x)/(depthValues.y);\ndepth=clamp(depth,0.,1.0);\ndirectionToLight=normalize(directionToLight);\ndirectionToLight.y=-directionToLight.y;\n#ifndef SHADOWFLOAT\nfloat shadow=unpack(textureCube(shadowSampler,directionToLight));\n#else\nfloat shadow=textureCube(shadowSampler,directionToLight).x;\n#endif\nreturn depth>shadow ? darkness : 1.0;\n}\n#define inline\nfloat computeShadowWithPoissonSamplingCube(vec3 lightPosition,samplerCube shadowSampler,float mapSize,float darkness,vec2 depthValues)\n{\nvec3 directionToLight=vPositionW-lightPosition;\nfloat depth=length(directionToLight);\ndepth=(depth+depthValues.x)/(depthValues.y);\ndepth=clamp(depth,0.,1.0);\ndirectionToLight=normalize(directionToLight);\ndirectionToLight.y=-directionToLight.y;\nfloat visibility=1.;\nvec3 poissonDisk[4];\npoissonDisk[0]=vec3(-1.0,1.0,-1.0);\npoissonDisk[1]=vec3(1.0,-1.0,-1.0);\npoissonDisk[2]=vec3(-1.0,-1.0,-1.0);\npoissonDisk[3]=vec3(1.0,-1.0,1.0);\n\n#ifndef SHADOWFLOAT\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize))<depth) visibility-=0.25;\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize))<depth) visibility-=0.25;\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize))<depth) visibility-=0.25;\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize))<depth) visibility-=0.25;\n#else\nif (textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<depth) visibility-=0.25;\nif (textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<depth) visibility-=0.25;\nif (textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<depth) visibility-=0.25;\nif (textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<depth) visibility-=0.25;\n#endif\nreturn min(1.0,visibility+darkness);\n}\n#define inline\nfloat computeShadowWithESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\n{\nvec3 directionToLight=vPositionW-lightPosition;\nfloat depth=length(directionToLight);\ndepth=(depth+depthValues.x)/(depthValues.y);\nfloat shadowPixelDepth=clamp(depth,0.,1.0);\ndirectionToLight=normalize(directionToLight);\ndirectionToLight.y=-directionToLight.y;\n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\n#else\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\n#endif\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);\nreturn esm;\n}\n#define inline\nfloat computeShadowWithCloseESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\n{\nvec3 directionToLight=vPositionW-lightPosition;\nfloat depth=length(directionToLight);\ndepth=(depth+depthValues.x)/(depthValues.y);\nfloat shadowPixelDepth=clamp(depth,0.,1.0);\ndirectionToLight=normalize(directionToLight);\ndirectionToLight.y=-directionToLight.y;\n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\n#else\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\n#endif\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);\nreturn esm;\n}\n#ifdef WEBGL2\n#define inline\nfloat computeShadowCSM(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray shadowSampler,float darkness,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\nvec3 uvLayer=vec3(uv.x,uv.y,layer);\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nfloat shadow=unpack(texture2D(shadowSampler,uvLayer));\n#else\nfloat shadow=texture2D(shadowSampler,uvLayer).x;\n#endif\nreturn shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;\n}\n#endif\n#define inline\nfloat computeShadow(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{\nreturn 1.0;\n}\nelse\n{\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nfloat shadow=unpack(texture2D(shadowSampler,uv));\n#else\nfloat shadow=texture2D(shadowSampler,uv).x;\n#endif\nreturn shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;\n}\n}\n#define inline\nfloat computeShadowWithPoissonSampling(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float mapSize,float darkness,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{\nreturn 1.0;\n}\nelse\n{\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\nfloat visibility=1.;\nvec2 poissonDisk[4];\npoissonDisk[0]=vec2(-0.94201624,-0.39906216);\npoissonDisk[1]=vec2(0.94558609,-0.76890725);\npoissonDisk[2]=vec2(-0.094184101,-0.92938870);\npoissonDisk[3]=vec2(0.34495938,0.29387760);\n\n#ifndef SHADOWFLOAT\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[0]*mapSize))<shadowPixelDepth) visibility-=0.25;\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[1]*mapSize))<shadowPixelDepth) visibility-=0.25;\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[2]*mapSize))<shadowPixelDepth) visibility-=0.25;\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[3]*mapSize))<shadowPixelDepth) visibility-=0.25;\n#else\nif (texture2D(shadowSampler,uv+poissonDisk[0]*mapSize).x<shadowPixelDepth) visibility-=0.25;\nif (texture2D(shadowSampler,uv+poissonDisk[1]*mapSize).x<shadowPixelDepth) visibility-=0.25;\nif (texture2D(shadowSampler,uv+poissonDisk[2]*mapSize).x<shadowPixelDepth) visibility-=0.25;\nif (texture2D(shadowSampler,uv+poissonDisk[3]*mapSize).x<shadowPixelDepth) visibility-=0.25;\n#endif\nreturn computeFallOff(min(1.0,visibility+darkness),clipSpace.xy,frustumEdgeFalloff);\n}\n}\n#define inline\nfloat computeShadowWithESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{\nreturn 1.0;\n}\nelse\n{\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(texture2D(shadowSampler,uv));\n#else\nfloat shadowMapSample=texture2D(shadowSampler,uv).x;\n#endif\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);\nreturn computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);\n}\n}\n#define inline\nfloat computeShadowWithCloseESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{\nreturn 1.0;\n}\nelse\n{\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(texture2D(shadowSampler,uv));\n#else\nfloat shadowMapSample=texture2D(shadowSampler,uv).x;\n#endif\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);\nreturn computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);\n}\n}\n#ifdef WEBGL2\n#define GREATEST_LESS_THAN_ONE 0.99999994\n\n#define inline\nfloat computeShadowWithCSMPCF1(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,float darkness,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nuvDepth.z=clamp(uvDepth.z,0.,GREATEST_LESS_THAN_ONE);\nvec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);\nfloat shadow=texture(shadowSampler,uvDepthLayer);\nshadow=mix(darkness,1.,shadow);\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n\n\n\n#define inline\nfloat computeShadowWithCSMPCF3(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nuvDepth.z=clamp(uvDepth.z,0.,GREATEST_LESS_THAN_ONE);\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x;\nuv+=0.5;\nvec2 st=fract(uv);\nvec2 base_uv=floor(uv)-0.5;\nbase_uv*=shadowMapSizeAndInverse.y;\n\n\n\n\nvec2 uvw0=3.-2.*st;\nvec2 uvw1=1.+2.*st;\nvec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;\nvec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;\nfloat shadow=0.;\nshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));\nshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));\nshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));\nshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));\nshadow=shadow/16.;\nshadow=mix(darkness,1.,shadow);\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n\n\n\n#define inline\nfloat computeShadowWithCSMPCF5(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nuvDepth.z=clamp(uvDepth.z,0.,GREATEST_LESS_THAN_ONE);\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x;\nuv+=0.5;\nvec2 st=fract(uv);\nvec2 base_uv=floor(uv)-0.5;\nbase_uv*=shadowMapSizeAndInverse.y;\n\n\nvec2 uvw0=4.-3.*st;\nvec2 uvw1=vec2(7.);\nvec2 uvw2=1.+3.*st;\nvec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;\nvec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;\nfloat shadow=0.;\nshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));\nshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));\nshadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[0]),layer,uvDepth.z));\nshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));\nshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));\nshadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[1]),layer,uvDepth.z));\nshadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[2]),layer,uvDepth.z));\nshadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[2]),layer,uvDepth.z));\nshadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[2]),layer,uvDepth.z));\nshadow=shadow/144.;\nshadow=mix(darkness,1.,shadow);\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n\n#define inline\nfloat computeShadowWithPCF1(vec4 vPositionFromLight,float depthMetric,sampler2DShadow shadowSampler,float darkness,float frustumEdgeFalloff)\n{\nif (depthMetric>1.0 || depthMetric<0.0) {\nreturn 1.0;\n}\nelse\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nfloat shadow=texture2D(shadowSampler,uvDepth);\nshadow=mix(darkness,1.,shadow);\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n}\n\n\n\n#define inline\nfloat computeShadowWithPCF3(vec4 vPositionFromLight,float depthMetric,sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{\nif (depthMetric>1.0 || depthMetric<0.0) {\nreturn 1.0;\n}\nelse\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x;\nuv+=0.5;\nvec2 st=fract(uv);\nvec2 base_uv=floor(uv)-0.5;\nbase_uv*=shadowMapSizeAndInverse.y;\n\n\n\n\nvec2 uvw0=3.-2.*st;\nvec2 uvw1=1.+2.*st;\nvec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;\nvec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;\nfloat shadow=0.;\nshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z));\nshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z));\nshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z));\nshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z));\nshadow=shadow/16.;\nshadow=mix(darkness,1.,shadow);\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n}\n\n\n\n#define inline\nfloat computeShadowWithPCF5(vec4 vPositionFromLight,float depthMetric,sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{\nif (depthMetric>1.0 || depthMetric<0.0) {\nreturn 1.0;\n}\nelse\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x;\nuv+=0.5;\nvec2 st=fract(uv);\nvec2 base_uv=floor(uv)-0.5;\nbase_uv*=shadowMapSizeAndInverse.y;\n\n\nvec2 uvw0=4.-3.*st;\nvec2 uvw1=vec2(7.);\nvec2 uvw2=1.+3.*st;\nvec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;\nvec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;\nfloat shadow=0.;\nshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z));\nshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z));\nshadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[0]),uvDepth.z));\nshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z));\nshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z));\nshadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[1]),uvDepth.z));\nshadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[2]),uvDepth.z));\nshadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[2]),uvDepth.z));\nshadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[2]),uvDepth.z));\nshadow=shadow/144.;\nshadow=mix(darkness,1.,shadow);\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n}\nconst vec3 PoissonSamplers32[64]=vec3[64](\nvec3(0.06407013,0.05409927,0.),\nvec3(0.7366577,0.5789394,0.),\nvec3(-0.6270542,-0.5320278,0.),\nvec3(-0.4096107,0.8411095,0.),\nvec3(0.6849564,-0.4990818,0.),\nvec3(-0.874181,-0.04579735,0.),\nvec3(0.9989998,0.0009880066,0.),\nvec3(-0.004920578,-0.9151649,0.),\nvec3(0.1805763,0.9747483,0.),\nvec3(-0.2138451,0.2635818,0.),\nvec3(0.109845,0.3884785,0.),\nvec3(0.06876755,-0.3581074,0.),\nvec3(0.374073,-0.7661266,0.),\nvec3(0.3079132,-0.1216763,0.),\nvec3(-0.3794335,-0.8271583,0.),\nvec3(-0.203878,-0.07715034,0.),\nvec3(0.5912697,0.1469799,0.),\nvec3(-0.88069,0.3031784,0.),\nvec3(0.5040108,0.8283722,0.),\nvec3(-0.5844124,0.5494877,0.),\nvec3(0.6017799,-0.1726654,0.),\nvec3(-0.5554981,0.1559997,0.),\nvec3(-0.3016369,-0.3900928,0.),\nvec3(-0.5550632,-0.1723762,0.),\nvec3(0.925029,0.2995041,0.),\nvec3(-0.2473137,0.5538505,0.),\nvec3(0.9183037,-0.2862392,0.),\nvec3(0.2469421,0.6718712,0.),\nvec3(0.3916397,-0.4328209,0.),\nvec3(-0.03576927,-0.6220032,0.),\nvec3(-0.04661255,0.7995201,0.),\nvec3(0.4402924,0.3640312,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.)\n);\nconst vec3 PoissonSamplers64[64]=vec3[64](\nvec3(-0.613392,0.617481,0.),\nvec3(0.170019,-0.040254,0.),\nvec3(-0.299417,0.791925,0.),\nvec3(0.645680,0.493210,0.),\nvec3(-0.651784,0.717887,0.),\nvec3(0.421003,0.027070,0.),\nvec3(-0.817194,-0.271096,0.),\nvec3(-0.705374,-0.668203,0.),\nvec3(0.977050,-0.108615,0.),\nvec3(0.063326,0.142369,0.),\nvec3(0.203528,0.214331,0.),\nvec3(-0.667531,0.326090,0.),\nvec3(-0.098422,-0.295755,0.),\nvec3(-0.885922,0.215369,0.),\nvec3(0.566637,0.605213,0.),\nvec3(0.039766,-0.396100,0.),\nvec3(0.751946,0.453352,0.),\nvec3(0.078707,-0.715323,0.),\nvec3(-0.075838,-0.529344,0.),\nvec3(0.724479,-0.580798,0.),\nvec3(0.222999,-0.215125,0.),\nvec3(-0.467574,-0.405438,0.),\nvec3(-0.248268,-0.814753,0.),\nvec3(0.354411,-0.887570,0.),\nvec3(0.175817,0.382366,0.),\nvec3(0.487472,-0.063082,0.),\nvec3(-0.084078,0.898312,0.),\nvec3(0.488876,-0.783441,0.),\nvec3(0.470016,0.217933,0.),\nvec3(-0.696890,-0.549791,0.),\nvec3(-0.149693,0.605762,0.),\nvec3(0.034211,0.979980,0.),\nvec3(0.503098,-0.308878,0.),\nvec3(-0.016205,-0.872921,0.),\nvec3(0.385784,-0.393902,0.),\nvec3(-0.146886,-0.859249,0.),\nvec3(0.643361,0.164098,0.),\nvec3(0.634388,-0.049471,0.),\nvec3(-0.688894,0.007843,0.),\nvec3(0.464034,-0.188818,0.),\nvec3(-0.440840,0.137486,0.),\nvec3(0.364483,0.511704,0.),\nvec3(0.034028,0.325968,0.),\nvec3(0.099094,-0.308023,0.),\nvec3(0.693960,-0.366253,0.),\nvec3(0.678884,-0.204688,0.),\nvec3(0.001801,0.780328,0.),\nvec3(0.145177,-0.898984,0.),\nvec3(0.062655,-0.611866,0.),\nvec3(0.315226,-0.604297,0.),\nvec3(-0.780145,0.486251,0.),\nvec3(-0.371868,0.882138,0.),\nvec3(0.200476,0.494430,0.),\nvec3(-0.494552,-0.711051,0.),\nvec3(0.612476,0.705252,0.),\nvec3(-0.578845,-0.768792,0.),\nvec3(-0.772454,-0.090976,0.),\nvec3(0.504440,0.372295,0.),\nvec3(0.155736,0.065157,0.),\nvec3(0.391522,0.849605,0.),\nvec3(-0.620106,-0.328104,0.),\nvec3(0.789239,-0.419965,0.),\nvec3(-0.545396,0.538133,0.),\nvec3(-0.178564,-0.596057,0.)\n);\n\n\n\n\n\n#define inline\nfloat computeShadowWithCSMPCSS(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nuvDepth.z=clamp(uvDepth.z,0.,GREATEST_LESS_THAN_ONE);\nvec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);\nfloat blockerDepth=0.0;\nfloat sumBlockerDepth=0.0;\nfloat numBlocker=0.0;\nfor (int i=0; i<searchTapCount; i ++) {\nblockerDepth=texture(depthSampler,vec3(uvDepth.xy+(lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse*PoissonSamplers32[i].xy),layer)).r;\nif (blockerDepth<depthMetric) {\nsumBlockerDepth+=blockerDepth;\nnumBlocker++;\n}\n}\nif (numBlocker<1.0) {\nreturn 1.0;\n}\nelse\n{\nfloat avgBlockerDepth=sumBlockerDepth/numBlocker;\n\nfloat AAOffset=shadowMapSizeInverse*10.;\n\n\nfloat penumbraRatio=((depthMetric-avgBlockerDepth)*depthCorrection+AAOffset);\nvec4 filterRadius=vec4(penumbraRatio*lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse,0.,0.);\nfloat random=getRand(vPositionFromLight.xy);\nfloat rotationAngle=random*3.1415926;\nvec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));\nfloat shadow=0.;\nfor (int i=0; i<pcfTapCount; i++) {\nvec4 offset=vec4(poissonSamplers[i],0.);\n\noffset=vec4(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.,0.);\nshadow+=texture2D(shadowSampler,uvDepthLayer+offset*filterRadius);\n}\nshadow/=float(pcfTapCount);\n\nshadow=mix(shadow,1.,min((depthMetric-avgBlockerDepth)*depthCorrection*penumbraDarkness,1.));\n\nshadow=mix(darkness,1.,shadow);\n\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n}\n\n\n\n\n\n#define inline\nfloat computeShadowWithPCSS(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers)\n{\nif (depthMetric>1.0 || depthMetric<0.0) {\nreturn 1.0;\n}\nelse\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nfloat blockerDepth=0.0;\nfloat sumBlockerDepth=0.0;\nfloat numBlocker=0.0;\nfor (int i=0; i<searchTapCount; i ++) {\nblockerDepth=texture(depthSampler,uvDepth.xy+(lightSizeUV*shadowMapSizeInverse*PoissonSamplers32[i].xy)).r;\nif (blockerDepth<depthMetric) {\nsumBlockerDepth+=blockerDepth;\nnumBlocker++;\n}\n}\nif (numBlocker<1.0) {\nreturn 1.0;\n}\nelse\n{\nfloat avgBlockerDepth=sumBlockerDepth/numBlocker;\n\nfloat AAOffset=shadowMapSizeInverse*10.;\n\n\nfloat penumbraRatio=((depthMetric-avgBlockerDepth)+AAOffset);\nfloat filterRadius=penumbraRatio*lightSizeUV*shadowMapSizeInverse;\nfloat random=getRand(vPositionFromLight.xy);\nfloat rotationAngle=random*3.1415926;\nvec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));\nfloat shadow=0.;\nfor (int i=0; i<pcfTapCount; i++) {\nvec3 offset=poissonSamplers[i];\n\noffset=vec3(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.);\nshadow+=texture2D(shadowSampler,uvDepth+offset*filterRadius);\n}\nshadow/=float(pcfTapCount);\n\nshadow=mix(shadow,1.,depthMetric-avgBlockerDepth);\n\nshadow=mix(darkness,1.,shadow);\n\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n}\n}\n#define inline\nfloat computeShadowWithPCSS16(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\n{\nreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32);\n}\n#define inline\nfloat computeShadowWithPCSS32(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\n{\nreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32);\n}\n#define inline\nfloat computeShadowWithPCSS64(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\n{\nreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64);\n}\n#define inline\nfloat computeShadowWithCSMPCSS16(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{\nreturn computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);\n}\n#define inline\nfloat computeShadowWithCSMPCSS32(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{\nreturn computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);\n}\n#define inline\nfloat computeShadowWithCSMPCSS64(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{\nreturn computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64,lightSizeUVCorrection,depthCorrection,penumbraDarkness);\n}\n#endif\n#endif\n`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var shadowsFragmentFunctions = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'reflectionFunction';\nlet shader = `vec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {\n\nvec3 invOrigVec=vec3(1.0,1.0,1.0)/origVec;\nvec3 halfSize=cubeSize*0.5;\nvec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;\nvec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;\n\nvec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);\n\nfloat distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);\n\nvec3 intersectPositionWS=vertexPos+origVec*distance;\n\nreturn intersectPositionWS-cubePos;\n}\nvec3 computeFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)\n{\nfloat lon=atan(direction.z,direction.x);\nfloat lat=acos(direction.y);\nvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\nfloat s=sphereCoords.x*0.5+0.5;\nfloat t=sphereCoords.y;\nreturn vec3(s,t,0);\n}\nvec3 computeMirroredFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)\n{\nfloat lon=atan(direction.z,direction.x);\nfloat lat=acos(direction.y);\nvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\nfloat s=sphereCoords.x*0.5+0.5;\nfloat t=sphereCoords.y;\nreturn vec3(1.0-s,t,0);\n}\nvec3 computeEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\n{\nvec3 cameraToVertex=normalize(worldPos.xyz-eyePosition);\nvec3 r=normalize(reflect(cameraToVertex,worldNormal));\nr=vec3(reflectionMatrix*vec4(r,0));\nfloat lon=atan(r.z,r.x);\nfloat lat=acos(r.y);\nvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\nfloat s=sphereCoords.x*0.5+0.5;\nfloat t=sphereCoords.y;\nreturn vec3(s,t,0);\n}\nvec3 computeSphericalCoords(vec4 worldPos,vec3 worldNormal,mat4 view,mat4 reflectionMatrix)\n{\nvec3 viewDir=normalize(vec3(view*worldPos));\nvec3 viewNormal=normalize(vec3(view*vec4(worldNormal,0.0)));\nvec3 r=reflect(viewDir,viewNormal);\nr=vec3(reflectionMatrix*vec4(r,0));\nr.z=r.z-1.0;\nfloat m=2.0*length(r);\nreturn vec3(r.x/m+0.5,1.0-r.y/m-0.5,0);\n}\nvec3 computePlanarCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\n{\nvec3 viewDir=worldPos.xyz-eyePosition;\nvec3 coords=normalize(reflect(viewDir,worldNormal));\nreturn vec3(reflectionMatrix*vec4(coords,1));\n}\nvec3 computeCubicCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\n{\nvec3 viewDir=normalize(worldPos.xyz-eyePosition);\n\nvec3 coords=reflect(viewDir,worldNormal);\ncoords=vec3(reflectionMatrix*vec4(coords,0));\n#ifdef INVERTCUBICMAP\ncoords.y*=-1.0;\n#endif\nreturn coords;\n}\nvec3 computeCubicLocalCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix,vec3 reflectionSize,vec3 reflectionPosition)\n{\nvec3 viewDir=normalize(worldPos.xyz-eyePosition);\n\nvec3 coords=reflect(viewDir,worldNormal);\ncoords=parallaxCorrectNormal(worldPos.xyz,coords,reflectionSize,reflectionPosition);\ncoords=vec3(reflectionMatrix*vec4(coords,0));\n#ifdef INVERTCUBICMAP\ncoords.y*=-1.0;\n#endif\nreturn coords;\n}\nvec3 computeProjectionCoords(vec4 worldPos,mat4 view,mat4 reflectionMatrix)\n{\nreturn vec3(reflectionMatrix*(view*worldPos));\n}\nvec3 computeSkyBoxCoords(vec3 positionW,mat4 reflectionMatrix)\n{\nreturn vec3(reflectionMatrix*vec4(positionW,1.));\n}\n#ifdef REFLECTION\nvec3 computeReflectionCoords(vec4 worldPos,vec3 worldNormal)\n{\n#ifdef REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\nvec3 direction=normalize(vDirectionW);\nreturn computeMirroredFixedEquirectangularCoords(worldPos,worldNormal,direction);\n#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED\nvec3 direction=normalize(vDirectionW);\nreturn computeFixedEquirectangularCoords(worldPos,worldNormal,direction);\n#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR\nreturn computeEquirectangularCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_SPHERICAL\nreturn computeSphericalCoords(worldPos,worldNormal,view,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_PLANAR\nreturn computePlanarCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_CUBIC\n#ifdef USE_LOCAL_REFLECTIONMAP_CUBIC\nreturn computeCubicLocalCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix,vReflectionSize,vReflectionPosition);\n#else\nreturn computeCubicCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\n#endif\n#endif\n#ifdef REFLECTIONMAP_PROJECTION\nreturn computeProjectionCoords(worldPos,view,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nreturn computeSkyBoxCoords(vPositionUVW,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_EXPLICIT\nreturn vec3(0,0,0);\n#endif\n}\n#endif`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var reflectionFunction = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'bumpFragmentMainFunctions';\nlet shader = `#if defined(BUMP) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC) || defined(DETAIL)\n#if defined(TANGENT) && defined(NORMAL)\nvarying mat3 vTBN;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\nuniform mat4 normalMatrix;\n#endif\nvec3 perturbNormalBase(mat3 cotangentFrame,vec3 normal,float scale)\n{\n#ifdef NORMALXYSCALE\nnormal=normalize(normal*vec3(scale,scale,1.0));\n#endif\nreturn normalize(cotangentFrame*normal);\n}\nvec3 perturbNormal(mat3 cotangentFrame,vec3 textureSample,float scale)\n{\nreturn perturbNormalBase(cotangentFrame,textureSample*2.0-1.0,scale);\n}\n\nmat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv,vec2 tangentSpaceParams)\n{\n\nuv=gl_FrontFacing ? uv : -uv;\n\nvec3 dp1=dFdx(p);\nvec3 dp2=dFdy(p);\nvec2 duv1=dFdx(uv);\nvec2 duv2=dFdy(uv);\n\nvec3 dp2perp=cross(dp2,normal);\nvec3 dp1perp=cross(normal,dp1);\nvec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;\nvec3 bitangent=dp2perp*duv1.y+dp1perp*duv2.y;\n\ntangent*=tangentSpaceParams.x;\nbitangent*=tangentSpaceParams.y;\n\nfloat invmax=inversesqrt(max(dot(tangent,tangent),dot(bitangent,bitangent)));\nreturn mat3(tangent*invmax,bitangent*invmax,normal);\n}\n#endif\n`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var bumpFragmentMainFunctions = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'bumpFragmentFunctions';\nlet shader = `#if defined(BUMP)\n#if BUMPDIRECTUV == 1\n#define vBumpUV vMainUV1\n#elif BUMPDIRECTUV == 2\n#define vBumpUV vMainUV2\n#else\nvarying vec2 vBumpUV;\n#endif\nuniform sampler2D bumpSampler;\nvec3 perturbNormal(mat3 cotangentFrame,vec2 uv)\n{\nreturn perturbNormal(cotangentFrame,texture2D(bumpSampler,uv).xyz,vBumpInfos.y);\n}\n#endif\n#if defined(DETAIL)\n#if DETAILDIRECTUV == 1\n#define vDetailUV vMainUV1\n#elif DETAILDIRECTUV == 2\n#define vDetailUV vMainUV2\n#else\nvarying vec2 vDetailUV;\n#endif\nuniform sampler2D detailSampler;\n#endif\n#if defined(BUMP)\nvec3 perturbNormal(mat3 cotangentFrame,vec3 color)\n{\nreturn perturbNormal(cotangentFrame,color,vBumpInfos.y);\n}\n\nmat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv)\n{\nreturn cotangent_frame(normal,p,uv,vTangentSpaceParams);\n}\n#endif\n#if defined(BUMP) && defined(PARALLAX)\nconst float minSamples=4.;\nconst float maxSamples=15.;\nconst int iMaxSamples=15;\n\nvec2 parallaxOcclusion(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale) {\nfloat parallaxLimit=length(vViewDirCoT.xy)/vViewDirCoT.z;\nparallaxLimit*=parallaxScale;\nvec2 vOffsetDir=normalize(vViewDirCoT.xy);\nvec2 vMaxOffset=vOffsetDir*parallaxLimit;\nfloat numSamples=maxSamples+(dot(vViewDirCoT,vNormalCoT)*(minSamples-maxSamples));\nfloat stepSize=1.0/numSamples;\n\nfloat currRayHeight=1.0;\nvec2 vCurrOffset=vec2(0,0);\nvec2 vLastOffset=vec2(0,0);\nfloat lastSampledHeight=1.0;\nfloat currSampledHeight=1.0;\nfor (int i=0; i<iMaxSamples; i++)\n{\ncurrSampledHeight=texture2D(bumpSampler,vBumpUV+vCurrOffset).w;\n\nif (currSampledHeight>currRayHeight)\n{\nfloat delta1=currSampledHeight-currRayHeight;\nfloat delta2=(currRayHeight+stepSize)-lastSampledHeight;\nfloat ratio=delta1/(delta1+delta2);\nvCurrOffset=(ratio)* vLastOffset+(1.0-ratio)*vCurrOffset;\n\nbreak;\n}\nelse\n{\ncurrRayHeight-=stepSize;\nvLastOffset=vCurrOffset;\nvCurrOffset+=stepSize*vMaxOffset;\nlastSampledHeight=currSampledHeight;\n}\n}\nreturn vCurrOffset;\n}\nvec2 parallaxOffset(vec3 viewDir,float heightScale)\n{\n\nfloat height=texture2D(bumpSampler,vBumpUV).w;\nvec2 texCoordOffset=heightScale*viewDir.xy*height;\nreturn -texCoordOffset;\n}\n#endif`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var bumpFragmentFunctions = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'bumpFragment';\nlet shader = `vec2 uvOffset=vec2(0.0,0.0);\n#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)\n#ifdef NORMALXYSCALE\nfloat normalScale=1.0;\n#elif defined(BUMP)\nfloat normalScale=vBumpInfos.y;\n#else\nfloat normalScale=1.0;\n#endif\n#if defined(TANGENT) && defined(NORMAL)\nmat3 TBN=vTBN;\n#elif defined(BUMP)\nmat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,vBumpUV);\n#else\nmat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,vDetailUV,vec2(1.,1.));\n#endif\n#elif defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL)\nmat3 TBN=vTBN;\n#else\nmat3 TBN=cotangent_frame(normalW,vPositionW,vMainUV1,vec2(1.,1.));\n#endif\n#endif\n#ifdef PARALLAX\nmat3 invTBN=transposeMat3(TBN);\n#ifdef PARALLAXOCCLUSION\nuvOffset=parallaxOcclusion(invTBN*-viewDirectionW,invTBN*normalW,vBumpUV,vBumpInfos.z);\n#else\nuvOffset=parallaxOffset(invTBN*viewDirectionW,vBumpInfos.z);\n#endif\n#endif\n#ifdef DETAIL\nvec4 detailColor=texture2D(detailSampler,vDetailUV+uvOffset);\nvec2 detailNormalRG=detailColor.wy*2.0-1.0;\nfloat detailNormalB=sqrt(1.-saturate(dot(detailNormalRG,detailNormalRG)));\nvec3 detailNormal=vec3(detailNormalRG,detailNormalB);\n#endif\n#ifdef BUMP\n#ifdef OBJECTSPACE_NORMALMAP\nnormalW=normalize(texture2D(bumpSampler,vBumpUV).xyz*2.0-1.0);\nnormalW=normalize(mat3(normalMatrix)*normalW);\n#elif !defined(DETAIL)\nnormalW=perturbNormal(TBN,vBumpUV+uvOffset);\n#else\nvec3 bumpNormal=texture2D(bumpSampler,vBumpUV+uvOffset).xyz*2.0-1.0;\n\n#if DETAIL_NORMALBLENDMETHOD == 0\ndetailNormal.xy*=vDetailInfos.z;\nvec3 blendedNormal=normalize(vec3(bumpNormal.xy+detailNormal.xy,bumpNormal.z*detailNormal.z));\n#elif DETAIL_NORMALBLENDMETHOD == 1\ndetailNormal.xy*=vDetailInfos.z;\nbumpNormal+=vec3(0.0,0.0,1.0);\ndetailNormal*=vec3(-1.0,-1.0,1.0);\nvec3 blendedNormal=bumpNormal*dot(bumpNormal,detailNormal)/bumpNormal.z-detailNormal;\n#endif\nnormalW=perturbNormalBase(TBN,blendedNormal,vBumpInfos.y);\n#endif\n#elif defined(DETAIL)\ndetailNormal.xy*=vDetailInfos.z;\nnormalW=perturbNormalBase(TBN,detailNormal,vDetailInfos.z);\n#endif`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var bumpFragment = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'lightFragment';\nlet shader = `#ifdef LIGHT{X}\n#if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})\n\n#else\n#ifdef PBR\n\n#ifdef SPOTLIGHT{X}\npreInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#elif defined(POINTLIGHT{X})\npreInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#elif defined(HEMILIGHT{X})\npreInfo=computeHemisphericPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#elif defined(DIRLIGHT{X})\npreInfo=computeDirectionalPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#endif\npreInfo.NdotV=NdotV;\n\n#ifdef SPOTLIGHT{X}\n#ifdef LIGHT_FALLOFF_GLTF{X}\npreInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\npreInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\n#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\npreInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\npreInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w);\n#elif defined(LIGHT_FALLOFF_STANDARD{X})\npreInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);\npreInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w);\n#else\npreInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\npreInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\n#endif\n#elif defined(POINTLIGHT{X})\n#ifdef LIGHT_FALLOFF_GLTF{X}\npreInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\n#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\npreInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\n#elif defined(LIGHT_FALLOFF_STANDARD{X})\npreInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);\n#else\npreInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\n#endif\n#else\npreInfo.attenuation=1.0;\n#endif\n\n\n#ifdef HEMILIGHT{X}\npreInfo.roughness=roughness;\n#else\npreInfo.roughness=adjustRoughnessFromLightProperties(roughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n#endif\n\n#ifdef HEMILIGHT{X}\ninfo.diffuse=computeHemisphericDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb,light{X}.vLightGround);\n#elif defined(SS_TRANSLUCENCY)\ninfo.diffuse=computeDiffuseAndTransmittedLighting(preInfo,light{X}.vLightDiffuse.rgb,subSurfaceOut.transmittance);\n#else\ninfo.diffuse=computeDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb);\n#endif\n\n#ifdef SPECULARTERM\n#ifdef ANISOTROPIC\ninfo.specular=computeAnisotropicSpecularLighting(preInfo,viewDirectionW,normalW,anisotropicOut.anisotropicTangent,anisotropicOut.anisotropicBitangent,anisotropicOut.anisotropy,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n#else\ninfo.specular=computeSpecularLighting(preInfo,normalW,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n#endif\n#endif\n\n#ifdef SHEEN\n#ifdef SHEEN_LINKWITHALBEDO\n\npreInfo.roughness=sheenOut.sheenIntensity;\n#else\n#ifdef HEMILIGHT{X}\npreInfo.roughness=sheenOut.sheenRoughness;\n#else\npreInfo.roughness=adjustRoughnessFromLightProperties(sheenOut.sheenRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n#endif\n#endif\ninfo.sheen=computeSheenLighting(preInfo,normalW,sheenOut.sheenColor,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n#endif\n\n#ifdef CLEARCOAT\n\n#ifdef HEMILIGHT{X}\npreInfo.roughness=clearcoatOut.clearCoatRoughness;\n#else\npreInfo.roughness=adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n#endif\ninfo.clearCoat=computeClearCoatLighting(preInfo,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatAARoughnessFactors.x,clearcoatOut.clearCoatIntensity,light{X}.vLightDiffuse.rgb);\n#ifdef CLEARCOAT_TINT\n\nabsorption=computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract,preInfo.L,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatColor,clearcoatOut.clearCoatThickness,clearcoatOut.clearCoatIntensity);\ninfo.diffuse*=absorption;\n#ifdef SPECULARTERM\ninfo.specular*=absorption;\n#endif\n#endif\n\ninfo.diffuse*=info.clearCoat.w;\n#ifdef SPECULARTERM\ninfo.specular*=info.clearCoat.w;\n#endif\n#ifdef SHEEN\ninfo.sheen*=info.clearCoat.w;\n#endif\n#endif\n#else\n#ifdef SPOTLIGHT{X}\ninfo=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\n#elif defined(HEMILIGHT{X})\ninfo=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightGround,glossiness);\n#elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\ninfo=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\n#endif\n#endif\n#ifdef PROJECTEDLIGHTTEXTURE{X}\ninfo.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightSampler{X},textureProjectionMatrix{X});\n#endif\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nfor (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++)\n{\n#ifdef SHADOWCSM_RIGHTHANDED{X}\ndiff{X}=viewFrustumZ{X}[i]+vPositionFromCamera{X}.z;\n#else\ndiff{X}=viewFrustumZ{X}[i]-vPositionFromCamera{X}.z;\n#endif\nif (diff{X}>=0.) {\nindex{X}=i;\nbreak;\n}\n}\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nif (index{X}>=0)\n#endif\n{\n#if defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nshadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#else\nshadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#endif\n#else\nshadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#ifdef SHADOWCSMDEBUG{X}\nshadowDebug{X}=vec3(shadow)*vCascadeColorsMultiplier{X}[index{X}];\n#endif\n#ifndef SHADOWCSMNOBLEND{X}\nfloat frustumLength=frustumLengths{X}[index{X}];\nfloat diffRatio=clamp(diff{X}/frustumLength,0.,1.)*cascadeBlendFactor{X};\nif (index{X}<(SHADOWCSMNUM_CASCADES{X}-1) && diffRatio<1.)\n{\nindex{X}+=1;\nfloat nextShadow=0.;\n#if defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nnextShadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nnextShadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nnextShadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nnextShadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#elif defined(SHADOWMEDIUMQUALITY{X})\nnextShadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#else\nnextShadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#endif\n#else\nnextShadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\nshadow=mix(nextShadow,shadow,diffRatio);\n#ifdef SHADOWCSMDEBUG{X}\nshadowDebug{X}=mix(vec3(nextShadow)*vCascadeColorsMultiplier{X}[index{X}],shadowDebug{X},diffRatio);\n#endif\n}\n#endif\n}\n#elif defined(SHADOWCLOSEESM{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithCloseESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\n#else\nshadow=computeShadowWithCloseESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWESM{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\n#else\nshadow=computeShadowWithESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPOISSON{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithPoissonSamplingCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.depthValues);\n#else\nshadow=computeShadowWithPoissonSampling(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithPCF1(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithPCF3(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nshadow=computeShadowWithPCF5(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithPCSS16(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithPCSS32(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nshadow=computeShadowWithPCSS64(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#else\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.depthValues);\n#else\nshadow=computeShadow(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#endif\n#ifdef SHADOWONLY\n#ifndef SHADOWINUSE\n#define SHADOWINUSE\n#endif\nglobalShadow+=shadow;\nshadowLightCount+=1.0;\n#endif\n#else\nshadow=1.;\n#endif\n#ifndef SHADOWONLY\n#ifdef CUSTOMUSERLIGHTING\ndiffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);\n#ifdef SPECULARTERM\nspecularBase+=computeCustomSpecularLighting(info,specularBase,shadow);\n#endif\n#elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})\ndiffuseBase+=lightmapColor.rgb*shadow;\n#ifdef SPECULARTERM\n#ifndef LIGHTMAPNOSPECULAR{X}\nspecularBase+=info.specular*shadow*lightmapColor.rgb;\n#endif\n#endif\n#ifdef CLEARCOAT\n#ifndef LIGHTMAPNOSPECULAR{X}\nclearCoatBase+=info.clearCoat.rgb*shadow*lightmapColor.rgb;\n#endif\n#endif\n#ifdef SHEEN\n#ifndef LIGHTMAPNOSPECULAR{X}\nsheenBase+=info.sheen.rgb*shadow;\n#endif\n#endif\n#else\n#ifdef SHADOWCSMDEBUG{X}\ndiffuseBase+=info.diffuse*shadowDebug{X};\n#else\ndiffuseBase+=info.diffuse*shadow;\n#endif\n#ifdef SPECULARTERM\nspecularBase+=info.specular*shadow;\n#endif\n#ifdef CLEARCOAT\nclearCoatBase+=info.clearCoat.rgb*shadow;\n#endif\n#ifdef SHEEN\nsheenBase+=info.sheen.rgb*shadow;\n#endif\n#endif\n#endif\n#endif`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var lightFragment = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'fogFragment';\nlet shader = `#ifdef FOG\nfloat fog=CalcFogFactor();\ncolor.rgb=fog*color.rgb+(1.0-fog)*vFogColor;\n#endif`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var fogFragment = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'fogVertexDeclaration';\nlet shader = `#ifdef FOG\nvarying vec3 vFogDistance;\n#endif`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var fogVertexDeclaration = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'shadowsVertex';\nlet shader = `#ifdef SHADOWS\n#if defined(SHADOWCSM{X})\nvPositionFromCamera{X}=view*worldPos;\nfor (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) {\nvPositionFromLight{X}[i]=lightMatrix{X}[i]*worldPos;\nvDepthMetric{X}[i]=((vPositionFromLight{X}[i].z+light{X}.depthValues.x)/(light{X}.depthValues.y));\n}\n#elif defined(SHADOW{X}) && !defined(SHADOWCUBE{X})\nvPositionFromLight{X}=lightMatrix{X}*worldPos;\nvDepthMetric{X}=((vPositionFromLight{X}.z+light{X}.depthValues.x)/(light{X}.depthValues.y));\n#endif\n#endif`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var shadowsVertex = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'lightsFragmentFunctions';\nlet shader = `\nstruct lightingInfo\n{\nvec3 diffuse;\n#ifdef SPECULARTERM\nvec3 specular;\n#endif\n#ifdef NDOTL\nfloat ndl;\n#endif\n};\nlightingInfo computeLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {\nlightingInfo result;\nvec3 lightVectorW;\nfloat attenuation=1.0;\nif (lightData.w == 0.)\n{\nvec3 direction=lightData.xyz-vPositionW;\nattenuation=max(0.,1.0-length(direction)/range);\nlightVectorW=normalize(direction);\n}\nelse\n{\nlightVectorW=normalize(-lightData.xyz);\n}\n\nfloat ndl=max(0.,dot(vNormal,lightVectorW));\n#ifdef NDOTL\nresult.ndl=ndl;\n#endif\nresult.diffuse=ndl*diffuseColor*attenuation;\n#ifdef SPECULARTERM\n\nvec3 angleW=normalize(viewDirectionW+lightVectorW);\nfloat specComp=max(0.,dot(vNormal,angleW));\nspecComp=pow(specComp,max(1.,glossiness));\nresult.specular=specComp*specularColor*attenuation;\n#endif\nreturn result;\n}\nlightingInfo computeSpotLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec4 lightDirection,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {\nlightingInfo result;\nvec3 direction=lightData.xyz-vPositionW;\nvec3 lightVectorW=normalize(direction);\nfloat attenuation=max(0.,1.0-length(direction)/range);\n\nfloat cosAngle=max(0.,dot(lightDirection.xyz,-lightVectorW));\nif (cosAngle>=lightDirection.w)\n{\ncosAngle=max(0.,pow(cosAngle,lightData.w));\nattenuation*=cosAngle;\n\nfloat ndl=max(0.,dot(vNormal,lightVectorW));\n#ifdef NDOTL\nresult.ndl=ndl;\n#endif\nresult.diffuse=ndl*diffuseColor*attenuation;\n#ifdef SPECULARTERM\n\nvec3 angleW=normalize(viewDirectionW+lightVectorW);\nfloat specComp=max(0.,dot(vNormal,angleW));\nspecComp=pow(specComp,max(1.,glossiness));\nresult.specular=specComp*specularColor*attenuation;\n#endif\nreturn result;\n}\nresult.diffuse=vec3(0.);\n#ifdef SPECULARTERM\nresult.specular=vec3(0.);\n#endif\n#ifdef NDOTL\nresult.ndl=0.;\n#endif\nreturn result;\n}\nlightingInfo computeHemisphericLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,vec3 groundColor,float glossiness) {\nlightingInfo result;\n\nfloat ndl=dot(vNormal,lightData.xyz)*0.5+0.5;\n#ifdef NDOTL\nresult.ndl=ndl;\n#endif\nresult.diffuse=mix(groundColor,diffuseColor,ndl);\n#ifdef SPECULARTERM\n\nvec3 angleW=normalize(viewDirectionW+lightData.xyz);\nfloat specComp=max(0.,dot(vNormal,angleW));\nspecComp=pow(specComp,max(1.,glossiness));\nresult.specular=specComp*specularColor;\n#endif\nreturn result;\n}\n#define inline\nvec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix){\nvec4 strq=textureProjectionMatrix*vec4(vPositionW,1.0);\nstrq/=strq.w;\nvec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;\nreturn textureColor;\n}`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var lightsFragmentFunctions = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'logDepthFragment';\nlet shader = `#ifdef LOGARITHMICDEPTH\ngl_FragDepthEXT=log2(vFragmentDepth)*logarithmicDepthConstant*0.5;\n#endif`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var logDepthFragment = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'bumpVertex';\nlet shader = `#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL)\nvec3 tbnNormal=normalize(normalUpdated);\nvec3 tbnTangent=normalize(tangentUpdated.xyz);\nvec3 tbnBitangent=cross(tbnNormal,tbnTangent)*tangentUpdated.w;\nvTBN=mat3(finalWorld)*mat3(tbnTangent,tbnBitangent,tbnNormal);\n#endif\n#endif`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var bumpVertex = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'fogVertex';\nlet shader = `#ifdef FOG\nvFogDistance=(view*worldPos).xyz;\n#endif`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var fogVertex = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'logDepthVertex';\nlet shader = `#ifdef LOGARITHMICDEPTH\nvFragmentDepth=1.0+gl_Position.w;\ngl_Position.z=log2(max(0.000001,vFragmentDepth))*logarithmicDepthConstant;\n#endif`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var logDepthVertex = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'prePassDeclaration';\nlet shader = `#ifdef PREPASS\n#extension GL_EXT_draw_buffers : require\nlayout(location=0) out vec4 glFragData[{X}];\nvec4 gl_FragColor;\n#endif\n`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var prePassDeclaration = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'fresnelFunction';\nlet shader = `#ifdef FRESNEL\nfloat computeFresnelTerm(vec3 viewDirection,vec3 worldNormal,float bias,float power)\n{\nfloat fresnelTerm=pow(bias+abs(dot(viewDirection,worldNormal)),power);\nreturn clamp(fresnelTerm,0.,1.);\n}\n#endif`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var fresnelFunction = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'depthPrePass';\nlet shader = `#ifdef DEPTHPREPASS\ngl_FragColor=vec4(0.,0.,0.,1.0);\nreturn;\n#endif`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var depthPrePass = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'bumpVertexDeclaration';\nlet shader = `#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL)\nvarying mat3 vTBN;\n#endif\n#endif\n`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var bumpVertexDeclaration = { name, shader };\n","import { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Material } from \"./material\";\r\nimport { _TypeStore } from \"../Misc/typeStore\";\r\nimport { serialize, expandToProperty, serializeAsTexture, SerializationHelper } from '../Misc/decorators';\r\nimport { MaterialFlags } from './materialFlags';\r\nimport { MaterialHelper } from './materialHelper';\r\nimport { BaseTexture } from './Textures/baseTexture';\r\nimport { UniformBuffer } from './uniformBuffer';\r\nimport { IAnimatable } from '../Animations/animatable.interface';\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport interface IMaterialDetailMapDefines {\r\n    DETAIL: boolean;\r\n    DETAILDIRECTUV : number;\r\n    DETAIL_NORMALBLENDMETHOD: number;\r\n\r\n    /** @hidden */\r\n    _areTexturesDirty: boolean;\r\n}\r\n\r\n/**\r\n * Define the code related to the detail map parameters of a material\r\n *\r\n * Inspired from:\r\n *   Unity: https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@9.0/manual/Mask-Map-and-Detail-Map.html and https://docs.unity3d.com/Manual/StandardShaderMaterialParameterDetail.html\r\n *   Unreal: https://docs.unrealengine.com/en-US/Engine/Rendering/Materials/HowTo/DetailTexturing/index.html\r\n *   Cryengine: https://docs.cryengine.com/display/SDKDOC2/Detail+Maps\r\n */\r\nexport class DetailMapConfiguration {\r\n\r\n    private _texture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * The detail texture of the material.\r\n     */\r\n    @serializeAsTexture(\"detailTexture\")\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public texture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Defines how strongly the detail diffuse/albedo channel is blended with the regular diffuse/albedo texture\r\n     * Bigger values mean stronger blending\r\n     */\r\n    @serialize()\r\n    public diffuseBlendLevel = 1;\r\n\r\n    /**\r\n     * Defines how strongly the detail roughness channel is blended with the regular roughness value\r\n     * Bigger values mean stronger blending. Only used with PBR materials\r\n     */\r\n    @serialize()\r\n    public roughnessBlendLevel = 1;\r\n\r\n    /**\r\n     * Defines how strong the bump effect from the detail map is\r\n     * Bigger values mean stronger effect\r\n     */\r\n    @serialize()\r\n    public bumpLevel = 1;\r\n\r\n    private _normalBlendMethod = Material.MATERIAL_NORMALBLENDMETHOD_WHITEOUT;\r\n    /**\r\n     * The method used to blend the bump and detail normals together\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public normalBlendMethod: number;\r\n\r\n    private _isEnabled = false;\r\n    /**\r\n     * Enable or disable the detail map on this material\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isEnabled = false;\r\n\r\n    /** @hidden */\r\n    private _internalMarkAllSubMeshesAsTexturesDirty: () => void;\r\n\r\n    /** @hidden */\r\n    public _markAllSubMeshesAsTexturesDirty(): void {\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /**\r\n     * Instantiate a new detail map\r\n     * @param markAllSubMeshesAsTexturesDirty Callback to flag the material to dirty\r\n     */\r\n    constructor(markAllSubMeshesAsTexturesDirty: () => void) {\r\n        this._internalMarkAllSubMeshesAsTexturesDirty = markAllSubMeshesAsTexturesDirty;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the submesh is ready to be used or not.\r\n     * @param defines the list of \"defines\" to update.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @returns - boolean indicating that the submesh is ready or not.\r\n     */\r\n    public isReadyForSubMesh(defines: IMaterialDetailMapDefines, scene: Scene): boolean {\r\n        const engine = scene.getEngine();\r\n\r\n        if (defines._areTexturesDirty && scene.texturesEnabled) {\r\n            if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled) {\r\n                // Detail texture cannot be not blocking.\r\n                if (!this._texture.isReady()) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Update the defines for detail map usage\r\n     * @param defines the list of \"defines\" to update.\r\n     * @param scene defines the scene the material belongs to.\r\n     */\r\n    public prepareDefines(defines: IMaterialDetailMapDefines, scene: Scene): void {\r\n        if (this._isEnabled) {\r\n            defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;\r\n\r\n            const engine = scene.getEngine();\r\n\r\n            if (defines._areTexturesDirty) {\r\n                if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled && this._isEnabled) {\r\n                    MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, \"DETAIL\");\r\n                    defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;\r\n                } else {\r\n                    defines.DETAIL = false;\r\n                }\r\n            }\r\n        } else {\r\n            defines.DETAIL = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the material data.\r\n     * @param uniformBuffer defines the Uniform buffer to fill in.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @param isFrozen defines whether the material is frozen or not.\r\n     */\r\n    public bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, isFrozen: boolean): void {\r\n        if (!this._isEnabled) {\r\n            return;\r\n        }\r\n\r\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\r\n            if (this._texture && MaterialFlags.DetailTextureEnabled) {\r\n                uniformBuffer.updateFloat4(\"vDetailInfos\", this._texture.coordinatesIndex, this.diffuseBlendLevel, this.bumpLevel, this.roughnessBlendLevel);\r\n                MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, \"detail\");\r\n            }\r\n        }\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (this._texture && MaterialFlags.DetailTextureEnabled) {\r\n                uniformBuffer.setTexture(\"detailSampler\", this._texture);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks to see if a texture is used in the material.\r\n     * @param texture - Base texture to use.\r\n     * @returns - Boolean specifying if a texture is used in the material.\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (this._texture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of the actively used textures.\r\n     * @param activeTextures Array of BaseTextures\r\n     */\r\n    public getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this._texture) {\r\n            activeTextures.push(this._texture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the animatable textures.\r\n     * @param animatables Array of animatable textures.\r\n     */\r\n    public getAnimatables(animatables: IAnimatable[]): void {\r\n        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\r\n            animatables.push(this._texture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the resources of the material.\r\n     * @param forceDisposeTextures - Forces the disposal of all textures.\r\n     */\r\n    public dispose(forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            this._texture?.dispose();\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Get the current class name useful for serialization or dynamic coding.\r\n    * @returns \"DetailMap\"\r\n    */\r\n    public getClassName(): string {\r\n        return \"DetailMap\";\r\n    }\r\n\r\n    /**\r\n     * Add the required uniforms to the current list.\r\n     * @param uniforms defines the current uniform list.\r\n     */\r\n    public static AddUniforms(uniforms: string[]): void {\r\n        uniforms.push(\"vDetailInfos\");\r\n    }\r\n\r\n    /**\r\n     * Add the required samplers to the current list.\r\n     * @param samplers defines the current sampler list.\r\n     */\r\n    public static AddSamplers(samplers: string[]): void {\r\n        samplers.push(\"detailSampler\");\r\n    }\r\n\r\n    /**\r\n     * Add the required uniforms to the current buffer.\r\n     * @param uniformBuffer defines the current uniform buffer.\r\n     */\r\n    public static PrepareUniformBuffer(uniformBuffer: UniformBuffer): void {\r\n        uniformBuffer.addUniform(\"vDetailInfos\", 4);\r\n        uniformBuffer.addUniform(\"detailMatrix\", 16);\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the current instance into another one.\r\n     * @param detailMap define the instance where to copy the info\r\n     */\r\n    public copyTo(detailMap: DetailMapConfiguration): void {\r\n        SerializationHelper.Clone(() => detailMap, this);\r\n    }\r\n\r\n    /**\r\n     * Serializes this detail map instance\r\n     * @returns - An object with the serialized instance.\r\n     */\r\n    public serialize(): any {\r\n        return SerializationHelper.Serialize(this);\r\n    }\r\n\r\n    /**\r\n     * Parses a detail map setting from a serialized object.\r\n     * @param source - Serialized object.\r\n     * @param scene Defines the scene we are parsing for\r\n     * @param rootUrl Defines the rootUrl to load from\r\n     */\r\n    public parse(source: any, scene: Scene, rootUrl: string): void {\r\n        SerializationHelper.Parse(() => this, source, scene, rootUrl);\r\n    }\r\n}\r\n","import { Logger } from \"../Misc/logger\";\r\nimport { Nullable } from \"../types\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { Light } from \"../Lights/light\";\r\n\r\n\r\nimport { UniformBuffer } from \"./uniformBuffer\";\r\nimport { Effect, IEffectCreationOptions } from \"./effect\";\r\nimport { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { WebVRFreeCamera } from '../Cameras/VR/webVRCamera';\r\nimport { MaterialDefines } from \"./materialDefines\";\r\nimport { Color3 } from '../Maths/math.color';\r\nimport { EffectFallbacks } from './effectFallbacks';\r\nimport { ThinMaterialHelper } from './thinMaterialHelper';\r\n\r\n/**\r\n * \"Static Class\" containing the most commonly used helper while dealing with material for rendering purpose.\r\n *\r\n * It contains the basic tools to help defining defines, binding uniform for the common part of the materials.\r\n *\r\n * This works by convention in BabylonJS but is meant to be use only with shader following the in place naming rules and conventions.\r\n */\r\nexport class MaterialHelper {\r\n\r\n    /**\r\n     * Bind the current view position to an effect.\r\n     * @param effect The effect to be bound\r\n     * @param scene The scene the eyes position is used from\r\n     * @param variableName name of the shader variable that will hold the eye position\r\n     */\r\n    public static BindEyePosition(effect: Effect, scene: Scene, variableName = \"vEyePosition\"): void {\r\n        if (scene._forcedViewPosition) {\r\n            effect.setVector3(variableName, scene._forcedViewPosition);\r\n            return;\r\n        }\r\n        var globalPosition = scene.activeCamera!.globalPosition;\r\n        if (!globalPosition) {\r\n            // Use WebVRFreecamera's device position as global position is not it's actual position in babylon space\r\n            globalPosition = (scene.activeCamera! as WebVRFreeCamera).devicePosition;\r\n        }\r\n        effect.setVector3(variableName, scene._mirroredCameraPosition ? scene._mirroredCameraPosition : globalPosition);\r\n    }\r\n\r\n    /**\r\n     * Helps preparing the defines values about the UVs in used in the effect.\r\n     * UVs are shared as much as we can accross channels in the shaders.\r\n     * @param texture The texture we are preparing the UVs for\r\n     * @param defines The defines to update\r\n     * @param key The channel key \"diffuse\", \"specular\"... used in the shader\r\n     */\r\n    public static PrepareDefinesForMergedUV(texture: BaseTexture, defines: any, key: string): void {\r\n        defines._needUVs = true;\r\n        defines[key] = true;\r\n        if (texture.getTextureMatrix().isIdentityAs3x2()) {\r\n            defines[key + \"DIRECTUV\"] = texture.coordinatesIndex + 1;\r\n            if (texture.coordinatesIndex === 0) {\r\n                defines[\"MAINUV1\"] = true;\r\n            } else {\r\n                defines[\"MAINUV2\"] = true;\r\n            }\r\n        } else {\r\n            defines[key + \"DIRECTUV\"] = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds a texture matrix value to its corrsponding uniform\r\n     * @param texture The texture to bind the matrix for\r\n     * @param uniformBuffer The uniform buffer receivin the data\r\n     * @param key The channel key \"diffuse\", \"specular\"... used in the shader\r\n     */\r\n    public static BindTextureMatrix(texture: BaseTexture, uniformBuffer: UniformBuffer, key: string): void {\r\n        var matrix = texture.getTextureMatrix();\r\n\r\n        uniformBuffer.updateMatrix(key + \"Matrix\", matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets the current status of the fog (should it be enabled?)\r\n     * @param mesh defines the mesh to evaluate for fog support\r\n     * @param scene defines the hosting scene\r\n     * @returns true if fog must be enabled\r\n     */\r\n    public static GetFogState(mesh: AbstractMesh, scene: Scene) {\r\n        return (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE);\r\n    }\r\n\r\n    /**\r\n     * Helper used to prepare the list of defines associated with misc. values for shader compilation\r\n     * @param mesh defines the current mesh\r\n     * @param scene defines the current scene\r\n     * @param useLogarithmicDepth defines if logarithmic depth has to be turned on\r\n     * @param pointsCloud defines if point cloud rendering has to be turned on\r\n     * @param fogEnabled defines if fog has to be turned on\r\n     * @param alphaTest defines if alpha testing has to be turned on\r\n     * @param defines defines the current list of defines\r\n     */\r\n    public static PrepareDefinesForMisc(mesh: AbstractMesh, scene: Scene, useLogarithmicDepth: boolean, pointsCloud: boolean, fogEnabled: boolean, alphaTest: boolean, defines: any): void {\r\n        if (defines._areMiscDirty) {\r\n            defines[\"LOGARITHMICDEPTH\"] = useLogarithmicDepth;\r\n            defines[\"POINTSIZE\"] = pointsCloud;\r\n            defines[\"FOG\"] = fogEnabled && this.GetFogState(mesh, scene);\r\n            defines[\"NONUNIFORMSCALING\"] = mesh.nonUniformScaling;\r\n            defines[\"ALPHATEST\"] = alphaTest;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper used to prepare the list of defines associated with frame values for shader compilation\r\n     * @param scene defines the current scene\r\n     * @param engine defines the current engine\r\n     * @param defines specifies the list of active defines\r\n     * @param useInstances defines if instances have to be turned on\r\n     * @param useClipPlane defines if clip plane have to be turned on\r\n     * @param useInstances defines if instances have to be turned on\r\n     * @param useThinInstances defines if thin instances have to be turned on\r\n     */\r\n    public static PrepareDefinesForFrameBoundValues(scene: Scene, engine: Engine, defines: any, useInstances: boolean, useClipPlane: Nullable<boolean> = null, useThinInstances: boolean = false): void {\r\n        var changed = false;\r\n        let useClipPlane1 = false;\r\n        let useClipPlane2 = false;\r\n        let useClipPlane3 = false;\r\n        let useClipPlane4 = false;\r\n        let useClipPlane5 = false;\r\n        let useClipPlane6 = false;\r\n\r\n        useClipPlane1 = useClipPlane == null ? (scene.clipPlane !== undefined && scene.clipPlane !== null) : useClipPlane;\r\n        useClipPlane2 = useClipPlane == null ? (scene.clipPlane2 !== undefined && scene.clipPlane2 !== null) : useClipPlane;\r\n        useClipPlane3 = useClipPlane == null ? (scene.clipPlane3 !== undefined && scene.clipPlane3 !== null) : useClipPlane;\r\n        useClipPlane4 = useClipPlane == null ? (scene.clipPlane4 !== undefined && scene.clipPlane4 !== null) : useClipPlane;\r\n        useClipPlane5 = useClipPlane == null ? (scene.clipPlane5 !== undefined && scene.clipPlane5 !== null) : useClipPlane;\r\n        useClipPlane6 = useClipPlane == null ? (scene.clipPlane6 !== undefined && scene.clipPlane6 !== null) : useClipPlane;\r\n\r\n        if (defines[\"CLIPPLANE\"] !== useClipPlane1) {\r\n            defines[\"CLIPPLANE\"] = useClipPlane1;\r\n            changed = true;\r\n        }\r\n\r\n        if (defines[\"CLIPPLANE2\"] !== useClipPlane2) {\r\n            defines[\"CLIPPLANE2\"] = useClipPlane2;\r\n            changed = true;\r\n        }\r\n\r\n        if (defines[\"CLIPPLANE3\"] !== useClipPlane3) {\r\n            defines[\"CLIPPLANE3\"] = useClipPlane3;\r\n            changed = true;\r\n        }\r\n\r\n        if (defines[\"CLIPPLANE4\"] !== useClipPlane4) {\r\n            defines[\"CLIPPLANE4\"] = useClipPlane4;\r\n            changed = true;\r\n        }\r\n\r\n        if (defines[\"CLIPPLANE5\"] !== useClipPlane5) {\r\n            defines[\"CLIPPLANE5\"] = useClipPlane5;\r\n            changed = true;\r\n        }\r\n\r\n        if (defines[\"CLIPPLANE6\"] !== useClipPlane6) {\r\n            defines[\"CLIPPLANE6\"] = useClipPlane6;\r\n            changed = true;\r\n        }\r\n\r\n        if (defines[\"DEPTHPREPASS\"] !== !engine.getColorWrite()) {\r\n            defines[\"DEPTHPREPASS\"] = !defines[\"DEPTHPREPASS\"];\r\n            changed = true;\r\n        }\r\n\r\n        if (defines[\"INSTANCES\"] !== useInstances) {\r\n            defines[\"INSTANCES\"] = useInstances;\r\n            changed = true;\r\n        }\r\n\r\n        if (defines[\"THIN_INSTANCES\"] !== useThinInstances) {\r\n            defines[\"THIN_INSTANCES\"] = useThinInstances;\r\n            changed = true;\r\n        }\r\n\r\n        if (changed) {\r\n            defines.markAsUnprocessed();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines for bones\r\n     * @param mesh The mesh containing the geometry data we will draw\r\n     * @param defines The defines to update\r\n     */\r\n    public static PrepareDefinesForBones(mesh: AbstractMesh, defines: any) {\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n            defines[\"NUM_BONE_INFLUENCERS\"] = mesh.numBoneInfluencers;\r\n\r\n            const materialSupportsBoneTexture = defines[\"BONETEXTURE\"] !== undefined;\r\n\r\n            if (mesh.skeleton.isUsingTextureForMatrices && materialSupportsBoneTexture) {\r\n                defines[\"BONETEXTURE\"] = true;\r\n            } else {\r\n                defines[\"BonesPerMesh\"] = (mesh.skeleton.bones.length + 1);\r\n                defines[\"BONETEXTURE\"] = materialSupportsBoneTexture ? false : undefined;\r\n            }\r\n        } else {\r\n            defines[\"NUM_BONE_INFLUENCERS\"] = 0;\r\n            defines[\"BonesPerMesh\"] = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines for morph targets\r\n     * @param mesh The mesh containing the geometry data we will draw\r\n     * @param defines The defines to update\r\n     */\r\n    public static PrepareDefinesForMorphTargets(mesh: AbstractMesh, defines: any) {\r\n        var manager = (<Mesh>mesh).morphTargetManager;\r\n        if (manager) {\r\n            defines[\"MORPHTARGETS_UV\"] = manager.supportsUVs && defines[\"UV1\"];\r\n            defines[\"MORPHTARGETS_TANGENT\"] = manager.supportsTangents && defines[\"TANGENT\"];\r\n            defines[\"MORPHTARGETS_NORMAL\"] = manager.supportsNormals && defines[\"NORMAL\"];\r\n            defines[\"MORPHTARGETS\"] = (manager.numInfluencers > 0);\r\n            defines[\"NUM_MORPH_INFLUENCERS\"] = manager.numInfluencers;\r\n        } else {\r\n            defines[\"MORPHTARGETS_UV\"] = false;\r\n            defines[\"MORPHTARGETS_TANGENT\"] = false;\r\n            defines[\"MORPHTARGETS_NORMAL\"] = false;\r\n            defines[\"MORPHTARGETS\"] = false;\r\n            defines[\"NUM_MORPH_INFLUENCERS\"] = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines used in the shader depending on the attributes data available in the mesh\r\n     * @param mesh The mesh containing the geometry data we will draw\r\n     * @param defines The defines to update\r\n     * @param useVertexColor Precise whether vertex colors should be used or not (override mesh info)\r\n     * @param useBones Precise whether bones should be used or not (override mesh info)\r\n     * @param useMorphTargets Precise whether morph targets should be used or not (override mesh info)\r\n     * @param useVertexAlpha Precise whether vertex alpha should be used or not (override mesh info)\r\n     * @returns false if defines are considered not dirty and have not been checked\r\n     */\r\n    public static PrepareDefinesForAttributes(mesh: AbstractMesh, defines: any, useVertexColor: boolean, useBones: boolean, useMorphTargets = false, useVertexAlpha = true): boolean {\r\n        if (!defines._areAttributesDirty && defines._needNormals === defines._normals && defines._needUVs === defines._uvs) {\r\n            return false;\r\n        }\r\n\r\n        defines._normals = defines._needNormals;\r\n        defines._uvs = defines._needUVs;\r\n\r\n        defines[\"NORMAL\"] = (defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.NormalKind));\r\n\r\n        if (defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n            defines[\"TANGENT\"] = true;\r\n        }\r\n\r\n        if (defines._needUVs) {\r\n            defines[\"UV1\"] = mesh.isVerticesDataPresent(VertexBuffer.UVKind);\r\n            defines[\"UV2\"] = mesh.isVerticesDataPresent(VertexBuffer.UV2Kind);\r\n        } else {\r\n            defines[\"UV1\"] = false;\r\n            defines[\"UV2\"] = false;\r\n        }\r\n\r\n        if (useVertexColor) {\r\n            var hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind);\r\n            defines[\"VERTEXCOLOR\"] = hasVertexColors;\r\n            defines[\"VERTEXALPHA\"] = mesh.hasVertexAlpha && hasVertexColors && useVertexAlpha;\r\n        }\r\n\r\n        if (useBones) {\r\n            this.PrepareDefinesForBones(mesh, defines);\r\n        }\r\n\r\n        if (useMorphTargets) {\r\n            this.PrepareDefinesForMorphTargets(mesh, defines);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines related to multiview\r\n     * @param scene The scene we are intending to draw\r\n     * @param defines The defines to update\r\n     */\r\n    public static PrepareDefinesForMultiview(scene: Scene, defines: any) {\r\n        if (scene.activeCamera) {\r\n            var previousMultiview = defines.MULTIVIEW;\r\n            defines.MULTIVIEW = (scene.activeCamera.outputRenderTarget !== null && scene.activeCamera.outputRenderTarget.getViewCount() > 1);\r\n            if (defines.MULTIVIEW != previousMultiview) {\r\n                defines.markAsUnprocessed();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines related to the prepass\r\n     * @param scene The scene we are intending to draw\r\n     * @param defines The defines to update\r\n     * @param canRenderToMRT Indicates if this material renders to several textures in the prepass\r\n     */\r\n    public static PrepareDefinesForPrePass(scene: Scene, defines: any, canRenderToMRT: boolean) {\r\n        var previousPrePass = defines.PREPASS;\r\n\r\n        if (scene.prePassRenderer && scene.prePassRenderer.enabled && canRenderToMRT) {\r\n            defines.PREPASS = true;\r\n            defines.SCENE_MRT_COUNT = scene.prePassRenderer.mrtCount;\r\n\r\n            const irradianceIndex = scene.prePassRenderer.getIndex(0);\r\n            if (irradianceIndex !== -1) {\r\n                defines.PREPASS_IRRADIANCE = true;\r\n                defines.PREPASS_IRRADIANCE_INDEX = irradianceIndex;\r\n            } else {\r\n                defines.PREPASS_IRRADIANCE = false;\r\n            }\r\n\r\n            const albedoIndex = scene.prePassRenderer.getIndex(6);\r\n            if (albedoIndex !== -1) {\r\n                defines.PREPASS_ALBEDO = true;\r\n                defines.PREPASS_ALBEDO_INDEX = albedoIndex;\r\n            } else {\r\n                defines.PREPASS_ALBEDO = false;\r\n            }\r\n\r\n            const depthNormalIndex = scene.prePassRenderer.getIndex(5);\r\n            if (depthNormalIndex !== -1) {\r\n                defines.PREPASS_DEPTHNORMAL = true;\r\n                defines.PREPASS_DEPTHNORMAL_INDEX = depthNormalIndex;\r\n            } else {\r\n                defines.PREPASS_DEPTHNORMAL = false;\r\n            }\r\n        } else {\r\n            defines.PREPASS = false;\r\n        }\r\n\r\n        if (defines.PREPASS != previousPrePass) {\r\n            defines.markAsUnprocessed();\r\n            defines.markAsImageProcessingDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines related to the light information passed in parameter\r\n     * @param scene The scene we are intending to draw\r\n     * @param mesh The mesh the effect is compiling for\r\n     * @param light The light the effect is compiling for\r\n     * @param lightIndex The index of the light\r\n     * @param defines The defines to update\r\n     * @param specularSupported Specifies whether specular is supported or not (override lights data)\r\n     * @param state Defines the current state regarding what is needed (normals, etc...)\r\n     */\r\n    public static PrepareDefinesForLight(scene: Scene, mesh: AbstractMesh, light: Light, lightIndex: number, defines: any, specularSupported: boolean, state: {\r\n        needNormals: boolean,\r\n        needRebuild: boolean,\r\n        shadowEnabled: boolean,\r\n        specularEnabled: boolean,\r\n        lightmapMode: boolean\r\n    }) {\r\n        state.needNormals = true;\r\n\r\n        if (defines[\"LIGHT\" + lightIndex] === undefined) {\r\n            state.needRebuild = true;\r\n        }\r\n\r\n        defines[\"LIGHT\" + lightIndex] = true;\r\n\r\n        defines[\"SPOTLIGHT\" + lightIndex] = false;\r\n        defines[\"HEMILIGHT\" + lightIndex] = false;\r\n        defines[\"POINTLIGHT\" + lightIndex] = false;\r\n        defines[\"DIRLIGHT\" + lightIndex] = false;\r\n\r\n        light.prepareLightSpecificDefines(defines, lightIndex);\r\n\r\n        // FallOff.\r\n        defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = false;\r\n        defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = false;\r\n        defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = false;\r\n\r\n        switch (light.falloffType) {\r\n            case Light.FALLOFF_GLTF:\r\n                defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = true;\r\n                break;\r\n            case Light.FALLOFF_PHYSICAL:\r\n                defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = true;\r\n                break;\r\n            case Light.FALLOFF_STANDARD:\r\n                defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = true;\r\n                break;\r\n        }\r\n\r\n        // Specular\r\n        if (specularSupported && !light.specular.equalsFloats(0, 0, 0)) {\r\n            state.specularEnabled = true;\r\n        }\r\n\r\n        // Shadows\r\n        defines[\"SHADOW\" + lightIndex] = false;\r\n        defines[\"SHADOWCSM\" + lightIndex] = false;\r\n        defines[\"SHADOWCSMDEBUG\" + lightIndex] = false;\r\n        defines[\"SHADOWCSMNUM_CASCADES\" + lightIndex] = false;\r\n        defines[\"SHADOWCSMUSESHADOWMAXZ\" + lightIndex] = false;\r\n        defines[\"SHADOWCSMNOBLEND\" + lightIndex] = false;\r\n        defines[\"SHADOWCSM_RIGHTHANDED\" + lightIndex] = false;\r\n        defines[\"SHADOWPCF\" + lightIndex] = false;\r\n        defines[\"SHADOWPCSS\" + lightIndex] = false;\r\n        defines[\"SHADOWPOISSON\" + lightIndex] = false;\r\n        defines[\"SHADOWESM\" + lightIndex] = false;\r\n        defines[\"SHADOWCUBE\" + lightIndex] = false;\r\n        defines[\"SHADOWLOWQUALITY\" + lightIndex] = false;\r\n        defines[\"SHADOWMEDIUMQUALITY\" + lightIndex] = false;\r\n\r\n        if (mesh && mesh.receiveShadows && scene.shadowsEnabled && light.shadowEnabled) {\r\n            var shadowGenerator = light.getShadowGenerator();\r\n            if (shadowGenerator) {\r\n                const shadowMap = shadowGenerator.getShadowMap();\r\n                if (shadowMap) {\r\n                    if (shadowMap.renderList && shadowMap.renderList.length > 0) {\r\n                        state.shadowEnabled = true;\r\n                        shadowGenerator.prepareDefines(defines, lightIndex);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (light.lightmapMode != Light.LIGHTMAP_DEFAULT) {\r\n            state.lightmapMode = true;\r\n            defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = true;\r\n            defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = (light.lightmapMode == Light.LIGHTMAP_SHADOWSONLY);\r\n        } else {\r\n            defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = false;\r\n            defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines related to the light information passed in parameter\r\n     * @param scene The scene we are intending to draw\r\n     * @param mesh The mesh the effect is compiling for\r\n     * @param defines The defines to update\r\n     * @param specularSupported Specifies whether specular is supported or not (override lights data)\r\n     * @param maxSimultaneousLights Specfies how manuy lights can be added to the effect at max\r\n     * @param disableLighting Specifies whether the lighting is disabled (override scene and light)\r\n     * @returns true if normals will be required for the rest of the effect\r\n     */\r\n    public static PrepareDefinesForLights(scene: Scene, mesh: AbstractMesh, defines: any, specularSupported: boolean, maxSimultaneousLights = 4, disableLighting = false): boolean {\r\n        if (!defines._areLightsDirty) {\r\n            return defines._needNormals;\r\n        }\r\n\r\n        var lightIndex = 0;\r\n        let state = {\r\n            needNormals: false,\r\n            needRebuild: false,\r\n            lightmapMode: false,\r\n            shadowEnabled: false,\r\n            specularEnabled: false\r\n        };\r\n\r\n        if (scene.lightsEnabled && !disableLighting) {\r\n            for (var light of mesh.lightSources) {\r\n                this.PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state);\r\n\r\n                lightIndex++;\r\n                if (lightIndex === maxSimultaneousLights) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        defines[\"SPECULARTERM\"] = state.specularEnabled;\r\n        defines[\"SHADOWS\"] = state.shadowEnabled;\r\n\r\n        // Resetting all other lights if any\r\n        for (var index = lightIndex; index < maxSimultaneousLights; index++) {\r\n            if (defines[\"LIGHT\" + index] !== undefined) {\r\n                defines[\"LIGHT\" + index] = false;\r\n                defines[\"HEMILIGHT\" + index] = false;\r\n                defines[\"POINTLIGHT\" + index] = false;\r\n                defines[\"DIRLIGHT\" + index] = false;\r\n                defines[\"SPOTLIGHT\" + index] = false;\r\n                defines[\"SHADOW\" + index] = false;\r\n                defines[\"SHADOWCSM\" + index] = false;\r\n                defines[\"SHADOWCSMDEBUG\" + index] = false;\r\n                defines[\"SHADOWCSMNUM_CASCADES\" + index] = false;\r\n                defines[\"SHADOWCSMUSESHADOWMAXZ\" + index] = false;\r\n                defines[\"SHADOWCSMNOBLEND\" + index] = false;\r\n                defines[\"SHADOWCSM_RIGHTHANDED\" + index] = false;\r\n                defines[\"SHADOWPCF\" + index] = false;\r\n                defines[\"SHADOWPCSS\" + index] = false;\r\n                defines[\"SHADOWPOISSON\" + index] = false;\r\n                defines[\"SHADOWESM\" + index] = false;\r\n                defines[\"SHADOWCUBE\" + index] = false;\r\n                defines[\"SHADOWLOWQUALITY\" + index] = false;\r\n                defines[\"SHADOWMEDIUMQUALITY\" + index] = false;\r\n            }\r\n        }\r\n\r\n        let caps = scene.getEngine().getCaps();\r\n\r\n        if (defines[\"SHADOWFLOAT\"] === undefined) {\r\n            state.needRebuild = true;\r\n        }\r\n\r\n        defines[\"SHADOWFLOAT\"] = state.shadowEnabled &&\r\n            ((caps.textureFloatRender && caps.textureFloatLinearFiltering) ||\r\n                (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering));\r\n        defines[\"LIGHTMAPEXCLUDED\"] = state.lightmapMode;\r\n\r\n        if (state.needRebuild) {\r\n            defines.rebuild();\r\n        }\r\n\r\n        return state.needNormals;\r\n    }\r\n\r\n    /**\r\n     * Prepares the uniforms and samplers list to be used in the effect (for a specific light)\r\n     * @param lightIndex defines the light index\r\n     * @param uniformsList The uniform list\r\n     * @param samplersList The sampler list\r\n     * @param projectedLightTexture defines if projected texture must be used\r\n     * @param uniformBuffersList defines an optional list of uniform buffers\r\n     */\r\n    public static PrepareUniformsAndSamplersForLight(lightIndex: number, uniformsList: string[], samplersList: string[], projectedLightTexture?: any, uniformBuffersList: Nullable<string[]> = null) {\r\n        uniformsList.push(\r\n            \"vLightData\" + lightIndex,\r\n            \"vLightDiffuse\" + lightIndex,\r\n            \"vLightSpecular\" + lightIndex,\r\n            \"vLightDirection\" + lightIndex,\r\n            \"vLightFalloff\" + lightIndex,\r\n            \"vLightGround\" + lightIndex,\r\n            \"lightMatrix\" + lightIndex,\r\n            \"shadowsInfo\" + lightIndex,\r\n            \"depthValues\" + lightIndex,\r\n        );\r\n\r\n        if (uniformBuffersList) {\r\n            uniformBuffersList.push(\"Light\" + lightIndex);\r\n        }\r\n\r\n        samplersList.push(\"shadowSampler\" + lightIndex);\r\n        samplersList.push(\"depthSampler\" + lightIndex);\r\n\r\n        uniformsList.push(\r\n            \"viewFrustumZ\" + lightIndex,\r\n            \"cascadeBlendFactor\" + lightIndex,\r\n            \"lightSizeUVCorrection\" + lightIndex,\r\n            \"depthCorrection\" + lightIndex,\r\n            \"penumbraDarkness\" + lightIndex,\r\n            \"frustumLengths\" + lightIndex,\r\n        );\r\n\r\n        if (projectedLightTexture) {\r\n            samplersList.push(\"projectionLightSampler\" + lightIndex);\r\n            uniformsList.push(\r\n                \"textureProjectionMatrix\" + lightIndex,\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the uniforms and samplers list to be used in the effect\r\n     * @param uniformsListOrOptions The uniform names to prepare or an EffectCreationOptions containing the liist and extra information\r\n     * @param samplersList The sampler list\r\n     * @param defines The defines helping in the list generation\r\n     * @param maxSimultaneousLights The maximum number of simultanous light allowed in the effect\r\n     */\r\n    public static PrepareUniformsAndSamplersList(uniformsListOrOptions: string[] | IEffectCreationOptions, samplersList?: string[], defines?: any, maxSimultaneousLights = 4): void {\r\n        let uniformsList: string[];\r\n        let uniformBuffersList: Nullable<string[]> = null;\r\n\r\n        if ((<IEffectCreationOptions>uniformsListOrOptions).uniformsNames) {\r\n            var options = <IEffectCreationOptions>uniformsListOrOptions;\r\n            uniformsList = options.uniformsNames;\r\n            uniformBuffersList = options.uniformBuffersNames;\r\n            samplersList = options.samplers;\r\n            defines = options.defines;\r\n            maxSimultaneousLights = options.maxSimultaneousLights || 0;\r\n        } else {\r\n            uniformsList = <string[]>uniformsListOrOptions;\r\n            if (!samplersList) {\r\n                samplersList = [];\r\n            }\r\n        }\r\n\r\n        for (var lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\r\n            if (!defines[\"LIGHT\" + lightIndex]) {\r\n                break;\r\n            }\r\n            this.PrepareUniformsAndSamplersForLight(lightIndex, uniformsList, samplersList, defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex], uniformBuffersList);\r\n        }\r\n\r\n        if (defines[\"NUM_MORPH_INFLUENCERS\"]) {\r\n            uniformsList.push(\"morphTargetInfluences\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This helps decreasing rank by rank the shadow quality (0 being the highest rank and quality)\r\n     * @param defines The defines to update while falling back\r\n     * @param fallbacks The authorized effect fallbacks\r\n     * @param maxSimultaneousLights The maximum number of lights allowed\r\n     * @param rank the current rank of the Effect\r\n     * @returns The newly affected rank\r\n     */\r\n    public static HandleFallbacksForShadows(defines: any, fallbacks: EffectFallbacks, maxSimultaneousLights = 4, rank = 0): number {\r\n        let lightFallbackRank = 0;\r\n        for (var lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\r\n            if (!defines[\"LIGHT\" + lightIndex]) {\r\n                break;\r\n            }\r\n\r\n            if (lightIndex > 0) {\r\n                lightFallbackRank = rank + lightIndex;\r\n                fallbacks.addFallback(lightFallbackRank, \"LIGHT\" + lightIndex);\r\n            }\r\n\r\n            if (!defines[\"SHADOWS\"]) {\r\n                if (defines[\"SHADOW\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOW\" + lightIndex);\r\n                }\r\n\r\n                if (defines[\"SHADOWPCF\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOWPCF\" + lightIndex);\r\n                }\r\n\r\n                if (defines[\"SHADOWPCSS\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOWPCSS\" + lightIndex);\r\n                }\r\n\r\n                if (defines[\"SHADOWPOISSON\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOWPOISSON\" + lightIndex);\r\n                }\r\n\r\n                if (defines[\"SHADOWESM\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOWESM\" + lightIndex);\r\n                }\r\n            }\r\n        }\r\n        return lightFallbackRank++;\r\n    }\r\n\r\n    private static _TmpMorphInfluencers = { \"NUM_MORPH_INFLUENCERS\": 0 };\r\n    /**\r\n     * Prepares the list of attributes required for morph targets according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param mesh The mesh to prepare the morph targets attributes for\r\n     * @param influencers The number of influencers\r\n     */\r\n    public static PrepareAttributesForMorphTargetsInfluencers(attribs: string[], mesh: AbstractMesh, influencers: number): void {\r\n        this._TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = influencers;\r\n        this.PrepareAttributesForMorphTargets(attribs, mesh, this._TmpMorphInfluencers);\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of attributes required for morph targets according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param mesh The mesh to prepare the morph targets attributes for\r\n     * @param defines The current Defines of the effect\r\n     */\r\n    public static PrepareAttributesForMorphTargets(attribs: string[], mesh: AbstractMesh, defines: any): void {\r\n        var influencers = defines[\"NUM_MORPH_INFLUENCERS\"];\r\n\r\n        if (influencers > 0 && EngineStore.LastCreatedEngine) {\r\n            var maxAttributesCount = EngineStore.LastCreatedEngine.getCaps().maxVertexAttribs;\r\n            var manager = (<Mesh>mesh).morphTargetManager;\r\n            var normal = manager && manager.supportsNormals && defines[\"NORMAL\"];\r\n            var tangent = manager && manager.supportsTangents && defines[\"TANGENT\"];\r\n            var uv = manager && manager.supportsUVs && defines[\"UV1\"];\r\n            for (var index = 0; index < influencers; index++) {\r\n                attribs.push(VertexBuffer.PositionKind + index);\r\n\r\n                if (normal) {\r\n                    attribs.push(VertexBuffer.NormalKind + index);\r\n                }\r\n\r\n                if (tangent) {\r\n                    attribs.push(VertexBuffer.TangentKind + index);\r\n                }\r\n\r\n                if (uv) {\r\n                    attribs.push(VertexBuffer.UVKind + \"_\" + index);\r\n                }\r\n\r\n                if (attribs.length > maxAttributesCount) {\r\n                    Logger.Error(\"Cannot add more vertex attributes for mesh \" + mesh.name);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of attributes required for bones according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param mesh The mesh to prepare the bones attributes for\r\n     * @param defines The current Defines of the effect\r\n     * @param fallbacks The current efffect fallback strategy\r\n     */\r\n    public static PrepareAttributesForBones(attribs: string[], mesh: AbstractMesh, defines: any, fallbacks: EffectFallbacks): void {\r\n        if (defines[\"NUM_BONE_INFLUENCERS\"] > 0) {\r\n            fallbacks.addCPUSkinningFallback(0, mesh);\r\n\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (defines[\"NUM_BONE_INFLUENCERS\"] > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check and prepare the list of attributes required for instances according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param defines The current MaterialDefines of the effect\r\n     */\r\n    public static PrepareAttributesForInstances(attribs: string[], defines: MaterialDefines): void {\r\n        if (defines[\"INSTANCES\"] || defines[\"THIN_INSTANCES\"]) {\r\n            this.PushAttributesForInstances(attribs);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add the list of attributes required for instances to the attribs array.\r\n     * @param attribs The current list of supported attribs\r\n     */\r\n    public static PushAttributesForInstances(attribs: string[]): void {\r\n        attribs.push(\"world0\");\r\n        attribs.push(\"world1\");\r\n        attribs.push(\"world2\");\r\n        attribs.push(\"world3\");\r\n    }\r\n\r\n    /**\r\n     * Binds the light information to the effect.\r\n     * @param light The light containing the generator\r\n     * @param effect The effect we are binding the data to\r\n     * @param lightIndex The light index in the effect used to render\r\n     */\r\n    public static BindLightProperties(light: Light, effect: Effect, lightIndex: number): void {\r\n        light.transferToEffect(effect, lightIndex + \"\");\r\n    }\r\n\r\n    /**\r\n     * Binds the lights information from the scene to the effect for the given mesh.\r\n     * @param light Light to bind\r\n     * @param lightIndex Light index\r\n     * @param scene The scene where the light belongs to\r\n     * @param effect The effect we are binding the data to\r\n     * @param useSpecular Defines if specular is supported\r\n     * @param rebuildInParallel Specifies whether the shader is rebuilding in parallel\r\n     */\r\n    public static BindLight(light: Light, lightIndex: number, scene: Scene, effect: Effect, useSpecular: boolean, rebuildInParallel = false): void {\r\n        light._bindLight(lightIndex, scene, effect, useSpecular, rebuildInParallel);\r\n    }\r\n\r\n    /**\r\n     * Binds the lights information from the scene to the effect for the given mesh.\r\n     * @param scene The scene the lights belongs to\r\n     * @param mesh The mesh we are binding the information to render\r\n     * @param effect The effect we are binding the data to\r\n     * @param defines The generated defines for the effect\r\n     * @param maxSimultaneousLights The maximum number of light that can be bound to the effect\r\n     * @param rebuildInParallel Specifies whether the shader is rebuilding in parallel\r\n     */\r\n    public static BindLights(scene: Scene, mesh: AbstractMesh, effect: Effect, defines: any, maxSimultaneousLights = 4, rebuildInParallel = false): void {\r\n        let len = Math.min(mesh.lightSources.length, maxSimultaneousLights);\r\n\r\n        for (var i = 0; i < len; i++) {\r\n\r\n            let light = mesh.lightSources[i];\r\n            this.BindLight(light, i, scene, effect, typeof defines === \"boolean\" ? defines : defines[\"SPECULARTERM\"], rebuildInParallel);\r\n        }\r\n    }\r\n\r\n    private static _tempFogColor = Color3.Black();\r\n    /**\r\n     * Binds the fog information from the scene to the effect for the given mesh.\r\n     * @param scene The scene the lights belongs to\r\n     * @param mesh The mesh we are binding the information to render\r\n     * @param effect The effect we are binding the data to\r\n     * @param linearSpace Defines if the fog effect is applied in linear space\r\n     */\r\n    public static BindFogParameters(scene: Scene, mesh: AbstractMesh, effect: Effect, linearSpace = false): void {\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            effect.setFloat4(\"vFogInfos\", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);\r\n            // Convert fog color to linear space if used in a linear space computed shader.\r\n            if (linearSpace) {\r\n                scene.fogColor.toLinearSpaceToRef(this._tempFogColor);\r\n                effect.setColor3(\"vFogColor\", this._tempFogColor);\r\n            }\r\n            else {\r\n                effect.setColor3(\"vFogColor\", scene.fogColor);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the bones information from the mesh to the effect.\r\n     * @param mesh The mesh we are binding the information to render\r\n     * @param effect The effect we are binding the data to\r\n     */\r\n    public static BindBonesParameters(mesh?: AbstractMesh, effect?: Effect): void {\r\n        if (!effect || !mesh) {\r\n            return;\r\n        }\r\n        if (mesh.computeBonesUsingShaders && effect._bonesComputationForcedToCPU) {\r\n            mesh.computeBonesUsingShaders = false;\r\n        }\r\n\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n            const skeleton = mesh.skeleton;\r\n\r\n            if (skeleton.isUsingTextureForMatrices && effect.getUniformIndex(\"boneTextureWidth\") > -1) {\r\n                const boneTexture = skeleton.getTransformMatrixTexture(mesh);\r\n                effect.setTexture(\"boneSampler\", boneTexture);\r\n                effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\r\n            } else {\r\n                const matrices = skeleton.getTransformMatrices(mesh);\r\n\r\n                if (matrices) {\r\n                    effect.setMatrices(\"mBones\", matrices);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the morph targets information from the mesh to the effect.\r\n     * @param abstractMesh The mesh we are binding the information to render\r\n     * @param effect The effect we are binding the data to\r\n     */\r\n    public static BindMorphTargetParameters(abstractMesh: AbstractMesh, effect: Effect): void {\r\n        let manager = (<Mesh>abstractMesh).morphTargetManager;\r\n        if (!abstractMesh || !manager) {\r\n            return;\r\n        }\r\n\r\n        effect.setFloatArray(\"morphTargetInfluences\", manager.influences);\r\n    }\r\n\r\n    /**\r\n     * Binds the logarithmic depth information from the scene to the effect for the given defines.\r\n     * @param defines The generated defines used in the effect\r\n     * @param effect The effect we are binding the data to\r\n     * @param scene The scene we are willing to render with logarithmic scale for\r\n     */\r\n    public static BindLogDepth(defines: any, effect: Effect, scene: Scene): void {\r\n        if (defines[\"LOGARITHMICDEPTH\"]) {\r\n            effect.setFloat(\"logarithmicDepthConstant\", 2.0 / (Math.log((<Camera>scene.activeCamera).maxZ + 1.0) / Math.LN2));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the clip plane information from the scene to the effect.\r\n     * @param scene The scene the clip plane information are extracted from\r\n     * @param effect The effect we are binding the data to\r\n     */\r\n    public static BindClipPlane(effect: Effect, scene: Scene): void {\r\n        ThinMaterialHelper.BindClipPlane(effect, scene);\r\n    }\r\n}\r\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'defaultFragmentDeclaration';\nlet shader = `uniform vec4 vDiffuseColor;\n#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\n#endif\nuniform vec3 vEmissiveColor;\nuniform float visibility;\n\n#ifdef DIFFUSE\nuniform vec2 vDiffuseInfos;\n#endif\n#ifdef AMBIENT\nuniform vec2 vAmbientInfos;\n#endif\n#ifdef OPACITY\nuniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\n#endif\n#ifdef LIGHTMAP\nuniform vec2 vLightmapInfos;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;\nuniform vec2 vTangentSpaceParams;\n#endif\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION)\nuniform mat4 view;\n#endif\n#ifdef REFRACTION\nuniform vec4 vRefractionInfos;\n#ifndef REFRACTIONMAP_3D\nuniform mat4 refractionMatrix;\n#endif\n#ifdef REFRACTIONFRESNEL\nuniform vec4 refractionLeftColor;\nuniform vec4 refractionRightColor;\n#endif\n#endif\n#if defined(SPECULAR) && defined(SPECULARTERM)\nuniform vec2 vSpecularInfos;\n#endif\n#ifdef DIFFUSEFRESNEL\nuniform vec4 diffuseLeftColor;\nuniform vec4 diffuseRightColor;\n#endif\n#ifdef OPACITYFRESNEL\nuniform vec4 opacityParts;\n#endif\n#ifdef EMISSIVEFRESNEL\nuniform vec4 emissiveLeftColor;\nuniform vec4 emissiveRightColor;\n#endif\n\n#ifdef REFLECTION\nuniform vec2 vReflectionInfos;\n#if defined(REFLECTIONMAP_PLANAR) || defined(REFLECTIONMAP_CUBIC) || defined(REFLECTIONMAP_PROJECTION) || defined(REFLECTIONMAP_EQUIRECTANGULAR) || defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_SKYBOX)\nuniform mat4 reflectionMatrix;\n#endif\n#ifndef REFLECTIONMAP_SKYBOX\n#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)\nuniform vec3 vReflectionPosition;\nuniform vec3 vReflectionSize;\n#endif\n#endif\n#ifdef REFLECTIONFRESNEL\nuniform vec4 reflectionLeftColor;\nuniform vec4 reflectionRightColor;\n#endif\n#endif`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var defaultFragmentDeclaration = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'defaultUboDeclaration';\nlet shader = `layout(std140,column_major) uniform;\nuniform Material\n{\nvec4 diffuseLeftColor;\nvec4 diffuseRightColor;\nvec4 opacityParts;\nvec4 reflectionLeftColor;\nvec4 reflectionRightColor;\nvec4 refractionLeftColor;\nvec4 refractionRightColor;\nvec4 emissiveLeftColor;\nvec4 emissiveRightColor;\nvec2 vDiffuseInfos;\nvec2 vAmbientInfos;\nvec2 vOpacityInfos;\nvec2 vReflectionInfos;\nvec3 vReflectionPosition;\nvec3 vReflectionSize;\nvec2 vEmissiveInfos;\nvec2 vLightmapInfos;\nvec2 vSpecularInfos;\nvec3 vBumpInfos;\nmat4 diffuseMatrix;\nmat4 ambientMatrix;\nmat4 opacityMatrix;\nmat4 reflectionMatrix;\nmat4 emissiveMatrix;\nmat4 lightmapMatrix;\nmat4 specularMatrix;\nmat4 bumpMatrix;\nvec2 vTangentSpaceParams;\nfloat pointSize;\nmat4 refractionMatrix;\nvec4 vRefractionInfos;\nvec4 vSpecularColor;\nvec3 vEmissiveColor;\nfloat visibility;\nvec4 vDiffuseColor;\nvec4 vDetailInfos;\nmat4 detailMatrix;\n};\nuniform Scene {\nmat4 viewProjection;\n#ifdef MULTIVIEW\nmat4 viewProjectionR;\n#endif\nmat4 view;\n};\n`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var defaultUboDeclaration = { name, shader };\n","import { Effect } from \"../Materials/effect\";\nimport \"./ShadersInclude/defaultFragmentDeclaration\";\nimport \"./ShadersInclude/defaultUboDeclaration\";\nimport \"./ShadersInclude/prePassDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/lightFragmentDeclaration\";\nimport \"./ShadersInclude/lightUboDeclaration\";\nimport \"./ShadersInclude/lightsFragmentFunctions\";\nimport \"./ShadersInclude/shadowsFragmentFunctions\";\nimport \"./ShadersInclude/fresnelFunction\";\nimport \"./ShadersInclude/reflectionFunction\";\nimport \"./ShadersInclude/imageProcessingDeclaration\";\nimport \"./ShadersInclude/imageProcessingFunctions\";\nimport \"./ShadersInclude/bumpFragmentMainFunctions\";\nimport \"./ShadersInclude/bumpFragmentFunctions\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/fogFragmentDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nimport \"./ShadersInclude/bumpFragment\";\nimport \"./ShadersInclude/depthPrePass\";\nimport \"./ShadersInclude/lightFragment\";\nimport \"./ShadersInclude/logDepthFragment\";\nimport \"./ShadersInclude/fogFragment\";\n\nlet name = 'defaultPixelShader';\nlet shader = `#include<__decl__defaultFragment>\n#if defined(BUMP) || !defined(NORMAL)\n#extension GL_OES_standard_derivatives : enable\n#endif\n#include<prePassDeclaration>[SCENE_MRT_COUNT]\n#define CUSTOM_FRAGMENT_BEGIN\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n\n#define RECIPROCAL_PI2 0.15915494\nuniform vec3 vEyePosition;\nuniform vec3 vAmbientColor;\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#ifdef MAINUV1\nvarying vec2 vMainUV1;\n#endif\n#ifdef MAINUV2\nvarying vec2 vMainUV2;\n#endif\n#ifdef PREPASS\nvarying vec3 vViewPos;\n#endif\n\n#include<helperFunctions>\n\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n\n#ifdef DIFFUSE\n#if DIFFUSEDIRECTUV == 1\n#define vDiffuseUV vMainUV1\n#elif DIFFUSEDIRECTUV == 2\n#define vDiffuseUV vMainUV2\n#else\nvarying vec2 vDiffuseUV;\n#endif\nuniform sampler2D diffuseSampler;\n#endif\n#ifdef AMBIENT\n#if AMBIENTDIRECTUV == 1\n#define vAmbientUV vMainUV1\n#elif AMBIENTDIRECTUV == 2\n#define vAmbientUV vMainUV2\n#else\nvarying vec2 vAmbientUV;\n#endif\nuniform sampler2D ambientSampler;\n#endif\n#ifdef OPACITY\n#if OPACITYDIRECTUV == 1\n#define vOpacityUV vMainUV1\n#elif OPACITYDIRECTUV == 2\n#define vOpacityUV vMainUV2\n#else\nvarying vec2 vOpacityUV;\n#endif\nuniform sampler2D opacitySampler;\n#endif\n#ifdef EMISSIVE\n#if EMISSIVEDIRECTUV == 1\n#define vEmissiveUV vMainUV1\n#elif EMISSIVEDIRECTUV == 2\n#define vEmissiveUV vMainUV2\n#else\nvarying vec2 vEmissiveUV;\n#endif\nuniform sampler2D emissiveSampler;\n#endif\n#ifdef LIGHTMAP\n#if LIGHTMAPDIRECTUV == 1\n#define vLightmapUV vMainUV1\n#elif LIGHTMAPDIRECTUV == 2\n#define vLightmapUV vMainUV2\n#else\nvarying vec2 vLightmapUV;\n#endif\nuniform sampler2D lightmapSampler;\n#endif\n#ifdef REFRACTION\n#ifdef REFRACTIONMAP_3D\nuniform samplerCube refractionCubeSampler;\n#else\nuniform sampler2D refraction2DSampler;\n#endif\n#endif\n#if defined(SPECULAR) && defined(SPECULARTERM)\n#if SPECULARDIRECTUV == 1\n#define vSpecularUV vMainUV1\n#elif SPECULARDIRECTUV == 2\n#define vSpecularUV vMainUV2\n#else\nvarying vec2 vSpecularUV;\n#endif\nuniform sampler2D specularSampler;\n#endif\n#ifdef ALPHATEST\nuniform float alphaCutOff;\n#endif\n\n#include<fresnelFunction>\n\n#ifdef REFLECTION\n#ifdef REFLECTIONMAP_3D\nuniform samplerCube reflectionCubeSampler;\n#else\nuniform sampler2D reflection2DSampler;\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#else\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\n#endif\n#include<reflectionFunction>\n#endif\n#include<imageProcessingDeclaration>\n#include<imageProcessingFunctions>\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition-vPositionW);\n\nvec4 baseColor=vec4(1.,1.,1.,1.);\nvec3 diffuseColor=vDiffuseColor.rgb;\n\nfloat alpha=vDiffuseColor.a;\n\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=normalize(-cross(dFdx(vPositionW),dFdy(vPositionW)));\n#endif\n#include<bumpFragment>\n#ifdef TWOSIDEDLIGHTING\nnormalW=gl_FrontFacing ? normalW : -normalW;\n#endif\n#ifdef DIFFUSE\nbaseColor=texture2D(diffuseSampler,vDiffuseUV+uvOffset);\n#if defined(ALPHATEST) && !defined(ALPHATEST_AFTERALLALPHACOMPUTATIONS)\nif (baseColor.a<alphaCutOff)\ndiscard;\n#endif\n#ifdef ALPHAFROMDIFFUSE\nalpha*=baseColor.a;\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_ALPHA\nbaseColor.rgb*=vDiffuseInfos.y;\n#endif\n#include<depthPrePass>\n#ifdef VERTEXCOLOR\nbaseColor.rgb*=vColor.rgb;\n#endif\n#ifdef DETAIL\nbaseColor.rgb=baseColor.rgb*2.0*mix(0.5,detailColor.r,vDetailInfos.y);\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE\n\nvec3 baseAmbientColor=vec3(1.,1.,1.);\n#ifdef AMBIENT\nbaseAmbientColor=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb*vAmbientInfos.y;\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_LIGHTS\n\n#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;\nvec3 specularColor=vSpecularColor.rgb;\n#ifdef SPECULAR\nvec4 specularMapColor=texture2D(specularSampler,vSpecularUV+uvOffset);\nspecularColor=specularMapColor.rgb;\n#ifdef GLOSSINESS\nglossiness=glossiness*specularMapColor.a;\n#endif\n#endif\n#else\nfloat glossiness=0.;\n#endif\n\nvec3 diffuseBase=vec3(0.,0.,0.);\nlightingInfo info;\n#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\n#endif\nfloat shadow=1.;\n#ifdef LIGHTMAP\nvec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);\n#ifdef RGBDLIGHTMAP\nlightmapColor.rgb=fromRGBD(lightmapColor);\n#endif\nlightmapColor.rgb*=vLightmapInfos.y;\n#endif\n#include<lightFragment>[0..maxSimultaneousLights]\n\nvec4 refractionColor=vec4(0.,0.,0.,1.);\n#ifdef REFRACTION\nvec3 refractionVector=normalize(refract(-viewDirectionW,normalW,vRefractionInfos.y));\n#ifdef REFRACTIONMAP_3D\nrefractionVector.y=refractionVector.y*vRefractionInfos.w;\nif (dot(refractionVector,viewDirectionW)<1.0) {\nrefractionColor=textureCube(refractionCubeSampler,refractionVector);\n}\n#else\nvec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));\nvec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;\nrefractionCoords.y=1.0-refractionCoords.y;\nrefractionColor=texture2D(refraction2DSampler,refractionCoords);\n#endif\n#ifdef RGBDREFRACTION\nrefractionColor.rgb=fromRGBD(refractionColor);\n#endif\n#ifdef IS_REFRACTION_LINEAR\nrefractionColor.rgb=toGammaSpace(refractionColor.rgb);\n#endif\nrefractionColor.rgb*=vRefractionInfos.x;\n#endif\n\nvec4 reflectionColor=vec4(0.,0.,0.,1.);\n#ifdef REFLECTION\nvec3 vReflectionUVW=computeReflectionCoords(vec4(vPositionW,1.0),normalW);\n#ifdef REFLECTIONMAP_3D\n#ifdef ROUGHNESS\nfloat bias=vReflectionInfos.y;\n#ifdef SPECULARTERM\n#ifdef SPECULAR\n#ifdef GLOSSINESS\nbias*=(1.0-specularMapColor.a);\n#endif\n#endif\n#endif\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW,bias);\n#else\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW);\n#endif\n#else\nvec2 coords=vReflectionUVW.xy;\n#ifdef REFLECTIONMAP_PROJECTION\ncoords/=vReflectionUVW.z;\n#endif\ncoords.y=1.0-coords.y;\nreflectionColor=texture2D(reflection2DSampler,coords);\n#endif\n#ifdef RGBDREFLECTION\nreflectionColor.rgb=fromRGBD(reflectionColor);\n#endif\n#ifdef IS_REFLECTION_LINEAR\nreflectionColor.rgb=toGammaSpace(reflectionColor.rgb);\n#endif\nreflectionColor.rgb*=vReflectionInfos.x;\n#ifdef REFLECTIONFRESNEL\nfloat reflectionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,reflectionRightColor.a,reflectionLeftColor.a);\n#ifdef REFLECTIONFRESNELFROMSPECULAR\n#ifdef SPECULARTERM\nreflectionColor.rgb*=specularColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\n#else\nreflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\n#endif\n#else\nreflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\n#endif\n#endif\n#endif\n#ifdef REFRACTIONFRESNEL\nfloat refractionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,refractionRightColor.a,refractionLeftColor.a);\nrefractionColor.rgb*=refractionLeftColor.rgb*(1.0-refractionFresnelTerm)+refractionFresnelTerm*refractionRightColor.rgb;\n#endif\n#ifdef OPACITY\nvec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);\n#ifdef OPACITYRGB\nopacityMap.rgb=opacityMap.rgb*vec3(0.3,0.59,0.11);\nalpha*=(opacityMap.x+opacityMap.y+opacityMap.z)* vOpacityInfos.y;\n#else\nalpha*=opacityMap.a*vOpacityInfos.y;\n#endif\n#endif\n#ifdef VERTEXALPHA\nalpha*=vColor.a;\n#endif\n#ifdef OPACITYFRESNEL\nfloat opacityFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,opacityParts.z,opacityParts.w);\nalpha+=opacityParts.x*(1.0-opacityFresnelTerm)+opacityFresnelTerm*opacityParts.y;\n#endif\n#ifdef ALPHATEST\n#ifdef ALPHATEST_AFTERALLALPHACOMPUTATIONS\nif (alpha<alphaCutOff)\ndiscard;\n#endif\n#ifndef ALPHABLEND\n\nalpha=1.0;\n#endif\n#endif\n\nvec3 emissiveColor=vEmissiveColor;\n#ifdef EMISSIVE\nemissiveColor+=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb*vEmissiveInfos.y;\n#endif\n#ifdef EMISSIVEFRESNEL\nfloat emissiveFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,emissiveRightColor.a,emissiveLeftColor.a);\nemissiveColor*=emissiveLeftColor.rgb*(1.0-emissiveFresnelTerm)+emissiveFresnelTerm*emissiveRightColor.rgb;\n#endif\n\n#ifdef DIFFUSEFRESNEL\nfloat diffuseFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,diffuseRightColor.a,diffuseLeftColor.a);\ndiffuseBase*=diffuseLeftColor.rgb*(1.0-diffuseFresnelTerm)+diffuseFresnelTerm*diffuseRightColor.rgb;\n#endif\n\n#ifdef EMISSIVEASILLUMINATION\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n#else\n#ifdef LINKEMISSIVEWITHDIFFUSE\nvec3 finalDiffuse=clamp((diffuseBase+emissiveColor)*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n#else\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+emissiveColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n#endif\n#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\n#ifdef SPECULAROVERALPHA\nalpha=clamp(alpha+dot(finalSpecular,vec3(0.3,0.59,0.11)),0.,1.);\n#endif\n#else\nvec3 finalSpecular=vec3(0.0);\n#endif\n#ifdef REFLECTIONOVERALPHA\nalpha=clamp(alpha+dot(reflectionColor.rgb,vec3(0.3,0.59,0.11)),0.,1.);\n#endif\n\n#ifdef EMISSIVEASILLUMINATION\nvec4 color=vec4(clamp(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+emissiveColor+refractionColor.rgb,0.0,1.0),alpha);\n#else\nvec4 color=vec4(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+refractionColor.rgb,alpha);\n#endif\n\n#ifdef LIGHTMAP\n#ifndef LIGHTMAPEXCLUDED\n#ifdef USELIGHTMAPASSHADOWMAP\ncolor.rgb*=lightmapColor.rgb;\n#else\ncolor.rgb+=lightmapColor.rgb;\n#endif\n#endif\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_FOG\ncolor.rgb=max(color.rgb,0.);\n#include<logDepthFragment>\n#include<fogFragment>\n\n\n#ifdef IMAGEPROCESSINGPOSTPROCESS\ncolor.rgb=toLinearSpace(color.rgb);\n#else\n#ifdef IMAGEPROCESSING\ncolor.rgb=toLinearSpace(color.rgb);\ncolor=applyImageProcessing(color);\n#endif\n#endif\ncolor.a*=visibility;\n#ifdef PREMULTIPLYALPHA\n\ncolor.rgb*=color.a;\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\n#ifdef PREPASS\ngl_FragData[0]=color;\n#ifdef PREPASS_IRRADIANCE\ngl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(0.0,0.0,0.0,1.0);\n#endif\n#ifdef PREPASS_DEPTHNORMAL\ngl_FragData[PREPASS_DEPTHNORMAL_INDEX]=vec4(vViewPos.z,(view*vec4(normalW,0.0)).rgb);\n#endif\n#ifdef PREPASS_ALBEDO\ngl_FragData[PREPASS_ALBEDO_INDEX]=vec4(0.0,0.0,0.0,1.0);\n#endif\n#endif\ngl_FragColor=color;\n}\n`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var defaultPixelShader = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'defaultVertexDeclaration';\nlet shader = `\nuniform mat4 viewProjection;\nuniform mat4 view;\n#ifdef DIFFUSE\nuniform mat4 diffuseMatrix;\nuniform vec2 vDiffuseInfos;\n#endif\n#ifdef AMBIENT\nuniform mat4 ambientMatrix;\nuniform vec2 vAmbientInfos;\n#endif\n#ifdef OPACITY\nuniform mat4 opacityMatrix;\nuniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\nuniform mat4 emissiveMatrix;\n#endif\n#ifdef LIGHTMAP\nuniform vec2 vLightmapInfos;\nuniform mat4 lightmapMatrix;\n#endif\n#if defined(SPECULAR) && defined(SPECULARTERM)\nuniform vec2 vSpecularInfos;\nuniform mat4 specularMatrix;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;\nuniform mat4 bumpMatrix;\n#endif\n#ifdef REFLECTION\nuniform mat4 reflectionMatrix;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var defaultVertexDeclaration = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'pointCloudVertex';\nlet shader = `#ifdef POINTSIZE\ngl_PointSize=pointSize;\n#endif`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pointCloudVertex = { name, shader };\n","import { Effect } from \"../Materials/effect\";\nimport \"./ShadersInclude/defaultVertexDeclaration\";\nimport \"./ShadersInclude/defaultUboDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/bumpVertexDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/fogVertexDeclaration\";\nimport \"./ShadersInclude/lightFragmentDeclaration\";\nimport \"./ShadersInclude/lightUboDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertex\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bumpVertex\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/fogVertex\";\nimport \"./ShadersInclude/shadowsVertex\";\nimport \"./ShadersInclude/pointCloudVertex\";\nimport \"./ShadersInclude/logDepthVertex\";\n\nlet name = 'defaultVertexShader';\nlet shader = `#include<__decl__defaultVertex>\n\n#define CUSTOM_VERTEX_BEGIN\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef TANGENT\nattribute vec4 tangent;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<helperFunctions>\n#include<bonesDeclaration>\n\n#include<instancesDeclaration>\n#ifdef PREPASS\nvarying vec3 vViewPos;\n#endif\n#ifdef MAINUV1\nvarying vec2 vMainUV1;\n#endif\n#ifdef MAINUV2\nvarying vec2 vMainUV2;\n#endif\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV == 0\nvarying vec2 vDiffuseUV;\n#endif\n#if defined(DETAIL) && DETAILDIRECTUV == 0\nvarying vec2 vDetailUV;\n#endif\n#if defined(AMBIENT) && AMBIENTDIRECTUV == 0\nvarying vec2 vAmbientUV;\n#endif\n#if defined(OPACITY) && OPACITYDIRECTUV == 0\nvarying vec2 vOpacityUV;\n#endif\n#if defined(EMISSIVE) && EMISSIVEDIRECTUV == 0\nvarying vec2 vEmissiveUV;\n#endif\n#if defined(LIGHTMAP) && LIGHTMAPDIRECTUV == 0\nvarying vec2 vLightmapUV;\n#endif\n#if defined(SPECULAR) && defined(SPECULARTERM) && SPECULARDIRECTUV == 0\nvarying vec2 vSpecularUV;\n#endif\n#if defined(BUMP) && BUMPDIRECTUV == 0\nvarying vec2 vBumpUV;\n#endif\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<bumpVertexDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvec3 positionUpdated=position;\n#ifdef NORMAL\nvec3 normalUpdated=normal;\n#endif\n#ifdef TANGENT\nvec4 tangentUpdated=tangent;\n#endif\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvPositionUVW=positionUpdated;\n#endif\n#define CUSTOM_VERTEX_UPDATE_POSITION\n#define CUSTOM_VERTEX_UPDATE_NORMAL\n#include<instancesVertex>\n#include<bonesVertex>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\n#ifdef NORMAL\nmat3 normalWorld=mat3(finalWorld);\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\nvNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));\nvNormalW=normalize(normalWorld*vNormalW);\n#else\n#ifdef NONUNIFORMSCALING\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\n#endif\nvNormalW=normalize(normalWorld*normalUpdated);\n#endif\n#endif\n#define CUSTOM_VERTEX_UPDATE_WORLDPOS\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR == 0u) {\ngl_Position=viewProjection*worldPos;\n} else {\ngl_Position=viewProjectionR*worldPos;\n}\n#else\ngl_Position=viewProjection*worldPos;\n#endif\nvPositionW=vec3(worldPos);\n#ifdef PREPASS\nvViewPos=(view*worldPos).rgb;\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));\n#endif\n\n#ifndef UV1\nvec2 uvUpdated=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef MAINUV1\nvMainUV1=uvUpdated;\n#endif\n#ifdef MAINUV2\nvMainUV2=uv2;\n#endif\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV == 0\nif (vDiffuseInfos.x == 0.)\n{\nvDiffuseUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#if defined(DETAIL) && DETAILDIRECTUV == 0\nif (vDetailInfos.x == 0.)\n{\nvDetailUV=vec2(detailMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvDetailUV=vec2(detailMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#if defined(AMBIENT) && AMBIENTDIRECTUV == 0\nif (vAmbientInfos.x == 0.)\n{\nvAmbientUV=vec2(ambientMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvAmbientUV=vec2(ambientMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#if defined(OPACITY) && OPACITYDIRECTUV == 0\nif (vOpacityInfos.x == 0.)\n{\nvOpacityUV=vec2(opacityMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvOpacityUV=vec2(opacityMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#if defined(EMISSIVE) && EMISSIVEDIRECTUV == 0\nif (vEmissiveInfos.x == 0.)\n{\nvEmissiveUV=vec2(emissiveMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvEmissiveUV=vec2(emissiveMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#if defined(LIGHTMAP) && LIGHTMAPDIRECTUV == 0\nif (vLightmapInfos.x == 0.)\n{\nvLightmapUV=vec2(lightmapMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvLightmapUV=vec2(lightmapMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#if defined(SPECULAR) && defined(SPECULARTERM) && SPECULARDIRECTUV == 0\nif (vSpecularInfos.x == 0.)\n{\nvSpecularUV=vec2(specularMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvSpecularUV=vec2(specularMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#if defined(BUMP) && BUMPDIRECTUV == 0\nif (vBumpInfos.x == 0.)\n{\nvBumpUV=vec2(bumpMatrix*vec4(uvUpdated,1.0,0.0));\n}\nelse\n{\nvBumpUV=vec2(bumpMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#include<bumpVertex>\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#ifdef VERTEXCOLOR\n\nvColor=color;\n#endif\n#include<pointCloudVertex>\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var defaultVertexShader = { name, shader };\n","import { serialize, SerializationHelper, serializeAsColor3, expandToProperty, serializeAsFresnelParameters, serializeAsTexture } from \"../Misc/decorators\";\r\nimport { Observer } from \"../Misc/observable\";\r\nimport { SmartArray } from \"../Misc/smartArray\";\r\nimport { IAnimatable } from '../Animations/animatable.interface';\r\n\r\nimport { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Matrix } from \"../Maths/math.vector\";\r\nimport { Color3 } from '../Maths/math.color';\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\n\r\nimport { ImageProcessingConfiguration, IImageProcessingConfigurationDefines } from \"./imageProcessingConfiguration\";\r\nimport { ColorCurves } from \"./colorCurves\";\r\nimport { FresnelParameters } from \"./fresnelParameters\";\r\nimport { Material, ICustomShaderNameResolveOptions } from \"../Materials/material\";\r\nimport { MaterialDefines } from \"../Materials/materialDefines\";\r\nimport { PushMaterial } from \"./pushMaterial\";\r\nimport { MaterialHelper } from \"./materialHelper\";\r\n\r\nimport { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { CubeTexture } from \"../Materials/Textures/cubeTexture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { _TypeStore } from \"../Misc/typeStore\";\r\nimport { MaterialFlags } from \"./materialFlags\";\r\n\r\nimport \"../Shaders/default.fragment\";\r\nimport \"../Shaders/default.vertex\";\r\n\r\nimport { EffectFallbacks } from './effectFallbacks';\r\nimport { Effect, IEffectCreationOptions } from './effect';\r\nimport { IMaterialDetailMapDefines, DetailMapConfiguration } from './material.detailMapConfiguration';\r\n\r\nconst onCreatedEffectParameters = { effect: null as unknown as Effect, subMesh: null as unknown as Nullable<SubMesh> };\r\n\r\n/** @hidden */\r\nexport class StandardMaterialDefines extends MaterialDefines implements IImageProcessingConfigurationDefines, IMaterialDetailMapDefines {\r\n    public MAINUV1 = false;\r\n    public MAINUV2 = false;\r\n    public DIFFUSE = false;\r\n    public DIFFUSEDIRECTUV = 0;\r\n    public DETAIL = false;\r\n    public DETAILDIRECTUV = 0;\r\n    public DETAIL_NORMALBLENDMETHOD = 0;\r\n    public AMBIENT = false;\r\n    public AMBIENTDIRECTUV = 0;\r\n    public OPACITY = false;\r\n    public OPACITYDIRECTUV = 0;\r\n    public OPACITYRGB = false;\r\n    public REFLECTION = false;\r\n    public EMISSIVE = false;\r\n    public EMISSIVEDIRECTUV = 0;\r\n    public SPECULAR = false;\r\n    public SPECULARDIRECTUV = 0;\r\n    public BUMP = false;\r\n    public BUMPDIRECTUV = 0;\r\n    public PARALLAX = false;\r\n    public PARALLAXOCCLUSION = false;\r\n    public SPECULAROVERALPHA = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public ALPHAFROMDIFFUSE = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public SPECULARTERM = false;\r\n    public DIFFUSEFRESNEL = false;\r\n    public OPACITYFRESNEL = false;\r\n    public REFLECTIONFRESNEL = false;\r\n    public REFRACTIONFRESNEL = false;\r\n    public EMISSIVEFRESNEL = false;\r\n    public FRESNEL = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public BONETEXTURE = false;\r\n    public INSTANCES = false;\r\n    public THIN_INSTANCES = false;\r\n    public GLOSSINESS = false;\r\n    public ROUGHNESS = false;\r\n    public EMISSIVEASILLUMINATION = false;\r\n    public LINKEMISSIVEWITHDIFFUSE = false;\r\n    public REFLECTIONFRESNELFROMSPECULAR = false;\r\n    public LIGHTMAP = false;\r\n    public LIGHTMAPDIRECTUV = 0;\r\n    public OBJECTSPACE_NORMALMAP = false;\r\n    public USELIGHTMAPASSHADOWMAP = false;\r\n    public REFLECTIONMAP_3D = false;\r\n    public REFLECTIONMAP_SPHERICAL = false;\r\n    public REFLECTIONMAP_PLANAR = false;\r\n    public REFLECTIONMAP_CUBIC = false;\r\n    public USE_LOCAL_REFLECTIONMAP_CUBIC = false;\r\n    public REFLECTIONMAP_PROJECTION = false;\r\n    public REFLECTIONMAP_SKYBOX = false;\r\n    public REFLECTIONMAP_EXPLICIT = false;\r\n    public REFLECTIONMAP_EQUIRECTANGULAR = false;\r\n    public REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\r\n    public REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\r\n    public INVERTCUBICMAP = false;\r\n    public LOGARITHMICDEPTH = false;\r\n    public REFRACTION = false;\r\n    public REFRACTIONMAP_3D = false;\r\n    public REFLECTIONOVERALPHA = false;\r\n    public TWOSIDEDLIGHTING = false;\r\n    public SHADOWFLOAT = false;\r\n    public MORPHTARGETS = false;\r\n    public MORPHTARGETS_NORMAL = false;\r\n    public MORPHTARGETS_TANGENT = false;\r\n    public MORPHTARGETS_UV = false;\r\n    public NUM_MORPH_INFLUENCERS = 0;\r\n    public NONUNIFORMSCALING = false; // https://playground.babylonjs.com#V6DWIH\r\n    public PREMULTIPLYALPHA = false; // https://playground.babylonjs.com#LNVJJ7\r\n    public ALPHATEST_AFTERALLALPHACOMPUTATIONS = false;\r\n    public ALPHABLEND = true;\r\n\r\n    public PREPASS = false;\r\n    public PREPASS_IRRADIANCE = false;\r\n    public PREPASS_IRRADIANCE_INDEX = -1;\r\n    public PREPASS_ALBEDO = false;\r\n    public PREPASS_ALBEDO_INDEX = -1;\r\n    public PREPASS_DEPTHNORMAL = false;\r\n    public PREPASS_DEPTHNORMAL_INDEX = -1;\r\n    public SCENE_MRT_COUNT = 0;\r\n\r\n    public RGBDLIGHTMAP = false;\r\n    public RGBDREFLECTION = false;\r\n    public RGBDREFRACTION = false;\r\n\r\n    public IMAGEPROCESSING = false;\r\n    public VIGNETTE = false;\r\n    public VIGNETTEBLENDMODEMULTIPLY = false;\r\n    public VIGNETTEBLENDMODEOPAQUE = false;\r\n    public TONEMAPPING = false;\r\n    public TONEMAPPING_ACES = false;\r\n    public CONTRAST = false;\r\n    public COLORCURVES = false;\r\n    public COLORGRADING = false;\r\n    public COLORGRADING3D = false;\r\n    public SAMPLER3DGREENDEPTH = false;\r\n    public SAMPLER3DBGRMAP = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public MULTIVIEW = false;\r\n    /**\r\n     * If the reflection texture on this material is in linear color space\r\n     * @hidden\r\n     */\r\n    public IS_REFLECTION_LINEAR = false;\r\n    /**\r\n     * If the refraction texture on this material is in linear color space\r\n     * @hidden\r\n     */\r\n    public IS_REFRACTION_LINEAR = false;\r\n    public EXPOSURE = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n\r\n    public setReflectionMode(modeToEnable: string) {\r\n        var modes = [\r\n            \"REFLECTIONMAP_CUBIC\", \"REFLECTIONMAP_EXPLICIT\", \"REFLECTIONMAP_PLANAR\",\r\n            \"REFLECTIONMAP_PROJECTION\", \"REFLECTIONMAP_PROJECTION\", \"REFLECTIONMAP_SKYBOX\",\r\n            \"REFLECTIONMAP_SPHERICAL\", \"REFLECTIONMAP_EQUIRECTANGULAR\", \"REFLECTIONMAP_EQUIRECTANGULAR_FIXED\",\r\n            \"REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\"\r\n        ];\r\n\r\n        for (var mode of modes) {\r\n            (<any>this)[mode] = (mode === modeToEnable);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * This is the default material used in Babylon. It is the best trade off between quality\r\n * and performances.\r\n * @see https://doc.babylonjs.com/babylon101/materials\r\n */\r\nexport class StandardMaterial extends PushMaterial {\r\n    @serializeAsTexture(\"diffuseTexture\")\r\n    private _diffuseTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * The basic texture of the material as viewed under a light.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\r\n    public diffuseTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsTexture(\"ambientTexture\")\r\n    private _ambientTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * AKA Occlusion Texture in other nomenclature, it helps adding baked shadows into your material.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public ambientTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsTexture(\"opacityTexture\")\r\n    private _opacityTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Define the transparency of the material from a texture.\r\n     * The final alpha value can be read either from the red channel (if texture.getAlphaFromRGB is false)\r\n     * or from the luminance or the current texel (if texture.getAlphaFromRGB is true)\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\r\n    public opacityTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsTexture(\"reflectionTexture\")\r\n    private _reflectionTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Define the texture used to display the reflection.\r\n     * @see https://doc.babylonjs.com/how_to/reflect#how-to-obtain-reflections-and-refractions\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public reflectionTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsTexture(\"emissiveTexture\")\r\n    private _emissiveTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Define texture of the material as if self lit.\r\n     * This will be mixed in the final result even in the absence of light.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public emissiveTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsTexture(\"specularTexture\")\r\n    private _specularTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Define how the color and intensity of the highlight given by the light in the material.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public specularTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsTexture(\"bumpTexture\")\r\n    private _bumpTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Bump mapping is a technique to simulate bump and dents on a rendered surface.\r\n     * These are made by creating a normal map from an image. The means to do this can be found on the web, a search for 'normal map generator' will bring up free and paid for methods of doing this.\r\n     * @see https://doc.babylonjs.com/how_to/more_materials#bump-map\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public bumpTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsTexture(\"lightmapTexture\")\r\n    private _lightmapTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Complex lighting can be computationally expensive to compute at runtime.\r\n     * To save on computation, lightmaps may be used to store calculated lighting in a texture which will be applied to a given mesh.\r\n     * @see https://doc.babylonjs.com/babylon101/lights#lightmaps\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public lightmapTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsTexture(\"refractionTexture\")\r\n    private _refractionTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Define the texture used to display the refraction.\r\n     * @see https://doc.babylonjs.com/how_to/reflect#how-to-obtain-reflections-and-refractions\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public refractionTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * The color of the material lit by the environmental background lighting.\r\n     * @see https://doc.babylonjs.com/babylon101/materials#ambient-color-example\r\n     */\r\n    @serializeAsColor3(\"ambient\")\r\n    public ambientColor = new Color3(0, 0, 0);\r\n\r\n    /**\r\n     * The basic color of the material as viewed under a light.\r\n     */\r\n    @serializeAsColor3(\"diffuse\")\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * Define how the color and intensity of the highlight given by the light in the material.\r\n     */\r\n    @serializeAsColor3(\"specular\")\r\n    public specularColor = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * Define the color of the material as if self lit.\r\n     * This will be mixed in the final result even in the absence of light.\r\n     */\r\n    @serializeAsColor3(\"emissive\")\r\n    public emissiveColor = new Color3(0, 0, 0);\r\n\r\n    /**\r\n     * Defines how sharp are the highlights in the material.\r\n     * The bigger the value the sharper giving a more glossy feeling to the result.\r\n     * Reversely, the smaller the value the blurrier giving a more rough feeling to the result.\r\n     */\r\n    @serialize()\r\n    public specularPower = 64;\r\n\r\n    @serialize(\"useAlphaFromDiffuseTexture\")\r\n    private _useAlphaFromDiffuseTexture = false;\r\n    /**\r\n     * Does the transparency come from the diffuse texture alpha channel.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\r\n    public useAlphaFromDiffuseTexture: boolean;\r\n\r\n    @serialize(\"useEmissiveAsIllumination\")\r\n    private _useEmissiveAsIllumination = false;\r\n    /**\r\n     * If true, the emissive value is added into the end result, otherwise it is multiplied in.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useEmissiveAsIllumination: boolean;\r\n\r\n    @serialize(\"linkEmissiveWithDiffuse\")\r\n    private _linkEmissiveWithDiffuse = false;\r\n    /**\r\n     * If true, some kind of energy conservation will prevent the end result to be more than 1 by reducing\r\n     * the emissive level when the final color is close to one.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public linkEmissiveWithDiffuse: boolean;\r\n\r\n    @serialize(\"useSpecularOverAlpha\")\r\n    private _useSpecularOverAlpha = false;\r\n    /**\r\n     * Specifies that the material will keep the specular highlights over a transparent surface (only the most limunous ones).\r\n     * A car glass is a good exemple of that. When sun reflects on it you can not see what is behind.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useSpecularOverAlpha: boolean;\r\n\r\n    @serialize(\"useReflectionOverAlpha\")\r\n    private _useReflectionOverAlpha = false;\r\n    /**\r\n     * Specifies that the material will keeps the reflection highlights over a transparent surface (only the most limunous ones).\r\n     * A car glass is a good exemple of that. When the street lights reflects on it you can not see what is behind.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useReflectionOverAlpha: boolean;\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    /**\r\n     * Does lights from the scene impacts this material.\r\n     * It can be a nice trick for performance to disable lighting on a fully emissive material.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"useObjectSpaceNormalMap\")\r\n    private _useObjectSpaceNormalMap = false;\r\n    /**\r\n     * Allows using an object space normal map (instead of tangent space).\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useObjectSpaceNormalMap: boolean;\r\n\r\n    @serialize(\"useParallax\")\r\n    private _useParallax = false;\r\n    /**\r\n     * Is parallax enabled or not.\r\n     * @see https://doc.babylonjs.com/how_to/using_parallax_mapping\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useParallax: boolean;\r\n\r\n    @serialize(\"useParallaxOcclusion\")\r\n    private _useParallaxOcclusion = false;\r\n    /**\r\n     * Is parallax occlusion enabled or not.\r\n     * If true, the outcome is way more realistic than traditional Parallax but you can expect a performance hit that worthes consideration.\r\n     * @see https://doc.babylonjs.com/how_to/using_parallax_mapping\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useParallaxOcclusion: boolean;\r\n\r\n    /**\r\n     * Apply a scaling factor that determine which \"depth\" the height map should reprensent. A value between 0.05 and 0.1 is reasonnable in Parallax, you can reach 0.2 using Parallax Occlusion.\r\n     */\r\n    @serialize()\r\n    public parallaxScaleBias = 0.05;\r\n\r\n    @serialize(\"roughness\")\r\n    private _roughness = 0;\r\n    /**\r\n     * Helps to define how blurry the reflections should appears in the material.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public roughness: number;\r\n\r\n    /**\r\n     * In case of refraction, define the value of the index of refraction.\r\n     * @see https://doc.babylonjs.com/how_to/reflect#how-to-obtain-reflections-and-refractions\r\n     */\r\n    @serialize()\r\n    public indexOfRefraction = 0.98;\r\n\r\n    /**\r\n     * Invert the refraction texture alongside the y axis.\r\n     * It can be useful with procedural textures or probe for instance.\r\n     * @see https://doc.babylonjs.com/how_to/reflect#how-to-obtain-reflections-and-refractions\r\n     */\r\n    @serialize()\r\n    public invertRefractionY = true;\r\n\r\n    /**\r\n     * Defines the alpha limits in alpha test mode.\r\n     */\r\n    @serialize()\r\n    public alphaCutOff = 0.4;\r\n\r\n    @serialize(\"useLightmapAsShadowmap\")\r\n    private _useLightmapAsShadowmap = false;\r\n    /**\r\n     * In case of light mapping, define whether the map contains light or shadow informations.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useLightmapAsShadowmap: boolean;\r\n\r\n    // Fresnel\r\n    @serializeAsFresnelParameters(\"diffuseFresnelParameters\")\r\n    private _diffuseFresnelParameters: FresnelParameters;\r\n    /**\r\n     * Define the diffuse fresnel parameters of the material.\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_fresnelparameters\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\r\n    public diffuseFresnelParameters: FresnelParameters;\r\n\r\n    @serializeAsFresnelParameters(\"opacityFresnelParameters\")\r\n    private _opacityFresnelParameters: FresnelParameters;\r\n    /**\r\n     * Define the opacity fresnel parameters of the material.\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_fresnelparameters\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsFresnelAndMiscDirty\")\r\n    public opacityFresnelParameters: FresnelParameters;\r\n\r\n    @serializeAsFresnelParameters(\"reflectionFresnelParameters\")\r\n    private _reflectionFresnelParameters: FresnelParameters;\r\n    /**\r\n     * Define the reflection fresnel parameters of the material.\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_fresnelparameters\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\r\n    public reflectionFresnelParameters: FresnelParameters;\r\n\r\n    @serializeAsFresnelParameters(\"refractionFresnelParameters\")\r\n    private _refractionFresnelParameters: FresnelParameters;\r\n    /**\r\n     * Define the refraction fresnel parameters of the material.\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_fresnelparameters\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\r\n    public refractionFresnelParameters: FresnelParameters;\r\n\r\n    @serializeAsFresnelParameters(\"emissiveFresnelParameters\")\r\n    private _emissiveFresnelParameters: FresnelParameters;\r\n    /**\r\n     * Define the emissive fresnel parameters of the material.\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_fresnelparameters\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\r\n    public emissiveFresnelParameters: FresnelParameters;\r\n\r\n    @serialize(\"useReflectionFresnelFromSpecular\")\r\n    private _useReflectionFresnelFromSpecular = false;\r\n    /**\r\n     * If true automatically deducts the fresnels values from the material specularity.\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_fresnelparameters\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\r\n    public useReflectionFresnelFromSpecular: boolean;\r\n\r\n    @serialize(\"useGlossinessFromSpecularMapAlpha\")\r\n    private _useGlossinessFromSpecularMapAlpha = false;\r\n    /**\r\n     * Defines if the glossiness/roughness of the material should be read from the specular map alpha channel\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useGlossinessFromSpecularMapAlpha: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    /**\r\n     * Defines the maximum number of lights that can be used in the material\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    @serialize(\"invertNormalMapX\")\r\n    private _invertNormalMapX = false;\r\n    /**\r\n     * If sets to true, x component of normal map value will invert (x = 1.0 - x).\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public invertNormalMapX: boolean;\r\n\r\n    @serialize(\"invertNormalMapY\")\r\n    private _invertNormalMapY = false;\r\n    /**\r\n     * If sets to true, y component of normal map value will invert (y = 1.0 - y).\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public invertNormalMapY: boolean;\r\n\r\n    @serialize(\"twoSidedLighting\")\r\n    private _twoSidedLighting = false;\r\n    /**\r\n     * If sets to true and backfaceCulling is false, normals will be flipped on the backside.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public twoSidedLighting: boolean;\r\n\r\n    /**\r\n     * Default configuration related to image processing available in the standard Material.\r\n     */\r\n    protected _imageProcessingConfiguration: ImageProcessingConfiguration;\r\n\r\n    /**\r\n     * Gets the image processing configuration used either in this material.\r\n     */\r\n    public get imageProcessingConfiguration(): ImageProcessingConfiguration {\r\n        return this._imageProcessingConfiguration;\r\n    }\r\n\r\n    /**\r\n     * Sets the Default image processing configuration used either in the this material.\r\n     *\r\n     * If sets to null, the scene one is in use.\r\n     */\r\n    public set imageProcessingConfiguration(value: ImageProcessingConfiguration) {\r\n        this._attachImageProcessingConfiguration(value);\r\n\r\n        // Ensure the effect will be rebuilt.\r\n        this._markAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /**\r\n     * Keep track of the image processing observer to allow dispose and replace.\r\n     */\r\n    private _imageProcessingObserver: Nullable<Observer<ImageProcessingConfiguration>>;\r\n\r\n    /**\r\n     * Attaches a new image processing configuration to the Standard Material.\r\n     * @param configuration\r\n     */\r\n    protected _attachImageProcessingConfiguration(configuration: Nullable<ImageProcessingConfiguration>): void {\r\n        if (configuration === this._imageProcessingConfiguration) {\r\n            return;\r\n        }\r\n\r\n        // Detaches observer\r\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n        }\r\n\r\n        // Pick the scene configuration if needed\r\n        if (!configuration) {\r\n            this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\r\n        }\r\n        else {\r\n            this._imageProcessingConfiguration = configuration;\r\n        }\r\n\r\n        // Attaches observer\r\n        if (this._imageProcessingConfiguration) {\r\n            this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {\r\n                this._markAllSubMeshesAsImageProcessingDirty();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets wether the color curves effect is enabled.\r\n     */\r\n    public get cameraColorCurvesEnabled(): boolean {\r\n        return this.imageProcessingConfiguration.colorCurvesEnabled;\r\n    }\r\n    /**\r\n     * Sets wether the color curves effect is enabled.\r\n     */\r\n    public set cameraColorCurvesEnabled(value: boolean) {\r\n        this.imageProcessingConfiguration.colorCurvesEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets wether the color grading effect is enabled.\r\n     */\r\n    public get cameraColorGradingEnabled(): boolean {\r\n        return this.imageProcessingConfiguration.colorGradingEnabled;\r\n    }\r\n    /**\r\n     * Gets wether the color grading effect is enabled.\r\n     */\r\n    public set cameraColorGradingEnabled(value: boolean) {\r\n        this.imageProcessingConfiguration.colorGradingEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets wether tonemapping is enabled or not.\r\n     */\r\n    public get cameraToneMappingEnabled(): boolean {\r\n        return this._imageProcessingConfiguration.toneMappingEnabled;\r\n    }\r\n    /**\r\n     * Sets wether tonemapping is enabled or not\r\n     */\r\n    public set cameraToneMappingEnabled(value: boolean) {\r\n        this._imageProcessingConfiguration.toneMappingEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * The camera exposure used on this material.\r\n     * This property is here and not in the camera to allow controlling exposure without full screen post process.\r\n     * This corresponds to a photographic exposure.\r\n     */\r\n    public get cameraExposure(): number {\r\n        return this._imageProcessingConfiguration.exposure;\r\n    }\r\n    /**\r\n     * The camera exposure used on this material.\r\n     * This property is here and not in the camera to allow controlling exposure without full screen post process.\r\n     * This corresponds to a photographic exposure.\r\n     */\r\n    public set cameraExposure(value: number) {\r\n        this._imageProcessingConfiguration.exposure = value;\r\n    }\r\n\r\n    /**\r\n     * Gets The camera contrast used on this material.\r\n     */\r\n    public get cameraContrast(): number {\r\n        return this._imageProcessingConfiguration.contrast;\r\n    }\r\n\r\n    /**\r\n     * Sets The camera contrast used on this material.\r\n     */\r\n    public set cameraContrast(value: number) {\r\n        this._imageProcessingConfiguration.contrast = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the Color Grading 2D Lookup Texture.\r\n     */\r\n    public get cameraColorGradingTexture(): Nullable<BaseTexture> {\r\n        return this._imageProcessingConfiguration.colorGradingTexture;\r\n    }\r\n    /**\r\n     * Sets the Color Grading 2D Lookup Texture.\r\n     */\r\n    public set cameraColorGradingTexture(value: Nullable<BaseTexture>) {\r\n        this._imageProcessingConfiguration.colorGradingTexture = value;\r\n    }\r\n\r\n    /**\r\n     * The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).\r\n     * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\r\n     * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\r\n     * corresponding to low luminance, medium luminance, and high luminance areas respectively.\r\n     */\r\n    public get cameraColorCurves(): Nullable<ColorCurves> {\r\n        return this._imageProcessingConfiguration.colorCurves;\r\n    }\r\n    /**\r\n     * The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).\r\n     * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\r\n     * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\r\n     * corresponding to low luminance, medium luminance, and high luminance areas respectively.\r\n     */\r\n    public set cameraColorCurves(value: Nullable<ColorCurves>) {\r\n        this._imageProcessingConfiguration.colorCurves = value;\r\n    }\r\n\r\n    /**\r\n     * Can this material render to several textures at once\r\n     */\r\n    public get canRenderToMRT() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Defines the detail map parameters for the material.\r\n     */\r\n    public readonly detailMap = new DetailMapConfiguration(this._markAllSubMeshesAsTexturesDirty.bind(this));\r\n\r\n    protected _renderTargets = new SmartArray<RenderTargetTexture>(16);\r\n    protected _worldViewProjectionMatrix = Matrix.Zero();\r\n    protected _globalAmbientColor = new Color3(0, 0, 0);\r\n    protected _useLogarithmicDepth: boolean;\r\n    protected _rebuildInParallel = false;\r\n\r\n    /**\r\n     * Instantiates a new standard material.\r\n     * This is the default material used in Babylon. It is the best trade off between quality\r\n     * and performances.\r\n     * @see https://doc.babylonjs.com/babylon101/materials\r\n     * @param name Define the name of the material in the scene\r\n     * @param scene Define the scene the material belong to\r\n     */\r\n    constructor(name: string, scene: Scene) {\r\n        super(name, scene);\r\n\r\n        // Setup the default processing configuration to the scene.\r\n        this._attachImageProcessingConfiguration(null);\r\n\r\n        this.getRenderTargetTextures = (): SmartArray<RenderTargetTexture> => {\r\n            this._renderTargets.reset();\r\n\r\n            if (StandardMaterial.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\r\n                this._renderTargets.push(<RenderTargetTexture>this._reflectionTexture);\r\n            }\r\n\r\n            if (StandardMaterial.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\r\n                this._renderTargets.push(<RenderTargetTexture>this._refractionTexture);\r\n            }\r\n\r\n            return this._renderTargets;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     */\r\n    public get hasRenderTargetTextures(): boolean {\r\n        if (StandardMaterial.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\r\n            return true;\r\n        }\r\n\r\n        if (StandardMaterial.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"StandardMaterial\"\r\n     * Mainly use in serialization.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"StandardMaterial\";\r\n    }\r\n\r\n    /**\r\n     * In case the depth buffer does not allow enough depth precision for your scene (might be the case in large scenes)\r\n     * You can try switching to logarithmic depth.\r\n     * @see https://doc.babylonjs.com/how_to/using_logarithmic_depth_buffer\r\n     */\r\n    @serialize()\r\n    public get useLogarithmicDepth(): boolean {\r\n        return this._useLogarithmicDepth;\r\n    }\r\n\r\n    public set useLogarithmicDepth(value: boolean) {\r\n        this._useLogarithmicDepth = value && this.getScene().getEngine().getCaps().fragmentDepthSupported;\r\n\r\n        this._markAllSubMeshesAsMiscDirty();\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material will require alpha blending\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        if (this._disableAlphaBlending) {\r\n            return false;\r\n        }\r\n\r\n        return (this.alpha < 1.0) || (this._opacityTexture != null) || this._shouldUseAlphaFromDiffuseTexture() || this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled;\r\n    }\r\n\r\n    /**\r\n     * Specifies if this material should be rendered in alpha test mode\r\n     * @returns a boolean specifying if an alpha test is needed.\r\n     */\r\n    public needAlphaTesting(): boolean {\r\n        if (this._forceAlphaTest) {\r\n            return true;\r\n        }\r\n\r\n        return this._diffuseTexture != null && this._diffuseTexture.hasAlpha && (this._transparencyMode == null || this._transparencyMode === Material.MATERIAL_ALPHATEST);\r\n    }\r\n\r\n    protected _shouldUseAlphaFromDiffuseTexture(): boolean {\r\n        return this._diffuseTexture != null && this._diffuseTexture.hasAlpha && this._useAlphaFromDiffuseTexture && this._transparencyMode !== Material.MATERIAL_OPAQUE;\r\n    }\r\n\r\n    /**\r\n     * Get the texture used for alpha test purpose.\r\n     * @returns the diffuse texture in case of the standard material.\r\n     */\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return this._diffuseTexture;\r\n    }\r\n\r\n    /**\r\n     * Get if the submesh is ready to be used and all its information available.\r\n     * Child classes can use it to update shaders\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances: boolean = false): boolean {\r\n        if (subMesh.effect && this.isFrozen) {\r\n            if (subMesh.effect._wasPreviouslyReady) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh._materialDefines) {\r\n            subMesh._materialDefines = new StandardMaterialDefines();\r\n        }\r\n\r\n        var scene = this.getScene();\r\n        var defines = <StandardMaterialDefines>subMesh._materialDefines;\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        var engine = scene.getEngine();\r\n\r\n        // Lights\r\n        defines._needNormals = MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Multiview\r\n        MaterialHelper.PrepareDefinesForMultiview(scene, defines);\r\n\r\n        // PrePass\r\n        MaterialHelper.PrepareDefinesForPrePass(scene, defines, this.canRenderToMRT);\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            defines.MAINUV1 = false;\r\n            defines.MAINUV2 = false;\r\n            if (scene.texturesEnabled) {\r\n                if (this._diffuseTexture && StandardMaterial.DiffuseTextureEnabled) {\r\n                    if (!this._diffuseTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    } else {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._diffuseTexture, defines, \"DIFFUSE\");\r\n                    }\r\n                } else {\r\n                    defines.DIFFUSE = false;\r\n                }\r\n\r\n                if (this._ambientTexture && StandardMaterial.AmbientTextureEnabled) {\r\n                    if (!this._ambientTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    } else {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._ambientTexture, defines, \"AMBIENT\");\r\n                    }\r\n                } else {\r\n                    defines.AMBIENT = false;\r\n                }\r\n\r\n                if (this._opacityTexture && StandardMaterial.OpacityTextureEnabled) {\r\n                    if (!this._opacityTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    } else {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._opacityTexture, defines, \"OPACITY\");\r\n                        defines.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;\r\n                    }\r\n                } else {\r\n                    defines.OPACITY = false;\r\n                }\r\n\r\n                if (this._reflectionTexture && StandardMaterial.ReflectionTextureEnabled) {\r\n                    if (!this._reflectionTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needNormals = true;\r\n                        defines.REFLECTION = true;\r\n\r\n                        defines.ROUGHNESS = (this._roughness > 0);\r\n                        defines.REFLECTIONOVERALPHA = this._useReflectionOverAlpha;\r\n                        defines.INVERTCUBICMAP = (this._reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE);\r\n                        defines.REFLECTIONMAP_3D = this._reflectionTexture.isCube;\r\n                        defines.RGBDREFLECTION = this._reflectionTexture.isRGBD;\r\n\r\n                        switch (this._reflectionTexture.coordinatesMode) {\r\n                            case Texture.EXPLICIT_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_EXPLICIT\");\r\n                                break;\r\n                            case Texture.PLANAR_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_PLANAR\");\r\n                                break;\r\n                            case Texture.PROJECTION_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_PROJECTION\");\r\n                                break;\r\n                            case Texture.SKYBOX_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_SKYBOX\");\r\n                                break;\r\n                            case Texture.SPHERICAL_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_SPHERICAL\");\r\n                                break;\r\n                            case Texture.EQUIRECTANGULAR_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_EQUIRECTANGULAR\");\r\n                                break;\r\n                            case Texture.FIXED_EQUIRECTANGULAR_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_EQUIRECTANGULAR_FIXED\");\r\n                                break;\r\n                            case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\");\r\n                                break;\r\n                            case Texture.CUBIC_MODE:\r\n                            case Texture.INVCUBIC_MODE:\r\n                            default:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_CUBIC\");\r\n                                break;\r\n                        }\r\n\r\n                        defines.USE_LOCAL_REFLECTIONMAP_CUBIC = (<any>this._reflectionTexture).boundingBoxSize ? true : false;\r\n                    }\r\n                } else {\r\n                    defines.REFLECTION = false;\r\n                }\r\n\r\n                if (this._emissiveTexture && StandardMaterial.EmissiveTextureEnabled) {\r\n                    if (!this._emissiveTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    } else {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._emissiveTexture, defines, \"EMISSIVE\");\r\n                    }\r\n                } else {\r\n                    defines.EMISSIVE = false;\r\n                }\r\n\r\n                if (this._lightmapTexture && StandardMaterial.LightmapTextureEnabled) {\r\n                    if (!this._lightmapTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    } else {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._lightmapTexture, defines, \"LIGHTMAP\");\r\n                        defines.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap;\r\n                        defines.RGBDLIGHTMAP = this._lightmapTexture.isRGBD;\r\n                    }\r\n                } else {\r\n                    defines.LIGHTMAP = false;\r\n                }\r\n\r\n                if (this._specularTexture && StandardMaterial.SpecularTextureEnabled) {\r\n                    if (!this._specularTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    } else {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._specularTexture, defines, \"SPECULAR\");\r\n                        defines.GLOSSINESS = this._useGlossinessFromSpecularMapAlpha;\r\n                    }\r\n                } else {\r\n                    defines.SPECULAR = false;\r\n                }\r\n\r\n                if (scene.getEngine().getCaps().standardDerivatives && this._bumpTexture && StandardMaterial.BumpTextureEnabled) {\r\n                    // Bump texure can not be not blocking.\r\n                    if (!this._bumpTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture, defines, \"BUMP\");\r\n\r\n                        defines.PARALLAX = this._useParallax;\r\n                        defines.PARALLAXOCCLUSION = this._useParallaxOcclusion;\r\n                    }\r\n\r\n                    defines.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;\r\n                } else {\r\n                    defines.BUMP = false;\r\n                }\r\n\r\n                if (this._refractionTexture && StandardMaterial.RefractionTextureEnabled) {\r\n                    if (!this._refractionTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.REFRACTION = true;\r\n\r\n                        defines.REFRACTIONMAP_3D = this._refractionTexture.isCube;\r\n                        defines.RGBDREFRACTION = this._refractionTexture.isRGBD;\r\n                    }\r\n                } else {\r\n                    defines.REFRACTION = false;\r\n                }\r\n\r\n                defines.TWOSIDEDLIGHTING = !this._backFaceCulling && this._twoSidedLighting;\r\n            } else {\r\n                defines.DIFFUSE = false;\r\n                defines.AMBIENT = false;\r\n                defines.OPACITY = false;\r\n                defines.REFLECTION = false;\r\n                defines.EMISSIVE = false;\r\n                defines.LIGHTMAP = false;\r\n                defines.BUMP = false;\r\n                defines.REFRACTION = false;\r\n            }\r\n\r\n            defines.ALPHAFROMDIFFUSE = this._shouldUseAlphaFromDiffuseTexture();\r\n\r\n            defines.EMISSIVEASILLUMINATION = this._useEmissiveAsIllumination;\r\n\r\n            defines.LINKEMISSIVEWITHDIFFUSE = this._linkEmissiveWithDiffuse;\r\n\r\n            defines.SPECULAROVERALPHA = this._useSpecularOverAlpha;\r\n\r\n            defines.PREMULTIPLYALPHA = (this.alphaMode === 7 || this.alphaMode === 8);\r\n\r\n            defines.ALPHATEST_AFTERALLALPHACOMPUTATIONS = this.transparencyMode !== null;\r\n\r\n            defines.ALPHABLEND = this.transparencyMode === null || this.needAlphaBlendingForMesh(mesh); // check on null for backward compatibility\r\n        }\r\n\r\n        if (!this.detailMap.isReadyForSubMesh(defines, scene)) {\r\n            return false;\r\n        }\r\n\r\n        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {\r\n            if (!this._imageProcessingConfiguration.isReady()) {\r\n                return false;\r\n            }\r\n\r\n            this._imageProcessingConfiguration.prepareDefines(defines);\r\n\r\n            defines.IS_REFLECTION_LINEAR = (this.reflectionTexture != null && !this.reflectionTexture.gammaSpace);\r\n            defines.IS_REFRACTION_LINEAR = (this.refractionTexture != null && !this.refractionTexture.gammaSpace);\r\n        }\r\n\r\n        if (defines._areFresnelDirty) {\r\n            if (StandardMaterial.FresnelEnabled) {\r\n                // Fresnel\r\n                if (this._diffuseFresnelParameters || this._opacityFresnelParameters ||\r\n                    this._emissiveFresnelParameters || this._refractionFresnelParameters ||\r\n                    this._reflectionFresnelParameters) {\r\n\r\n                    defines.DIFFUSEFRESNEL = (this._diffuseFresnelParameters && this._diffuseFresnelParameters.isEnabled);\r\n\r\n                    defines.OPACITYFRESNEL = (this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled);\r\n\r\n                    defines.REFLECTIONFRESNEL = (this._reflectionFresnelParameters && this._reflectionFresnelParameters.isEnabled);\r\n\r\n                    defines.REFLECTIONFRESNELFROMSPECULAR = this._useReflectionFresnelFromSpecular;\r\n\r\n                    defines.REFRACTIONFRESNEL = (this._refractionFresnelParameters && this._refractionFresnelParameters.isEnabled);\r\n\r\n                    defines.EMISSIVEFRESNEL = (this._emissiveFresnelParameters && this._emissiveFresnelParameters.isEnabled);\r\n\r\n                    defines._needNormals = true;\r\n                    defines.FRESNEL = true;\r\n                }\r\n            } else {\r\n                defines.FRESNEL = false;\r\n            }\r\n        }\r\n\r\n        // Misc.\r\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh) || this._forceAlphaTest, defines);\r\n\r\n        // Attribs\r\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true, true);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, defines, useInstances, null, subMesh.getRenderingMesh().hasThinInstances);\r\n\r\n        // External config\r\n        this.detailMap.prepareDefines(defines, scene);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            const lightDisposed = defines._areLightsDisposed;\r\n            defines.markAsProcessed();\r\n\r\n            // Fallbacks\r\n            var fallbacks = new EffectFallbacks();\r\n            if (defines.REFLECTION) {\r\n                fallbacks.addFallback(0, \"REFLECTION\");\r\n            }\r\n\r\n            if (defines.SPECULAR) {\r\n                fallbacks.addFallback(0, \"SPECULAR\");\r\n            }\r\n\r\n            if (defines.BUMP) {\r\n                fallbacks.addFallback(0, \"BUMP\");\r\n            }\r\n\r\n            if (defines.PARALLAX) {\r\n                fallbacks.addFallback(1, \"PARALLAX\");\r\n            }\r\n\r\n            if (defines.PARALLAXOCCLUSION) {\r\n                fallbacks.addFallback(0, \"PARALLAXOCCLUSION\");\r\n            }\r\n\r\n            if (defines.SPECULAROVERALPHA) {\r\n                fallbacks.addFallback(0, \"SPECULAROVERALPHA\");\r\n            }\r\n\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            if (defines.POINTSIZE) {\r\n                fallbacks.addFallback(0, \"POINTSIZE\");\r\n            }\r\n\r\n            if (defines.LOGARITHMICDEPTH) {\r\n                fallbacks.addFallback(0, \"LOGARITHMICDEPTH\");\r\n            }\r\n\r\n            MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights);\r\n\r\n            if (defines.SPECULARTERM) {\r\n                fallbacks.addFallback(0, \"SPECULARTERM\");\r\n            }\r\n\r\n            if (defines.DIFFUSEFRESNEL) {\r\n                fallbacks.addFallback(1, \"DIFFUSEFRESNEL\");\r\n            }\r\n\r\n            if (defines.OPACITYFRESNEL) {\r\n                fallbacks.addFallback(2, \"OPACITYFRESNEL\");\r\n            }\r\n\r\n            if (defines.REFLECTIONFRESNEL) {\r\n                fallbacks.addFallback(3, \"REFLECTIONFRESNEL\");\r\n            }\r\n\r\n            if (defines.EMISSIVEFRESNEL) {\r\n                fallbacks.addFallback(4, \"EMISSIVEFRESNEL\");\r\n            }\r\n\r\n            if (defines.FRESNEL) {\r\n                fallbacks.addFallback(4, \"FRESNEL\");\r\n            }\r\n\r\n            if (defines.MULTIVIEW) {\r\n                fallbacks.addFallback(0, \"MULTIVIEW\");\r\n            }\r\n\r\n            //Attributes\r\n            var attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\r\n            MaterialHelper.PrepareAttributesForMorphTargets(attribs, mesh, defines);\r\n\r\n            var shaderName = \"default\";\r\n\r\n            var uniforms = [\"world\", \"view\", \"viewProjection\", \"vEyePosition\", \"vLightsType\", \"vAmbientColor\", \"vDiffuseColor\", \"vSpecularColor\", \"vEmissiveColor\", \"visibility\",\r\n                \"vFogInfos\", \"vFogColor\", \"pointSize\",\r\n                \"vDiffuseInfos\", \"vAmbientInfos\", \"vOpacityInfos\", \"vReflectionInfos\", \"vEmissiveInfos\", \"vSpecularInfos\", \"vBumpInfos\", \"vLightmapInfos\", \"vRefractionInfos\",\r\n                \"mBones\",\r\n                \"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\", \"diffuseMatrix\", \"ambientMatrix\", \"opacityMatrix\", \"reflectionMatrix\", \"emissiveMatrix\", \"specularMatrix\", \"bumpMatrix\", \"normalMatrix\", \"lightmapMatrix\", \"refractionMatrix\",\r\n                \"diffuseLeftColor\", \"diffuseRightColor\", \"opacityParts\", \"reflectionLeftColor\", \"reflectionRightColor\", \"emissiveLeftColor\", \"emissiveRightColor\", \"refractionLeftColor\", \"refractionRightColor\",\r\n                \"vReflectionPosition\", \"vReflectionSize\",\r\n                \"logarithmicDepthConstant\", \"vTangentSpaceParams\", \"alphaCutOff\", \"boneTextureWidth\"\r\n            ];\r\n\r\n            var samplers = [\"diffuseSampler\", \"ambientSampler\", \"opacitySampler\", \"reflectionCubeSampler\",\r\n                \"reflection2DSampler\", \"emissiveSampler\", \"specularSampler\", \"bumpSampler\", \"lightmapSampler\",\r\n                \"refractionCubeSampler\", \"refraction2DSampler\", \"boneSampler\"];\r\n\r\n            var uniformBuffers = [\"Material\", \"Scene\"];\r\n\r\n            DetailMapConfiguration.AddUniforms(uniforms);\r\n            DetailMapConfiguration.AddSamplers(samplers);\r\n\r\n            if (ImageProcessingConfiguration) {\r\n                ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);\r\n                ImageProcessingConfiguration.PrepareSamplers(samplers, defines);\r\n            }\r\n\r\n            MaterialHelper.PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this._maxSimultaneousLights\r\n            });\r\n\r\n            const csnrOptions: ICustomShaderNameResolveOptions = {};\r\n\r\n            if (this.customShaderNameResolve) {\r\n                shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs, csnrOptions);\r\n            }\r\n\r\n            var join = defines.toString();\r\n\r\n            let previousEffect = subMesh.effect;\r\n            let effect = scene.getEngine().createEffect(shaderName, <IEffectCreationOptions>{\r\n                attributes: attribs,\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: join,\r\n                fallbacks: fallbacks,\r\n                onCompiled: this.onCompiled,\r\n                onError: this.onError,\r\n                indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS },\r\n                processFinalCode: csnrOptions.processFinalCode,\r\n                multiTarget: defines.PREPASS\r\n            }, engine);\r\n\r\n            if (effect) {\r\n                if (this._onEffectCreatedObservable) {\r\n                    onCreatedEffectParameters.effect = effect;\r\n                    onCreatedEffectParameters.subMesh = subMesh;\r\n                    this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\r\n                }\r\n\r\n                // Use previous effect while new one is compiling\r\n                if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {\r\n                    effect = previousEffect;\r\n                    this._rebuildInParallel = true;\r\n                    defines.markAsUnprocessed();\r\n\r\n                    if (lightDisposed) {\r\n                        // re register in case it takes more than one frame.\r\n                        defines._areLightsDisposed = true;\r\n                        return false;\r\n                    }\r\n                } else {\r\n                    this._rebuildInParallel = false;\r\n                    scene.resetCachedMaterial();\r\n                    subMesh.setEffect(effect, defines);\r\n                    this.buildUniformLayout();\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Builds the material UBO layouts.\r\n     * Used internally during the effect preparation.\r\n     */\r\n    public buildUniformLayout(): void {\r\n        // Order is important !\r\n        let ubo = this._uniformBuffer;\r\n        ubo.addUniform(\"diffuseLeftColor\", 4);\r\n        ubo.addUniform(\"diffuseRightColor\", 4);\r\n        ubo.addUniform(\"opacityParts\", 4);\r\n        ubo.addUniform(\"reflectionLeftColor\", 4);\r\n        ubo.addUniform(\"reflectionRightColor\", 4);\r\n        ubo.addUniform(\"refractionLeftColor\", 4);\r\n        ubo.addUniform(\"refractionRightColor\", 4);\r\n        ubo.addUniform(\"emissiveLeftColor\", 4);\r\n        ubo.addUniform(\"emissiveRightColor\", 4);\r\n\r\n        ubo.addUniform(\"vDiffuseInfos\", 2);\r\n        ubo.addUniform(\"vAmbientInfos\", 2);\r\n        ubo.addUniform(\"vOpacityInfos\", 2);\r\n        ubo.addUniform(\"vReflectionInfos\", 2);\r\n        ubo.addUniform(\"vReflectionPosition\", 3);\r\n        ubo.addUniform(\"vReflectionSize\", 3);\r\n        ubo.addUniform(\"vEmissiveInfos\", 2);\r\n        ubo.addUniform(\"vLightmapInfos\", 2);\r\n        ubo.addUniform(\"vSpecularInfos\", 2);\r\n        ubo.addUniform(\"vBumpInfos\", 3);\r\n\r\n        ubo.addUniform(\"diffuseMatrix\", 16);\r\n        ubo.addUniform(\"ambientMatrix\", 16);\r\n        ubo.addUniform(\"opacityMatrix\", 16);\r\n        ubo.addUniform(\"reflectionMatrix\", 16);\r\n        ubo.addUniform(\"emissiveMatrix\", 16);\r\n        ubo.addUniform(\"lightmapMatrix\", 16);\r\n        ubo.addUniform(\"specularMatrix\", 16);\r\n        ubo.addUniform(\"bumpMatrix\", 16);\r\n        ubo.addUniform(\"vTangentSpaceParams\", 2);\r\n        ubo.addUniform(\"pointSize\", 1);\r\n        ubo.addUniform(\"refractionMatrix\", 16);\r\n        ubo.addUniform(\"vRefractionInfos\", 4);\r\n        ubo.addUniform(\"vSpecularColor\", 4);\r\n        ubo.addUniform(\"vEmissiveColor\", 3);\r\n        ubo.addUniform(\"visibility\", 1);\r\n        ubo.addUniform(\"vDiffuseColor\", 4);\r\n\r\n        DetailMapConfiguration.PrepareUniformBuffer(ubo);\r\n\r\n        ubo.create();\r\n    }\r\n\r\n    /**\r\n     * Unbinds the material from the mesh\r\n     */\r\n    public unbind(): void {\r\n        if (this._activeEffect) {\r\n            let needFlag = false;\r\n            if (this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\r\n                this._activeEffect.setTexture(\"reflection2DSampler\", null);\r\n                needFlag = true;\r\n            }\r\n\r\n            if (this._refractionTexture && this._refractionTexture.isRenderTarget) {\r\n                this._activeEffect.setTexture(\"refraction2DSampler\", null);\r\n                needFlag = true;\r\n            }\r\n\r\n            if (needFlag) {\r\n                this._markAllSubMeshesAsTexturesDirty();\r\n            }\r\n        }\r\n\r\n        super.unbind();\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to this material by preparing the effect and shader to draw\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        var scene = this.getScene();\r\n\r\n        var defines = <StandardMaterialDefines>subMesh._materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        var effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        if (!defines.INSTANCES || defines.THIN_INSTANCES) {\r\n            this.bindOnlyWorldMatrix(world);\r\n        }\r\n\r\n        // Normal Matrix\r\n        if (defines.OBJECTSPACE_NORMALMAP) {\r\n            world.toNormalMatrix(this._normalMatrix);\r\n            this.bindOnlyNormalMatrix(this._normalMatrix);\r\n        }\r\n\r\n        let mustRebind = this._mustRebind(scene, effect, mesh.visibility);\r\n\r\n        // Bones\r\n        MaterialHelper.BindBonesParameters(mesh, effect);\r\n        let ubo = this._uniformBuffer;\r\n        if (mustRebind) {\r\n            ubo.bindToEffect(effect, \"Material\");\r\n\r\n            this.bindViewProjection(effect);\r\n            if (!ubo.useUbo || !this.isFrozen || !ubo.isSync) {\r\n\r\n                if (StandardMaterial.FresnelEnabled && defines.FRESNEL) {\r\n                    // Fresnel\r\n                    if (this.diffuseFresnelParameters && this.diffuseFresnelParameters.isEnabled) {\r\n                        ubo.updateColor4(\"diffuseLeftColor\", this.diffuseFresnelParameters.leftColor, this.diffuseFresnelParameters.power);\r\n                        ubo.updateColor4(\"diffuseRightColor\", this.diffuseFresnelParameters.rightColor, this.diffuseFresnelParameters.bias);\r\n                    }\r\n\r\n                    if (this.opacityFresnelParameters && this.opacityFresnelParameters.isEnabled) {\r\n                        ubo.updateColor4(\"opacityParts\", new Color3(this.opacityFresnelParameters.leftColor.toLuminance(), this.opacityFresnelParameters.rightColor.toLuminance(), this.opacityFresnelParameters.bias), this.opacityFresnelParameters.power);\r\n                    }\r\n\r\n                    if (this.reflectionFresnelParameters && this.reflectionFresnelParameters.isEnabled) {\r\n                        ubo.updateColor4(\"reflectionLeftColor\", this.reflectionFresnelParameters.leftColor, this.reflectionFresnelParameters.power);\r\n                        ubo.updateColor4(\"reflectionRightColor\", this.reflectionFresnelParameters.rightColor, this.reflectionFresnelParameters.bias);\r\n                    }\r\n\r\n                    if (this.refractionFresnelParameters && this.refractionFresnelParameters.isEnabled) {\r\n                        ubo.updateColor4(\"refractionLeftColor\", this.refractionFresnelParameters.leftColor, this.refractionFresnelParameters.power);\r\n                        ubo.updateColor4(\"refractionRightColor\", this.refractionFresnelParameters.rightColor, this.refractionFresnelParameters.bias);\r\n                    }\r\n\r\n                    if (this.emissiveFresnelParameters && this.emissiveFresnelParameters.isEnabled) {\r\n                        ubo.updateColor4(\"emissiveLeftColor\", this.emissiveFresnelParameters.leftColor, this.emissiveFresnelParameters.power);\r\n                        ubo.updateColor4(\"emissiveRightColor\", this.emissiveFresnelParameters.rightColor, this.emissiveFresnelParameters.bias);\r\n                    }\r\n                }\r\n\r\n                // Textures\r\n                if (scene.texturesEnabled) {\r\n                    if (this._diffuseTexture && StandardMaterial.DiffuseTextureEnabled) {\r\n                        ubo.updateFloat2(\"vDiffuseInfos\", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);\r\n                        MaterialHelper.BindTextureMatrix(this._diffuseTexture, ubo, \"diffuse\");\r\n\r\n                        if (this._diffuseTexture.hasAlpha) {\r\n                            effect.setFloat(\"alphaCutOff\", this.alphaCutOff);\r\n                        }\r\n                    }\r\n\r\n                    if (this._ambientTexture && StandardMaterial.AmbientTextureEnabled) {\r\n                        ubo.updateFloat2(\"vAmbientInfos\", this._ambientTexture.coordinatesIndex, this._ambientTexture.level);\r\n                        MaterialHelper.BindTextureMatrix(this._ambientTexture, ubo, \"ambient\");\r\n                    }\r\n\r\n                    if (this._opacityTexture && StandardMaterial.OpacityTextureEnabled) {\r\n                        ubo.updateFloat2(\"vOpacityInfos\", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);\r\n                        MaterialHelper.BindTextureMatrix(this._opacityTexture, ubo, \"opacity\");\r\n                    }\r\n\r\n                    if (this._reflectionTexture && StandardMaterial.ReflectionTextureEnabled) {\r\n                        ubo.updateFloat2(\"vReflectionInfos\", this._reflectionTexture.level, this.roughness);\r\n                        ubo.updateMatrix(\"reflectionMatrix\", this._reflectionTexture.getReflectionTextureMatrix());\r\n\r\n                        if ((<any>this._reflectionTexture).boundingBoxSize) {\r\n                            let cubeTexture = <CubeTexture>this._reflectionTexture;\r\n\r\n                            ubo.updateVector3(\"vReflectionPosition\", cubeTexture.boundingBoxPosition);\r\n                            ubo.updateVector3(\"vReflectionSize\", cubeTexture.boundingBoxSize);\r\n                        }\r\n                    }\r\n\r\n                    if (this._emissiveTexture && StandardMaterial.EmissiveTextureEnabled) {\r\n                        ubo.updateFloat2(\"vEmissiveInfos\", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level);\r\n                        MaterialHelper.BindTextureMatrix(this._emissiveTexture, ubo, \"emissive\");\r\n                    }\r\n\r\n                    if (this._lightmapTexture && StandardMaterial.LightmapTextureEnabled) {\r\n                        ubo.updateFloat2(\"vLightmapInfos\", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level);\r\n                        MaterialHelper.BindTextureMatrix(this._lightmapTexture, ubo, \"lightmap\");\r\n                    }\r\n\r\n                    if (this._specularTexture && StandardMaterial.SpecularTextureEnabled) {\r\n                        ubo.updateFloat2(\"vSpecularInfos\", this._specularTexture.coordinatesIndex, this._specularTexture.level);\r\n                        MaterialHelper.BindTextureMatrix(this._specularTexture, ubo, \"specular\");\r\n                    }\r\n\r\n                    if (this._bumpTexture && scene.getEngine().getCaps().standardDerivatives && StandardMaterial.BumpTextureEnabled) {\r\n                        ubo.updateFloat3(\"vBumpInfos\", this._bumpTexture.coordinatesIndex, 1.0 / this._bumpTexture.level, this.parallaxScaleBias);\r\n                        MaterialHelper.BindTextureMatrix(this._bumpTexture, ubo, \"bump\");\r\n\r\n                        if (scene._mirroredCameraPosition) {\r\n                            ubo.updateFloat2(\"vTangentSpaceParams\", this._invertNormalMapX ? 1.0 : -1.0, this._invertNormalMapY ? 1.0 : -1.0);\r\n                        } else {\r\n                            ubo.updateFloat2(\"vTangentSpaceParams\", this._invertNormalMapX ? -1.0 : 1.0, this._invertNormalMapY ? -1.0 : 1.0);\r\n                        }\r\n                    }\r\n\r\n                    if (this._refractionTexture && StandardMaterial.RefractionTextureEnabled) {\r\n                        var depth = 1.0;\r\n                        if (!this._refractionTexture.isCube) {\r\n                            ubo.updateMatrix(\"refractionMatrix\", this._refractionTexture.getReflectionTextureMatrix());\r\n\r\n                            if ((<any>this._refractionTexture).depth) {\r\n                                depth = (<any>this._refractionTexture).depth;\r\n                            }\r\n                        }\r\n                        ubo.updateFloat4(\"vRefractionInfos\", this._refractionTexture.level, this.indexOfRefraction, depth, this.invertRefractionY ? -1 : 1);\r\n                    }\r\n                }\r\n\r\n                // Point size\r\n                if (this.pointsCloud) {\r\n                    ubo.updateFloat(\"pointSize\", this.pointSize);\r\n                }\r\n\r\n                if (defines.SPECULARTERM) {\r\n                    ubo.updateColor4(\"vSpecularColor\", this.specularColor, this.specularPower);\r\n                }\r\n                ubo.updateColor3(\"vEmissiveColor\", StandardMaterial.EmissiveTextureEnabled ? this.emissiveColor : Color3.BlackReadOnly);\r\n\r\n                // Diffuse\r\n                ubo.updateColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha);\r\n            }\r\n\r\n            // Visibility\r\n            ubo.updateFloat(\"visibility\", mesh.visibility);\r\n\r\n            // Textures\r\n            if (scene.texturesEnabled) {\r\n                if (this._diffuseTexture && StandardMaterial.DiffuseTextureEnabled) {\r\n                    effect.setTexture(\"diffuseSampler\", this._diffuseTexture);\r\n                }\r\n\r\n                if (this._ambientTexture && StandardMaterial.AmbientTextureEnabled) {\r\n                    effect.setTexture(\"ambientSampler\", this._ambientTexture);\r\n                }\r\n\r\n                if (this._opacityTexture && StandardMaterial.OpacityTextureEnabled) {\r\n                    effect.setTexture(\"opacitySampler\", this._opacityTexture);\r\n                }\r\n\r\n                if (this._reflectionTexture && StandardMaterial.ReflectionTextureEnabled) {\r\n                    if (this._reflectionTexture.isCube) {\r\n                        effect.setTexture(\"reflectionCubeSampler\", this._reflectionTexture);\r\n                    } else {\r\n                        effect.setTexture(\"reflection2DSampler\", this._reflectionTexture);\r\n                    }\r\n                }\r\n\r\n                if (this._emissiveTexture && StandardMaterial.EmissiveTextureEnabled) {\r\n                    effect.setTexture(\"emissiveSampler\", this._emissiveTexture);\r\n                }\r\n\r\n                if (this._lightmapTexture && StandardMaterial.LightmapTextureEnabled) {\r\n                    effect.setTexture(\"lightmapSampler\", this._lightmapTexture);\r\n                }\r\n\r\n                if (this._specularTexture && StandardMaterial.SpecularTextureEnabled) {\r\n                    effect.setTexture(\"specularSampler\", this._specularTexture);\r\n                }\r\n\r\n                if (this._bumpTexture && scene.getEngine().getCaps().standardDerivatives && StandardMaterial.BumpTextureEnabled) {\r\n                    effect.setTexture(\"bumpSampler\", this._bumpTexture);\r\n                }\r\n\r\n                if (this._refractionTexture && StandardMaterial.RefractionTextureEnabled) {\r\n                    var depth = 1.0;\r\n                    if (this._refractionTexture.isCube) {\r\n                        effect.setTexture(\"refractionCubeSampler\", this._refractionTexture);\r\n                    } else {\r\n                        effect.setTexture(\"refraction2DSampler\", this._refractionTexture);\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.detailMap.bindForSubMesh(ubo, scene, this.isFrozen);\r\n\r\n            // Clip plane\r\n            MaterialHelper.BindClipPlane(effect, scene);\r\n\r\n            // Colors\r\n            scene.ambientColor.multiplyToRef(this.ambientColor, this._globalAmbientColor);\r\n\r\n            MaterialHelper.BindEyePosition(effect, scene);\r\n            effect.setColor3(\"vAmbientColor\", this._globalAmbientColor);\r\n        }\r\n\r\n        if (mustRebind || !this.isFrozen) {\r\n            // Lights\r\n            if (scene.lightsEnabled && !this._disableLighting) {\r\n                MaterialHelper.BindLights(scene, mesh, effect, defines, this._maxSimultaneousLights, this._rebuildInParallel);\r\n            }\r\n\r\n            // View\r\n            if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE || this._reflectionTexture || this._refractionTexture) {\r\n                this.bindView(effect);\r\n            }\r\n\r\n            // Fog\r\n            MaterialHelper.BindFogParameters(scene, mesh, effect);\r\n\r\n            // Morph targets\r\n            if (defines.NUM_MORPH_INFLUENCERS) {\r\n                MaterialHelper.BindMorphTargetParameters(mesh, effect);\r\n            }\r\n\r\n            // Log. depth\r\n            if (this.useLogarithmicDepth) {\r\n                MaterialHelper.BindLogDepth(defines, effect, scene);\r\n            }\r\n\r\n            // image processing\r\n            if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\r\n                this._imageProcessingConfiguration.bind(this._activeEffect);\r\n            }\r\n        }\r\n\r\n        ubo.update();\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    /**\r\n     * Get the list of animatables in the material.\r\n     * @returns the list of animatables object used in the material\r\n     */\r\n    public getAnimatables(): IAnimatable[] {\r\n        var results = [];\r\n\r\n        if (this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0) {\r\n            results.push(this._diffuseTexture);\r\n        }\r\n\r\n        if (this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0) {\r\n            results.push(this._ambientTexture);\r\n        }\r\n\r\n        if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {\r\n            results.push(this._opacityTexture);\r\n        }\r\n\r\n        if (this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0) {\r\n            results.push(this._reflectionTexture);\r\n        }\r\n\r\n        if (this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0) {\r\n            results.push(this._emissiveTexture);\r\n        }\r\n\r\n        if (this._specularTexture && this._specularTexture.animations && this._specularTexture.animations.length > 0) {\r\n            results.push(this._specularTexture);\r\n        }\r\n\r\n        if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {\r\n            results.push(this._bumpTexture);\r\n        }\r\n\r\n        if (this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0) {\r\n            results.push(this._lightmapTexture);\r\n        }\r\n\r\n        if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {\r\n            results.push(this._refractionTexture);\r\n        }\r\n\r\n        this.detailMap.getAnimatables(results);\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Gets the active textures from the material\r\n     * @returns an array of textures\r\n     */\r\n    public getActiveTextures(): BaseTexture[] {\r\n        var activeTextures = super.getActiveTextures();\r\n\r\n        if (this._diffuseTexture) {\r\n            activeTextures.push(this._diffuseTexture);\r\n        }\r\n\r\n        if (this._ambientTexture) {\r\n            activeTextures.push(this._ambientTexture);\r\n        }\r\n\r\n        if (this._opacityTexture) {\r\n            activeTextures.push(this._opacityTexture);\r\n        }\r\n\r\n        if (this._reflectionTexture) {\r\n            activeTextures.push(this._reflectionTexture);\r\n        }\r\n\r\n        if (this._emissiveTexture) {\r\n            activeTextures.push(this._emissiveTexture);\r\n        }\r\n\r\n        if (this._specularTexture) {\r\n            activeTextures.push(this._specularTexture);\r\n        }\r\n\r\n        if (this._bumpTexture) {\r\n            activeTextures.push(this._bumpTexture);\r\n        }\r\n\r\n        if (this._lightmapTexture) {\r\n            activeTextures.push(this._lightmapTexture);\r\n        }\r\n\r\n        if (this._refractionTexture) {\r\n            activeTextures.push(this._refractionTexture);\r\n        }\r\n\r\n        this.detailMap.getActiveTextures(activeTextures);\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material uses a texture\r\n     * @param texture defines the texture to check against the material\r\n     * @returns a boolean specifying if the material uses the texture\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._ambientTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._opacityTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._reflectionTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._emissiveTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._specularTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._bumpTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._lightmapTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._refractionTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return this.detailMap.hasTexture(texture);\r\n    }\r\n\r\n    /**\r\n     * Disposes the material\r\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            this._diffuseTexture?.dispose();\r\n            this._ambientTexture?.dispose();\r\n            this._opacityTexture?.dispose();\r\n            this._reflectionTexture?.dispose();\r\n            this._emissiveTexture?.dispose();\r\n            this._specularTexture?.dispose();\r\n            this._bumpTexture?.dispose();\r\n            this._lightmapTexture?.dispose();\r\n            this._refractionTexture?.dispose();\r\n        }\r\n\r\n        this.detailMap.dispose(forceDisposeTextures);\r\n\r\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect, forceDisposeTextures);\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the material, and gives it a new name\r\n     * @param name defines the new name for the duplicated material\r\n     * @returns the cloned material\r\n     */\r\n    public clone(name: string): StandardMaterial {\r\n        var result = SerializationHelper.Clone(() => new StandardMaterial(name, this.getScene()), this);\r\n\r\n        result.name = name;\r\n        result.id = name;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Serializes this material in a JSON representation\r\n     * @returns the serialized material object\r\n     */\r\n    public serialize(): any {\r\n        return SerializationHelper.Serialize(this);\r\n    }\r\n\r\n    /**\r\n     * Creates a standard material from parsed material data\r\n     * @param source defines the JSON representation of the material\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a new standard material\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): StandardMaterial {\r\n        return SerializationHelper.Parse(() => new StandardMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n\r\n    // Flags used to enable or disable a type of texture for all Standard Materials\r\n    /**\r\n     * Are diffuse textures enabled in the application.\r\n     */\r\n    public static get DiffuseTextureEnabled(): boolean {\r\n        return MaterialFlags.DiffuseTextureEnabled;\r\n    }\r\n    public static set DiffuseTextureEnabled(value: boolean) {\r\n        MaterialFlags.DiffuseTextureEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Are detail textures enabled in the application.\r\n     */\r\n    public static get DetailTextureEnabled(): boolean {\r\n        return MaterialFlags.DetailTextureEnabled;\r\n    }\r\n    public static set DetailTextureEnabled(value: boolean) {\r\n        MaterialFlags.DetailTextureEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Are ambient textures enabled in the application.\r\n     */\r\n    public static get AmbientTextureEnabled(): boolean {\r\n        return MaterialFlags.AmbientTextureEnabled;\r\n    }\r\n    public static set AmbientTextureEnabled(value: boolean) {\r\n        MaterialFlags.AmbientTextureEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Are opacity textures enabled in the application.\r\n     */\r\n    public static get OpacityTextureEnabled(): boolean {\r\n        return MaterialFlags.OpacityTextureEnabled;\r\n    }\r\n    public static set OpacityTextureEnabled(value: boolean) {\r\n        MaterialFlags.OpacityTextureEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Are reflection textures enabled in the application.\r\n     */\r\n    public static get ReflectionTextureEnabled(): boolean {\r\n        return MaterialFlags.ReflectionTextureEnabled;\r\n    }\r\n    public static set ReflectionTextureEnabled(value: boolean) {\r\n        MaterialFlags.ReflectionTextureEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Are emissive textures enabled in the application.\r\n     */\r\n    public static get EmissiveTextureEnabled(): boolean {\r\n        return MaterialFlags.EmissiveTextureEnabled;\r\n    }\r\n    public static set EmissiveTextureEnabled(value: boolean) {\r\n        MaterialFlags.EmissiveTextureEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Are specular textures enabled in the application.\r\n     */\r\n    public static get SpecularTextureEnabled(): boolean {\r\n        return MaterialFlags.SpecularTextureEnabled;\r\n    }\r\n    public static set SpecularTextureEnabled(value: boolean) {\r\n        MaterialFlags.SpecularTextureEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Are bump textures enabled in the application.\r\n     */\r\n    public static get BumpTextureEnabled(): boolean {\r\n        return MaterialFlags.BumpTextureEnabled;\r\n    }\r\n    public static set BumpTextureEnabled(value: boolean) {\r\n        MaterialFlags.BumpTextureEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Are lightmap textures enabled in the application.\r\n     */\r\n    public static get LightmapTextureEnabled(): boolean {\r\n        return MaterialFlags.LightmapTextureEnabled;\r\n    }\r\n    public static set LightmapTextureEnabled(value: boolean) {\r\n        MaterialFlags.LightmapTextureEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Are refraction textures enabled in the application.\r\n     */\r\n    public static get RefractionTextureEnabled(): boolean {\r\n        return MaterialFlags.RefractionTextureEnabled;\r\n    }\r\n    public static set RefractionTextureEnabled(value: boolean) {\r\n        MaterialFlags.RefractionTextureEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Are color grading textures enabled in the application.\r\n     */\r\n    public static get ColorGradingTextureEnabled(): boolean {\r\n        return MaterialFlags.ColorGradingTextureEnabled;\r\n    }\r\n    public static set ColorGradingTextureEnabled(value: boolean) {\r\n        MaterialFlags.ColorGradingTextureEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Are fresnels enabled in the application.\r\n     */\r\n    public static get FresnelEnabled(): boolean {\r\n        return MaterialFlags.FresnelEnabled;\r\n    }\r\n    public static set FresnelEnabled(value: boolean) {\r\n        MaterialFlags.FresnelEnabled = value;\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.StandardMaterial\"] = StandardMaterial;\r\n\r\nScene.DefaultMaterialFactory = (scene: Scene) => {\r\n    return new StandardMaterial(\"default material\", scene);\r\n};","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'helperFunctions';\nlet shader = `const float PI=3.1415926535897932384626433832795;\nconst float HALF_MIN=5.96046448e-08;\nconst float LinearEncodePowerApprox=2.2;\nconst float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;\nconst vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);\nconst float Epsilon=0.0000001;\n#define saturate(x) clamp(x,0.0,1.0)\n#define absEps(x) abs(x)+Epsilon\n#define maxEps(x) max(x,Epsilon)\n#define saturateEps(x) clamp(x,Epsilon,1.0)\nmat3 transposeMat3(mat3 inMatrix) {\nvec3 i0=inMatrix[0];\nvec3 i1=inMatrix[1];\nvec3 i2=inMatrix[2];\nmat3 outMatrix=mat3(\nvec3(i0.x,i1.x,i2.x),\nvec3(i0.y,i1.y,i2.y),\nvec3(i0.z,i1.z,i2.z)\n);\nreturn outMatrix;\n}\n\nmat3 inverseMat3(mat3 inMatrix) {\nfloat a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];\nfloat a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];\nfloat a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];\nfloat b01=a22*a11-a12*a21;\nfloat b11=-a22*a10+a12*a20;\nfloat b21=a21*a10-a11*a20;\nfloat det=a00*b01+a01*b11+a02*b21;\nreturn mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),\nb11,(a22*a00-a02*a20),(-a12*a00+a02*a10),\nb21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;\n}\nfloat toLinearSpace(float color)\n{\nreturn pow(color,LinearEncodePowerApprox);\n}\nvec3 toLinearSpace(vec3 color)\n{\nreturn pow(color,vec3(LinearEncodePowerApprox));\n}\nvec4 toLinearSpace(vec4 color)\n{\nreturn vec4(pow(color.rgb,vec3(LinearEncodePowerApprox)),color.a);\n}\nvec3 toGammaSpace(vec3 color)\n{\nreturn pow(color,vec3(GammaEncodePowerApprox));\n}\nvec4 toGammaSpace(vec4 color)\n{\nreturn vec4(pow(color.rgb,vec3(GammaEncodePowerApprox)),color.a);\n}\nfloat toGammaSpace(float color)\n{\nreturn pow(color,GammaEncodePowerApprox);\n}\nfloat square(float value)\n{\nreturn value*value;\n}\nfloat pow5(float value) {\nfloat sq=value*value;\nreturn sq*sq*value;\n}\nfloat getLuminance(vec3 color)\n{\nreturn clamp(dot(color,LuminanceEncodeApprox),0.,1.);\n}\n\nfloat getRand(vec2 seed) {\nreturn fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);\n}\nfloat dither(vec2 seed,float varianceAmount) {\nfloat rand=getRand(seed);\nfloat dither=mix(-varianceAmount/255.0,varianceAmount/255.0,rand);\nreturn dither;\n}\n\nconst float rgbdMaxRange=255.0;\nvec4 toRGBD(vec3 color) {\nfloat maxRGB=maxEps(max(color.r,max(color.g,color.b)));\nfloat D=max(rgbdMaxRange/maxRGB,1.);\nD=clamp(floor(D)/255.0,0.,1.);\n\nvec3 rgb=color.rgb*D;\n\nrgb=toGammaSpace(rgb);\nreturn vec4(rgb,D);\n}\nvec3 fromRGBD(vec4 rgbd) {\n\nrgbd.rgb=toLinearSpace(rgbd.rgb);\n\nreturn rgbd.rgb/rgbd.a;\n}\n`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var helperFunctions = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'bonesDeclaration';\nlet shader = `#if NUM_BONE_INFLUENCERS>0\n#ifdef BONETEXTURE\nuniform sampler2D boneSampler;\nuniform float boneTextureWidth;\n#else\nuniform mat4 mBones[BonesPerMesh];\n#endif\nattribute vec4 matricesIndices;\nattribute vec4 matricesWeights;\n#if NUM_BONE_INFLUENCERS>4\nattribute vec4 matricesIndicesExtra;\nattribute vec4 matricesWeightsExtra;\n#endif\n#ifdef BONETEXTURE\n#define inline\nmat4 readMatrixFromRawSampler(sampler2D smp,float index)\n{\nfloat offset=index*4.0;\nfloat dx=1.0/boneTextureWidth;\nvec4 m0=texture2D(smp,vec2(dx*(offset+0.5),0.));\nvec4 m1=texture2D(smp,vec2(dx*(offset+1.5),0.));\nvec4 m2=texture2D(smp,vec2(dx*(offset+2.5),0.));\nvec4 m3=texture2D(smp,vec2(dx*(offset+3.5),0.));\nreturn mat4(m0,m1,m2,m3);\n}\n#endif\n#endif`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var bonesDeclaration = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'instancesDeclaration';\nlet shader = `#ifdef INSTANCES\nattribute vec4 world0;\nattribute vec4 world1;\nattribute vec4 world2;\nattribute vec4 world3;\n#ifdef THIN_INSTANCES\nuniform mat4 world;\n#endif\n#else\nuniform mat4 world;\n#endif`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var instancesDeclaration = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'instancesVertex';\nlet shader = `#ifdef INSTANCES\nmat4 finalWorld=mat4(world0,world1,world2,world3);\n#ifdef THIN_INSTANCES\nfinalWorld=world*finalWorld;\n#endif\n#else\nmat4 finalWorld=world;\n#endif`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var instancesVertex = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'bonesVertex';\nlet shader = `#if NUM_BONE_INFLUENCERS>0\nmat4 influence;\n#ifdef BONETEXTURE\ninfluence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[0])*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[1])*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[2])*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[3])*matricesWeightsExtra[3];\n#endif\n#else\ninfluence=mBones[int(matricesIndices[0])]*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\ninfluence+=mBones[int(matricesIndices[1])]*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\ninfluence+=mBones[int(matricesIndices[2])]*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\ninfluence+=mBones[int(matricesIndices[3])]*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\ninfluence+=mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\ninfluence+=mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\ninfluence+=mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\ninfluence+=mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\n#endif\n#endif\nfinalWorld=finalWorld*influence;\n#endif`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var bonesVertex = { name, shader };\n","import { Engine } from \"../Engines/engine\";\r\n\r\n\r\n/**\r\n * This groups all the flags used to control the materials channel.\r\n */\r\nexport class MaterialFlags {\r\n    // Flags used to enable or disable a type of texture for all Standard Materials\r\n    private static _DiffuseTextureEnabled = true;\r\n    /**\r\n     * Are diffuse textures enabled in the application.\r\n     */\r\n    public static get DiffuseTextureEnabled(): boolean {\r\n        return this._DiffuseTextureEnabled;\r\n    }\r\n    public static set DiffuseTextureEnabled(value: boolean) {\r\n        if (this._DiffuseTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._DiffuseTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(1);\r\n    }\r\n\r\n    private static _DetailTextureEnabled = true;\r\n    /**\r\n     * Are detail textures enabled in the application.\r\n     */\r\n    public static get DetailTextureEnabled(): boolean {\r\n        return this._DetailTextureEnabled;\r\n    }\r\n    public static set DetailTextureEnabled(value: boolean) {\r\n        if (this._DetailTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._DetailTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(1);\r\n    }\r\n\r\n    private static _AmbientTextureEnabled = true;\r\n    /**\r\n     * Are ambient textures enabled in the application.\r\n     */\r\n    public static get AmbientTextureEnabled(): boolean {\r\n        return this._AmbientTextureEnabled;\r\n    }\r\n    public static set AmbientTextureEnabled(value: boolean) {\r\n        if (this._AmbientTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._AmbientTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(1);\r\n    }\r\n\r\n    private static _OpacityTextureEnabled = true;\r\n    /**\r\n     * Are opacity textures enabled in the application.\r\n     */\r\n    public static get OpacityTextureEnabled(): boolean {\r\n        return this._OpacityTextureEnabled;\r\n    }\r\n    public static set OpacityTextureEnabled(value: boolean) {\r\n        if (this._OpacityTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._OpacityTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(1);\r\n    }\r\n\r\n    private static _ReflectionTextureEnabled = true;\r\n    /**\r\n     * Are reflection textures enabled in the application.\r\n     */\r\n    public static get ReflectionTextureEnabled(): boolean {\r\n        return this._ReflectionTextureEnabled;\r\n    }\r\n    public static set ReflectionTextureEnabled(value: boolean) {\r\n        if (this._ReflectionTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._ReflectionTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(1);\r\n    }\r\n\r\n    private static _EmissiveTextureEnabled = true;\r\n    /**\r\n     * Are emissive textures enabled in the application.\r\n     */\r\n    public static get EmissiveTextureEnabled(): boolean {\r\n        return this._EmissiveTextureEnabled;\r\n    }\r\n    public static set EmissiveTextureEnabled(value: boolean) {\r\n        if (this._EmissiveTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._EmissiveTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(1);\r\n    }\r\n\r\n    private static _SpecularTextureEnabled = true;\r\n    /**\r\n     * Are specular textures enabled in the application.\r\n     */\r\n    public static get SpecularTextureEnabled(): boolean {\r\n        return this._SpecularTextureEnabled;\r\n    }\r\n    public static set SpecularTextureEnabled(value: boolean) {\r\n        if (this._SpecularTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._SpecularTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(1);\r\n    }\r\n\r\n    private static _BumpTextureEnabled = true;\r\n    /**\r\n     * Are bump textures enabled in the application.\r\n     */\r\n    public static get BumpTextureEnabled(): boolean {\r\n        return this._BumpTextureEnabled;\r\n    }\r\n    public static set BumpTextureEnabled(value: boolean) {\r\n        if (this._BumpTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._BumpTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(1);\r\n    }\r\n\r\n    private static _LightmapTextureEnabled = true;\r\n    /**\r\n     * Are lightmap textures enabled in the application.\r\n     */\r\n    public static get LightmapTextureEnabled(): boolean {\r\n        return this._LightmapTextureEnabled;\r\n    }\r\n    public static set LightmapTextureEnabled(value: boolean) {\r\n        if (this._LightmapTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._LightmapTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(1);\r\n    }\r\n\r\n    private static _RefractionTextureEnabled = true;\r\n    /**\r\n     * Are refraction textures enabled in the application.\r\n     */\r\n    public static get RefractionTextureEnabled(): boolean {\r\n        return this._RefractionTextureEnabled;\r\n    }\r\n    public static set RefractionTextureEnabled(value: boolean) {\r\n        if (this._RefractionTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._RefractionTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(1);\r\n    }\r\n\r\n    private static _ColorGradingTextureEnabled = true;\r\n    /**\r\n     * Are color grading textures enabled in the application.\r\n     */\r\n    public static get ColorGradingTextureEnabled(): boolean {\r\n        return this._ColorGradingTextureEnabled;\r\n    }\r\n    public static set ColorGradingTextureEnabled(value: boolean) {\r\n        if (this._ColorGradingTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._ColorGradingTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(1);\r\n    }\r\n\r\n    private static _FresnelEnabled = true;\r\n    /**\r\n     * Are fresnels enabled in the application.\r\n     */\r\n    public static get FresnelEnabled(): boolean {\r\n        return this._FresnelEnabled;\r\n    }\r\n    public static set FresnelEnabled(value: boolean) {\r\n        if (this._FresnelEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._FresnelEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(4);\r\n    }\r\n\r\n    private static _ClearCoatTextureEnabled = true;\r\n    /**\r\n     * Are clear coat textures enabled in the application.\r\n     */\r\n    public static get ClearCoatTextureEnabled(): boolean {\r\n        return this._ClearCoatTextureEnabled;\r\n    }\r\n    public static set ClearCoatTextureEnabled(value: boolean) {\r\n        if (this._ClearCoatTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._ClearCoatTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(1);\r\n    }\r\n\r\n    private static _ClearCoatBumpTextureEnabled = true;\r\n    /**\r\n     * Are clear coat bump textures enabled in the application.\r\n     */\r\n    public static get ClearCoatBumpTextureEnabled(): boolean {\r\n        return this._ClearCoatBumpTextureEnabled;\r\n    }\r\n    public static set ClearCoatBumpTextureEnabled(value: boolean) {\r\n        if (this._ClearCoatBumpTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._ClearCoatBumpTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(1);\r\n    }\r\n\r\n    private static _ClearCoatTintTextureEnabled = true;\r\n    /**\r\n     * Are clear coat tint textures enabled in the application.\r\n     */\r\n    public static get ClearCoatTintTextureEnabled(): boolean {\r\n        return this._ClearCoatTintTextureEnabled;\r\n    }\r\n    public static set ClearCoatTintTextureEnabled(value: boolean) {\r\n        if (this._ClearCoatTintTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._ClearCoatTintTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(1);\r\n    }\r\n\r\n    private static _SheenTextureEnabled = true;\r\n    /**\r\n     * Are sheen textures enabled in the application.\r\n     */\r\n    public static get SheenTextureEnabled(): boolean {\r\n        return this._SheenTextureEnabled;\r\n    }\r\n    public static set SheenTextureEnabled(value: boolean) {\r\n        if (this._SheenTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._SheenTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(1);\r\n    }\r\n\r\n    private static _AnisotropicTextureEnabled = true;\r\n    /**\r\n     * Are anisotropic textures enabled in the application.\r\n     */\r\n    public static get AnisotropicTextureEnabled(): boolean {\r\n        return this._AnisotropicTextureEnabled;\r\n    }\r\n    public static set AnisotropicTextureEnabled(value: boolean) {\r\n        if (this._AnisotropicTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._AnisotropicTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(1);\r\n    }\r\n\r\n    private static _ThicknessTextureEnabled = true;\r\n    /**\r\n     * Are thickness textures enabled in the application.\r\n     */\r\n    public static get ThicknessTextureEnabled(): boolean {\r\n        return this._ThicknessTextureEnabled;\r\n    }\r\n    public static set ThicknessTextureEnabled(value: boolean) {\r\n        if (this._ThicknessTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._ThicknessTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(1);\r\n    }\r\n}\r\n","import { SerializationHelper } from \"../Misc/decorators\";\r\nimport { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Matrix, Vector3, Vector2, Vector4 } from \"../Maths/math.vector\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { MaterialHelper } from \"./materialHelper\";\r\nimport { Effect, IEffectCreationOptions } from \"./effect\";\r\nimport { Material } from \"./material\";\r\nimport { _TypeStore } from '../Misc/typeStore';\r\nimport { Color3, Color4 } from '../Maths/math.color';\r\nimport { EffectFallbacks } from './effectFallbacks';\r\nimport { WebRequest } from '../Misc/webRequest';\r\nimport { Engine } from '../Engines/engine';\r\n\r\nconst onCreatedEffectParameters = { effect: null as unknown as Effect, subMesh: null as unknown as Nullable<SubMesh> };\r\n\r\n/**\r\n * Defines the options associated with the creation of a shader material.\r\n */\r\nexport interface IShaderMaterialOptions {\r\n    /**\r\n     * Does the material work in alpha blend mode\r\n     */\r\n    needAlphaBlending: boolean;\r\n\r\n    /**\r\n     * Does the material work in alpha test mode\r\n     */\r\n    needAlphaTesting: boolean;\r\n\r\n    /**\r\n     * The list of attribute names used in the shader\r\n     */\r\n    attributes: string[];\r\n\r\n    /**\r\n     * The list of unifrom names used in the shader\r\n     */\r\n    uniforms: string[];\r\n\r\n    /**\r\n     * The list of UBO names used in the shader\r\n     */\r\n    uniformBuffers: string[];\r\n\r\n    /**\r\n     * The list of sampler names used in the shader\r\n     */\r\n    samplers: string[];\r\n\r\n    /**\r\n     * The list of defines used in the shader\r\n     */\r\n    defines: string[];\r\n}\r\n\r\n/**\r\n * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\r\n *\r\n * This returned material effects how the mesh will look based on the code in the shaders.\r\n *\r\n * @see https://doc.babylonjs.com/how_to/shader_material\r\n */\r\nexport class ShaderMaterial extends Material {\r\n    private _shaderPath: any;\r\n    private _options: IShaderMaterialOptions;\r\n    private _textures: { [name: string]: BaseTexture } = {};\r\n    private _textureArrays: { [name: string]: BaseTexture[] } = {};\r\n    private _floats: { [name: string]: number } = {};\r\n    private _ints: { [name: string]: number } = {};\r\n    private _floatsArrays: { [name: string]: number[] } = {};\r\n    private _colors3: { [name: string]: Color3 } = {};\r\n    private _colors3Arrays: { [name: string]: number[] } = {};\r\n    private _colors4: { [name: string]: Color4 } = {};\r\n    private _colors4Arrays: { [name: string]: number[] } = {};\r\n    private _vectors2: { [name: string]: Vector2 } = {};\r\n    private _vectors3: { [name: string]: Vector3 } = {};\r\n    private _vectors4: { [name: string]: Vector4 } = {};\r\n    private _matrices: { [name: string]: Matrix } = {};\r\n    private _matrixArrays: { [name: string]: Float32Array | Array<number> } = {};\r\n    private _matrices3x3: { [name: string]: Float32Array | Array<number> } = {};\r\n    private _matrices2x2: { [name: string]: Float32Array | Array<number> } = {};\r\n    private _vectors2Arrays: { [name: string]: number[] } = {};\r\n    private _vectors3Arrays: { [name: string]: number[] } = {};\r\n    private _vectors4Arrays: { [name: string]: number[] } = {};\r\n    private _cachedWorldViewMatrix = new Matrix();\r\n    private _cachedWorldViewProjectionMatrix = new Matrix();\r\n    private _renderId: number;\r\n    private _multiview: boolean = false;\r\n    private _cachedDefines: string;\r\n\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = \"https://snippet.babylonjs.com\";\r\n\r\n    /** Snippet ID if the material was created from the snippet server */\r\n    public snippetId: string;\r\n\r\n    /**\r\n     * Instantiate a new shader material.\r\n     * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\r\n     * This returned material effects how the mesh will look based on the code in the shaders.\r\n     * @see https://doc.babylonjs.com/how_to/shader_material\r\n     * @param name Define the name of the material in the scene\r\n     * @param scene Define the scene the material belongs to\r\n     * @param shaderPath Defines  the route to the shader code in one of three ways:\r\n     *  * object: { vertex: \"custom\", fragment: \"custom\" }, used with Effect.ShadersStore[\"customVertexShader\"] and Effect.ShadersStore[\"customFragmentShader\"]\r\n     *  * object: { vertexElement: \"vertexShaderCode\", fragmentElement: \"fragmentShaderCode\" }, used with shader code in script tags\r\n     *  * object: { vertexSource: \"vertex shader code string\", fragmentSource: \"fragment shader code string\" } using with strings containing the shaders code\r\n     *  * string: \"./COMMON_NAME\", used with external files COMMON_NAME.vertex.fx and COMMON_NAME.fragment.fx in index.html folder.\r\n     * @param options Define the options used to create the shader\r\n     */\r\n    constructor(name: string, scene: Scene, shaderPath: any, options: Partial<IShaderMaterialOptions> = {}) {\r\n        super(name, scene);\r\n        this._shaderPath = shaderPath;\r\n\r\n        this._options = {\r\n            needAlphaBlending: false,\r\n            needAlphaTesting: false,\r\n            attributes: [\"position\", \"normal\", \"uv\"],\r\n            uniforms: [\"worldViewProjection\"],\r\n            uniformBuffers: [],\r\n            samplers: [],\r\n            defines: [],\r\n            ...options\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the shader path used to define the shader code\r\n     * It can be modified to trigger a new compilation\r\n     */\r\n    public get shaderPath(): any {\r\n        return this._shaderPath;\r\n    }\r\n\r\n    /**\r\n     * Sets the shader path used to define the shader code\r\n     * It can be modified to trigger a new compilation\r\n     */\r\n    public set shaderPath(shaderPath: any) {\r\n        this._shaderPath = shaderPath;\r\n    }\r\n\r\n    /**\r\n     * Gets the options used to compile the shader.\r\n     * They can be modified to trigger a new compilation\r\n     */\r\n    public get options(): IShaderMaterialOptions {\r\n        return this._options;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"ShaderMaterial\"\r\n     * Mainly use in serialization.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ShaderMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material will require alpha blending\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        return (this.alpha < 1.0) || this._options.needAlphaBlending;\r\n    }\r\n\r\n    /**\r\n     * Specifies if this material should be rendered in alpha test mode\r\n     * @returns a boolean specifying if an alpha test is needed.\r\n     */\r\n    public needAlphaTesting(): boolean {\r\n        return this._options.needAlphaTesting;\r\n    }\r\n\r\n    private _checkUniform(uniformName: string): void {\r\n        if (this._options.uniforms.indexOf(uniformName) === -1) {\r\n            this._options.uniforms.push(uniformName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a texture in the shader.\r\n     * @param name Define the name of the uniform samplers as defined in the shader\r\n     * @param texture Define the texture to bind to this sampler\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTexture(name: string, texture: BaseTexture): ShaderMaterial {\r\n        if (this._options.samplers.indexOf(name) === -1) {\r\n            this._options.samplers.push(name);\r\n        }\r\n        this._textures[name] = texture;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a texture array in the shader.\r\n     * @param name Define the name of the uniform sampler array as defined in the shader\r\n     * @param textures Define the list of textures to bind to this sampler\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTextureArray(name: string, textures: BaseTexture[]): ShaderMaterial {\r\n        if (this._options.samplers.indexOf(name) === -1) {\r\n            this._options.samplers.push(name);\r\n        }\r\n\r\n        this._checkUniform(name);\r\n\r\n        this._textureArrays[name] = textures;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloat(name: string, value: number): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._floats[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a int in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setInt(name: string, value: number): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._ints[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set an array of floats in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloats(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._floatsArrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Color3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3(name: string, value: Color3): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 array in the shader from a Color3 array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3Array(name: string, value: Color3[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors3Arrays[name] = value.reduce((arr, color) => {\r\n            color.toArray(arr, arr.length);\r\n            return arr;\r\n        }, []);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Color4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4(name: string, value: Color4): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 array in the shader from a Color4 array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4Array(name: string, value: Color4[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors4Arrays[name] = value.reduce((arr, color) => {\r\n            color.toArray(arr, arr.length);\r\n            return arr;\r\n        }, []);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 in the shader from a Vector2.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector2(name: string, value: Vector2): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Vector3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector3(name: string, value: Vector3): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Vector4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector4(name: string, value: Vector4): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat4 in the shader from a Matrix.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix(name: string, value: Matrix): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._matrices[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float32Array in the shader from a matrix array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrices(name: string, value: Matrix[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n\r\n        let float32Array = new Float32Array(value.length * 16);\r\n\r\n        for (var index = 0; index < value.length; index++) {\r\n            let matrix = value[index];\r\n\r\n            matrix.copyToArray(float32Array, index * 16);\r\n        }\r\n\r\n        this._matrixArrays[name] = float32Array;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat3 in the shader from a Float32Array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix3x3(name: string, value: Float32Array | Array<number>): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._matrices3x3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat2 in the shader from a Float32Array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix2x2(name: string, value: Float32Array | Array<number>): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._matrices2x2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setArray2(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors2Arrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setArray3(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors3Arrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setArray4(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors4Arrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    private _checkCache(mesh?: AbstractMesh, useInstances?: boolean): boolean {\r\n        if (!mesh) {\r\n            return true;\r\n        }\r\n\r\n        if (this._effect && (this._effect.defines.indexOf(\"#define INSTANCES\") !== -1) !== useInstances) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Specifies that the submesh is ready to be used\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        return this.isReady(mesh, useInstances);\r\n    }\r\n\r\n    /**\r\n     * Checks if the material is ready to render the requested mesh\r\n     * @param mesh Define the mesh to render\r\n     * @param useInstances Define whether or not the material is used with instances\r\n     * @returns true if ready, otherwise false\r\n     */\r\n    public isReady(mesh?: AbstractMesh, useInstances?: boolean): boolean {\r\n        if (this._effect && this.isFrozen) {\r\n            if (this._effect._wasPreviouslyReady) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        var scene = this.getScene();\r\n        var engine = scene.getEngine();\r\n\r\n        if (!this.checkReadyOnEveryCall) {\r\n            if (this._renderId === scene.getRenderId()) {\r\n                if (this._checkCache(mesh, useInstances)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Instances\r\n        var defines = [];\r\n        var attribs = [];\r\n        var fallbacks = new EffectFallbacks();\r\n\r\n        // global multiview\r\n        if (engine.getCaps().multiview &&\r\n            scene.activeCamera &&\r\n            scene.activeCamera.outputRenderTarget &&\r\n            scene.activeCamera.outputRenderTarget.getViewCount() > 1) {\r\n            this._multiview = true;\r\n            defines.push(\"#define MULTIVIEW\");\r\n            if (this._options.uniforms.indexOf(\"viewProjection\") !== -1 &&\r\n                this._options.uniforms.push(\"viewProjectionR\") === -1) {\r\n                this._options.uniforms.push(\"viewProjectionR\");\r\n            }\r\n        }\r\n\r\n        for (var index = 0; index < this._options.defines.length; index++) {\r\n            defines.push(this._options.defines[index]);\r\n        }\r\n\r\n        for (var index = 0; index < this._options.attributes.length; index++) {\r\n            attribs.push(this._options.attributes[index]);\r\n        }\r\n\r\n        if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorKind)) {\r\n            attribs.push(VertexBuffer.ColorKind);\r\n            defines.push(\"#define VERTEXCOLOR\");\r\n        }\r\n\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            MaterialHelper.PushAttributesForInstances(attribs);\r\n            if (mesh?.hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n            }\r\n        }\r\n\r\n        // Bones\r\n        let numInfluencers = 0;\r\n        if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n\r\n            const skeleton = mesh.skeleton;\r\n\r\n            numInfluencers = mesh.numBoneInfluencers;\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + numInfluencers);\r\n            fallbacks.addCPUSkinningFallback(0, mesh);\r\n\r\n            if (skeleton.isUsingTextureForMatrices) {\r\n                defines.push(\"#define BONETEXTURE\");\r\n\r\n                if (this._options.uniforms.indexOf(\"boneTextureWidth\") === -1) {\r\n                    this._options.uniforms.push(\"boneTextureWidth\");\r\n                }\r\n\r\n                if (this._options.samplers.indexOf(\"boneSampler\") === -1) {\r\n                    this._options.samplers.push(\"boneSampler\");\r\n                }\r\n            } else {\r\n                defines.push(\"#define BonesPerMesh \" + (skeleton.bones.length + 1));\r\n\r\n                if (this._options.uniforms.indexOf(\"mBones\") === -1) {\r\n                    this._options.uniforms.push(\"mBones\");\r\n                }\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Textures\r\n        for (var name in this._textures) {\r\n            if (!this._textures[name].isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Alpha test\r\n        if (mesh && this._shouldTurnAlphaTestOn(mesh)) {\r\n            defines.push(\"#define ALPHATEST\");\r\n        }\r\n\r\n        let shaderName = this._shaderPath,\r\n            uniforms = this._options.uniforms,\r\n            uniformBuffers = this._options.uniformBuffers,\r\n            samplers = this._options.samplers;\r\n\r\n        if (this.customShaderNameResolve) {\r\n            uniforms = uniforms.slice();\r\n            uniformBuffers = uniformBuffers.slice();\r\n            samplers = samplers.slice();\r\n            shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs);\r\n        }\r\n\r\n        var previousEffect = this._effect;\r\n        var join = defines.join(\"\\n\");\r\n\r\n        if (this._cachedDefines !== join) {\r\n            this._cachedDefines = join;\r\n\r\n            this._effect = engine.createEffect(shaderName, <IEffectCreationOptions>{\r\n                attributes: attribs,\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: join,\r\n                fallbacks: fallbacks,\r\n                onCompiled: this.onCompiled,\r\n                onError: this.onError,\r\n                indexParameters: { maxSimultaneousMorphTargets: numInfluencers }\r\n            }, engine);\r\n\r\n            if (this._onEffectCreatedObservable) {\r\n                onCreatedEffectParameters.effect = this._effect;\r\n                this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\r\n            }\r\n        }\r\n\r\n        if (!this._effect?.isReady() ?? true) {\r\n            return false;\r\n        }\r\n\r\n        if (previousEffect !== this._effect) {\r\n            scene.resetCachedMaterial();\r\n        }\r\n\r\n        this._renderId = scene.getRenderId();\r\n        this._effect._wasPreviouslyReady = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Binds the world matrix to the material\r\n     * @param world defines the world transformation matrix\r\n     * @param effectOverride - If provided, use this effect instead of internal effect\r\n     */\r\n    public bindOnlyWorldMatrix(world: Matrix, effectOverride?: Nullable<Effect>): void {\r\n        var scene = this.getScene();\r\n\r\n        const effect = effectOverride ?? this._effect;\r\n\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        if (this._options.uniforms.indexOf(\"world\") !== -1) {\r\n            effect.setMatrix(\"world\", world);\r\n        }\r\n\r\n        if (this._options.uniforms.indexOf(\"worldView\") !== -1) {\r\n            world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);\r\n            effect.setMatrix(\"worldView\", this._cachedWorldViewMatrix);\r\n        }\r\n\r\n        if (this._options.uniforms.indexOf(\"worldViewProjection\") !== -1) {\r\n            world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);\r\n            effect.setMatrix(\"worldViewProjection\", this._cachedWorldViewProjectionMatrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to this material by preparing the effect and shader to draw\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        this.bind(world, mesh, subMesh._effectOverride);\r\n    }\r\n\r\n    /**\r\n     * Binds the material to the mesh\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh to bind the material to\r\n     * @param effectOverride - If provided, use this effect instead of internal effect\r\n     */\r\n    public bind(world: Matrix, mesh?: Mesh, effectOverride?: Nullable<Effect>): void {\r\n        // Std values\r\n        this.bindOnlyWorldMatrix(world, effectOverride);\r\n\r\n        const effect = effectOverride ?? this._effect;\r\n\r\n        if (effect && this.getScene().getCachedMaterial() !== this) {\r\n            if (this._options.uniforms.indexOf(\"view\") !== -1) {\r\n                effect.setMatrix(\"view\", this.getScene().getViewMatrix());\r\n            }\r\n\r\n            if (this._options.uniforms.indexOf(\"projection\") !== -1) {\r\n                effect.setMatrix(\"projection\", this.getScene().getProjectionMatrix());\r\n            }\r\n\r\n            if (this._options.uniforms.indexOf(\"viewProjection\") !== -1) {\r\n                effect.setMatrix(\"viewProjection\", this.getScene().getTransformMatrix());\r\n                if (this._multiview) {\r\n                    effect.setMatrix(\"viewProjectionR\", this.getScene()._transformMatrixR);\r\n                }\r\n            }\r\n\r\n            if (this.getScene().activeCamera && this._options.uniforms.indexOf(\"cameraPosition\") !== -1) {\r\n                effect.setVector3(\"cameraPosition\", this.getScene().activeCamera!.globalPosition);\r\n            }\r\n\r\n            // Bones\r\n            MaterialHelper.BindBonesParameters(mesh, effect);\r\n\r\n            var name: string;\r\n            // Texture\r\n            for (name in this._textures) {\r\n                effect.setTexture(name, this._textures[name]);\r\n            }\r\n\r\n            // Texture arrays\r\n            for (name in this._textureArrays) {\r\n                effect.setTextureArray(name, this._textureArrays[name]);\r\n            }\r\n\r\n            // Int\r\n            for (name in this._ints) {\r\n                effect.setInt(name, this._ints[name]);\r\n            }\r\n\r\n            // Float\r\n            for (name in this._floats) {\r\n                effect.setFloat(name, this._floats[name]);\r\n            }\r\n\r\n            // Floats\r\n            for (name in this._floatsArrays) {\r\n                effect.setArray(name, this._floatsArrays[name]);\r\n            }\r\n\r\n            // Color3\r\n            for (name in this._colors3) {\r\n                effect.setColor3(name, this._colors3[name]);\r\n            }\r\n\r\n            // Color3Array\r\n            for (name in this._colors3Arrays) {\r\n                effect.setArray3(name, this._colors3Arrays[name]);\r\n            }\r\n\r\n            // Color4\r\n            for (name in this._colors4) {\r\n                var color = this._colors4[name];\r\n                effect.setFloat4(name, color.r, color.g, color.b, color.a);\r\n            }\r\n\r\n            // Color4Array\r\n            for (name in this._colors4Arrays) {\r\n                effect.setArray4(name, this._colors4Arrays[name]);\r\n            }\r\n\r\n            // Vector2\r\n            for (name in this._vectors2) {\r\n                effect.setVector2(name, this._vectors2[name]);\r\n            }\r\n\r\n            // Vector3\r\n            for (name in this._vectors3) {\r\n                effect.setVector3(name, this._vectors3[name]);\r\n            }\r\n\r\n            // Vector4\r\n            for (name in this._vectors4) {\r\n                effect.setVector4(name, this._vectors4[name]);\r\n            }\r\n\r\n            // Matrix\r\n            for (name in this._matrices) {\r\n                effect.setMatrix(name, this._matrices[name]);\r\n            }\r\n\r\n            // MatrixArray\r\n            for (name in this._matrixArrays) {\r\n                effect.setMatrices(name, this._matrixArrays[name]);\r\n            }\r\n\r\n            // Matrix 3x3\r\n            for (name in this._matrices3x3) {\r\n                effect.setMatrix3x3(name, this._matrices3x3[name]);\r\n            }\r\n\r\n            // Matrix 2x2\r\n            for (name in this._matrices2x2) {\r\n                effect.setMatrix2x2(name, this._matrices2x2[name]);\r\n            }\r\n\r\n            // Vector2Array\r\n            for (name in this._vectors2Arrays) {\r\n                effect.setArray2(name, this._vectors2Arrays[name]);\r\n            }\r\n\r\n            // Vector3Array\r\n            for (name in this._vectors3Arrays) {\r\n                effect.setArray3(name, this._vectors3Arrays[name]);\r\n            }\r\n\r\n            // Vector4Array\r\n            for (name in this._vectors4Arrays) {\r\n                effect.setArray4(name, this._vectors4Arrays[name]);\r\n            }\r\n        }\r\n\r\n        const seffect = this._effect;\r\n\r\n        this._effect = effect; // make sure the active effect is the right one if there are some observers for onBind that would need to get the current effect\r\n        this._afterBind(mesh);\r\n        this._effect = seffect;\r\n    }\r\n\r\n    protected _afterBind(mesh?: Mesh): void {\r\n        super._afterBind(mesh);\r\n        this.getScene()._cachedEffect = this._effect;\r\n    }\r\n\r\n    /**\r\n     * Gets the active textures from the material\r\n     * @returns an array of textures\r\n     */\r\n    public getActiveTextures(): BaseTexture[] {\r\n        var activeTextures = super.getActiveTextures();\r\n\r\n        for (var name in this._textures) {\r\n            activeTextures.push(this._textures[name]);\r\n        }\r\n\r\n        for (var name in this._textureArrays) {\r\n            var array = this._textureArrays[name];\r\n            for (var index = 0; index < array.length; index++) {\r\n                activeTextures.push(array[index]);\r\n            }\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material uses a texture\r\n     * @param texture defines the texture to check against the material\r\n     * @returns a boolean specifying if the material uses the texture\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        for (var name in this._textures) {\r\n            if (this._textures[name] === texture) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        for (var name in this._textureArrays) {\r\n            var array = this._textureArrays[name];\r\n            for (var index = 0; index < array.length; index++) {\r\n                if (array[index] === texture) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the material, and gives it a new name\r\n     * @param name defines the new name for the duplicated material\r\n     * @returns the cloned material\r\n     */\r\n    public clone(name: string): ShaderMaterial {\r\n        var result = SerializationHelper.Clone(() => new ShaderMaterial(name, this.getScene(), this._shaderPath, this._options), this);\r\n\r\n        result.name = name;\r\n        result.id = name;\r\n\r\n        // Shader code path\r\n        if (typeof result._shaderPath === 'object') {\r\n            result._shaderPath = { ...result._shaderPath };\r\n        }\r\n\r\n        // Options\r\n        this._options = { ...this._options };\r\n\r\n        (Object.keys(this._options) as Array<keyof IShaderMaterialOptions>).forEach((propName) => {\r\n            const propValue = this._options[propName];\r\n            if (Array.isArray(propValue)) {\r\n                (<string[]>this._options[propName]) = propValue.slice(0);\r\n            }\r\n        });\r\n\r\n        // Texture\r\n        for (var key in this._textures) {\r\n            result.setTexture(key, this._textures[key]);\r\n        }\r\n\r\n        // Float\r\n        for (var key in this._floats) {\r\n            result.setFloat(key, this._floats[key]);\r\n        }\r\n\r\n        // Floats\r\n        for (var key in this._floatsArrays) {\r\n            result.setFloats(key, this._floatsArrays[key]);\r\n        }\r\n\r\n        // Color3\r\n        for (var key in this._colors3) {\r\n            result.setColor3(key, this._colors3[key]);\r\n        }\r\n\r\n        // Color4\r\n        for (var key in this._colors4) {\r\n            result.setColor4(key, this._colors4[key]);\r\n        }\r\n\r\n        // Vector2\r\n        for (var key in this._vectors2) {\r\n            result.setVector2(key, this._vectors2[key]);\r\n        }\r\n\r\n        // Vector3\r\n        for (var key in this._vectors3) {\r\n            result.setVector3(key, this._vectors3[key]);\r\n        }\r\n\r\n        // Vector4\r\n        for (var key in this._vectors4) {\r\n            result.setVector4(key, this._vectors4[key]);\r\n        }\r\n\r\n        // Matrix\r\n        for (var key in this._matrices) {\r\n            result.setMatrix(key,  this._matrices[key]);\r\n        }\r\n\r\n        // Matrix 3x3\r\n        for (var key in this._matrices3x3) {\r\n            result.setMatrix3x3(key, this._matrices3x3[key]);\r\n        }\r\n\r\n        // Matrix 2x2\r\n        for (var key in this._matrices2x2) {\r\n            result.setMatrix2x2(key, this._matrices2x2[key]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Disposes the material\r\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n     * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean): void {\r\n\r\n        if (forceDisposeTextures) {\r\n            var name: string;\r\n            for (name in this._textures) {\r\n                this._textures[name].dispose();\r\n            }\r\n\r\n            for (name in this._textureArrays) {\r\n                var array = this._textureArrays[name];\r\n                for (var index = 0; index < array.length; index++) {\r\n                    array[index].dispose();\r\n                }\r\n            }\r\n        }\r\n\r\n        this._textures = {};\r\n\r\n        super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\r\n    }\r\n\r\n    /**\r\n     * Serializes this material in a JSON representation\r\n     * @returns the serialized material object\r\n     */\r\n    public serialize(): any {\r\n        var serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.ShaderMaterial\";\r\n\r\n        serializationObject.options = this._options;\r\n        serializationObject.shaderPath = this._shaderPath;\r\n\r\n        var name: string;\r\n\r\n        // Texture\r\n        serializationObject.textures = {};\r\n        for (name in this._textures) {\r\n            serializationObject.textures[name] = this._textures[name].serialize();\r\n        }\r\n\r\n        // Texture arrays\r\n        serializationObject.textureArrays = {};\r\n        for (name in this._textureArrays) {\r\n            serializationObject.textureArrays[name] = [];\r\n            var array = this._textureArrays[name];\r\n            for (var index = 0; index < array.length; index++) {\r\n                serializationObject.textureArrays[name].push(array[index].serialize());\r\n            }\r\n        }\r\n\r\n        // Float\r\n        serializationObject.floats = {};\r\n        for (name in this._floats) {\r\n            serializationObject.floats[name] = this._floats[name];\r\n        }\r\n\r\n        // Floats\r\n        serializationObject.FloatArrays = {};\r\n        for (name in this._floatsArrays) {\r\n            serializationObject.FloatArrays[name] = this._floatsArrays[name];\r\n        }\r\n\r\n        // Color3\r\n        serializationObject.colors3 = {};\r\n        for (name in this._colors3) {\r\n            serializationObject.colors3[name] = this._colors3[name].asArray();\r\n        }\r\n\r\n        // Color3 array\r\n        serializationObject.colors3Arrays = {};\r\n        for (name in this._colors3Arrays) {\r\n            serializationObject.colors3Arrays[name] = this._colors3Arrays[name];\r\n        }\r\n\r\n        // Color4\r\n        serializationObject.colors4 = {};\r\n        for (name in this._colors4) {\r\n            serializationObject.colors4[name] = this._colors4[name].asArray();\r\n        }\r\n\r\n        // Color4 array\r\n        serializationObject.colors4Arrays = {};\r\n        for (name in this._colors4Arrays) {\r\n            serializationObject.colors4Arrays[name] = this._colors4Arrays[name];\r\n        }\r\n\r\n        // Vector2\r\n        serializationObject.vectors2 = {};\r\n        for (name in this._vectors2) {\r\n            serializationObject.vectors2[name] = this._vectors2[name].asArray();\r\n        }\r\n\r\n        // Vector3\r\n        serializationObject.vectors3 = {};\r\n        for (name in this._vectors3) {\r\n            serializationObject.vectors3[name] = this._vectors3[name].asArray();\r\n        }\r\n\r\n        // Vector4\r\n        serializationObject.vectors4 = {};\r\n        for (name in this._vectors4) {\r\n            serializationObject.vectors4[name] = this._vectors4[name].asArray();\r\n        }\r\n\r\n        // Matrix\r\n        serializationObject.matrices = {};\r\n        for (name in this._matrices) {\r\n            serializationObject.matrices[name] = this._matrices[name].asArray();\r\n        }\r\n\r\n        // MatrixArray\r\n        serializationObject.matrixArray = {};\r\n        for (name in this._matrixArrays) {\r\n            serializationObject.matrixArray[name] = this._matrixArrays[name];\r\n        }\r\n\r\n        // Matrix 3x3\r\n        serializationObject.matrices3x3 = {};\r\n        for (name in this._matrices3x3) {\r\n            serializationObject.matrices3x3[name] = this._matrices3x3[name];\r\n        }\r\n\r\n        // Matrix 2x2\r\n        serializationObject.matrices2x2 = {};\r\n        for (name in this._matrices2x2) {\r\n            serializationObject.matrices2x2[name] = this._matrices2x2[name];\r\n        }\r\n\r\n        // Vector2Array\r\n        serializationObject.vectors2Arrays = {};\r\n        for (name in this._vectors2Arrays) {\r\n            serializationObject.vectors2Arrays[name] = this._vectors2Arrays[name];\r\n        }\r\n\r\n        // Vector3Array\r\n        serializationObject.vectors3Arrays = {};\r\n        for (name in this._vectors3Arrays) {\r\n            serializationObject.vectors3Arrays[name] = this._vectors3Arrays[name];\r\n        }\r\n\r\n        // Vector4Array\r\n        serializationObject.vectors4Arrays = {};\r\n        for (name in this._vectors4Arrays) {\r\n            serializationObject.vectors4Arrays[name] = this._vectors4Arrays[name];\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a shader material from parsed shader material data\r\n     * @param source defines the JSON represnetation of the material\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a new material\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): ShaderMaterial {\r\n        var material = SerializationHelper.Parse(() => new ShaderMaterial(source.name, scene, source.shaderPath, source.options), source, scene, rootUrl);\r\n\r\n        var name: string;\r\n\r\n        // Texture\r\n        for (name in source.textures) {\r\n            material.setTexture(name, <Texture>Texture.Parse(source.textures[name], scene, rootUrl));\r\n        }\r\n\r\n        // Texture arrays\r\n        for (name in source.textureArrays) {\r\n            var array = source.textureArrays[name];\r\n            var textureArray = new Array<Texture>();\r\n\r\n            for (var index = 0; index < array.length; index++) {\r\n                textureArray.push(<Texture>Texture.Parse(array[index], scene, rootUrl));\r\n            }\r\n            material.setTextureArray(name, textureArray);\r\n        }\r\n\r\n        // Float\r\n        for (name in source.floats) {\r\n            material.setFloat(name, source.floats[name]);\r\n        }\r\n\r\n        // Float s\r\n        for (name in source.floatsArrays) {\r\n            material.setFloats(name, source.floatsArrays[name]);\r\n        }\r\n\r\n        // Color3\r\n        for (name in source.colors3) {\r\n            material.setColor3(name, Color3.FromArray(source.colors3[name]));\r\n        }\r\n\r\n        // Color3 arrays\r\n        for (name in source.colors3Arrays) {\r\n            const colors: Color3[] = source.colors3Arrays[name].reduce((arr: Array<Array<number>>, num: number, i: number) => {\r\n                if (i % 3 === 0) {\r\n                    arr.push([num]);\r\n                } else {\r\n                    arr[arr.length - 1].push(num);\r\n                }\r\n                return arr;\r\n            }, []).map((color: ArrayLike<number>) => Color3.FromArray(color));\r\n            material.setColor3Array(name, colors);\r\n        }\r\n\r\n        // Color4\r\n        for (name in source.colors4) {\r\n            material.setColor4(name, Color4.FromArray(source.colors4[name]));\r\n        }\r\n\r\n        // Color4 arrays\r\n        for (name in source.colors4Arrays) {\r\n            const colors: Color4[] = source.colors4Arrays[name].reduce((arr: Array<Array<number>>, num: number, i: number) => {\r\n                if (i % 4 === 0) {\r\n                    arr.push([num]);\r\n                } else {\r\n                    arr[arr.length - 1].push(num);\r\n                }\r\n                return arr;\r\n            }, []).map((color: ArrayLike<number>) => Color4.FromArray(color));\r\n            material.setColor4Array(name, colors);\r\n        }\r\n\r\n        // Vector2\r\n        for (name in source.vectors2) {\r\n            material.setVector2(name, Vector2.FromArray(source.vectors2[name]));\r\n        }\r\n\r\n        // Vector3\r\n        for (name in source.vectors3) {\r\n            material.setVector3(name, Vector3.FromArray(source.vectors3[name]));\r\n        }\r\n\r\n        // Vector4\r\n        for (name in source.vectors4) {\r\n            material.setVector4(name, Vector4.FromArray(source.vectors4[name]));\r\n        }\r\n\r\n        // Matrix\r\n        for (name in source.matrices) {\r\n            material.setMatrix(name, Matrix.FromArray(source.matrices[name]));\r\n        }\r\n\r\n        // MatrixArray\r\n        for (name in source.matrixArray) {\r\n            material._matrixArrays[name] = new Float32Array(source.matrixArray[name]);\r\n        }\r\n\r\n        // Matrix 3x3\r\n        for (name in source.matrices3x3) {\r\n            material.setMatrix3x3(name, source.matrices3x3[name]);\r\n        }\r\n\r\n        // Matrix 2x2\r\n        for (name in source.matrices2x2) {\r\n            material.setMatrix2x2(name, source.matrices2x2[name]);\r\n        }\r\n\r\n        // Vector2Array\r\n        for (name in source.vectors2Arrays) {\r\n            material.setArray2(name, source.vectors2Arrays[name]);\r\n        }\r\n\r\n        // Vector3Array\r\n        for (name in source.vectors3Arrays) {\r\n            material.setArray3(name, source.vectors3Arrays[name]);\r\n        }\r\n\r\n        // Vector4Array\r\n        for (name in source.vectors4Arrays) {\r\n            material.setArray4(name, source.vectors4Arrays[name]);\r\n        }\r\n\r\n        return material;\r\n    }\r\n\r\n    /**\r\n     * Creates a new ShaderMaterial from a snippet saved in a remote file\r\n     * @param name defines the name of the ShaderMaterial to create (can be null or empty to use the one from the json data)\r\n     * @param url defines the url to load from\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new ShaderMaterial\r\n     */\r\n    public static ParseFromFileAsync(name: Nullable<string>, url: string, scene: Scene, rootUrl: string = \"\"): Promise<ShaderMaterial> {\r\n\r\n        return new Promise((resolve, reject) => {\r\n            var request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        let serializationObject = JSON.parse(request.responseText);\r\n                        let output = this.Parse(serializationObject, scene || Engine.LastCreatedScene, rootUrl);\r\n\r\n                        if (name) {\r\n                            output.name = name;\r\n                        }\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the ShaderMaterial\");\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", url);\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a ShaderMaterial from a snippet saved by the Inspector\r\n     * @param snippetId defines the snippet to load\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new ShaderMaterial\r\n     */\r\n    public static CreateFromSnippetAsync(snippetId: string, scene: Scene, rootUrl: string = \"\"): Promise<ShaderMaterial> {\r\n        return new Promise((resolve, reject) => {\r\n            var request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        var snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n                        let serializationObject = JSON.parse(snippet.shaderMaterial);\r\n                        let output = this.Parse(serializationObject, scene || Engine.LastCreatedScene, rootUrl);\r\n\r\n                        output.snippetId = snippetId;\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.ShaderMaterial\"] = ShaderMaterial;\r\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'morphTargetsVertexGlobalDeclaration';\nlet shader = `#ifdef MORPHTARGETS\nuniform float morphTargetInfluences[NUM_MORPH_INFLUENCERS];\n#endif`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var morphTargetsVertexGlobalDeclaration = { name, shader };\n","import { Effect } from \"../../Materials/effect\";\n\nlet name = 'morphTargetsVertexDeclaration';\nlet shader = `#ifdef MORPHTARGETS\nattribute vec3 position{X};\n#ifdef MORPHTARGETS_NORMAL\nattribute vec3 normal{X};\n#endif\n#ifdef MORPHTARGETS_TANGENT\nattribute vec3 tangent{X};\n#endif\n#ifdef MORPHTARGETS_UV\nattribute vec2 uv_{X};\n#endif\n#endif`;\n\nEffect.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var morphTargetsVertexDeclaration = { name, shader };\n","import { Nullable } from '../types';\r\nimport { IEffectFallbacks } from './iEffectFallbacks';\r\n\r\ndeclare type Effect = import(\"./effect\").Effect;\r\ndeclare type AbstractMesh = import(\"../Meshes/abstractMesh\").AbstractMesh;\r\n\r\n/**\r\n * EffectFallbacks can be used to add fallbacks (properties to disable) to certain properties when desired to improve performance.\r\n * (Eg. Start at high quality with reflection and fog, if fps is low, remove reflection, if still low remove fog)\r\n */\r\nexport class EffectFallbacks implements IEffectFallbacks {\r\n    private _defines: { [key: string]: Array<String> } = {};\r\n\r\n    private _currentRank = 32;\r\n    private _maxRank = -1;\r\n\r\n    private _mesh: Nullable<AbstractMesh> = null;\r\n\r\n    /**\r\n     * Removes the fallback from the bound mesh.\r\n     */\r\n    public unBindMesh() {\r\n        this._mesh = null;\r\n    }\r\n\r\n    /**\r\n     * Adds a fallback on the specified property.\r\n     * @param rank The rank of the fallback (Lower ranks will be fallbacked to first)\r\n     * @param define The name of the define in the shader\r\n     */\r\n    public addFallback(rank: number, define: string): void {\r\n        if (!this._defines[rank]) {\r\n            if (rank < this._currentRank) {\r\n                this._currentRank = rank;\r\n            }\r\n\r\n            if (rank > this._maxRank) {\r\n                this._maxRank = rank;\r\n            }\r\n\r\n            this._defines[rank] = new Array<String>();\r\n        }\r\n\r\n        this._defines[rank].push(define);\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh to use CPU skinning when needing to fallback.\r\n     * @param rank The rank of the fallback (Lower ranks will be fallbacked to first)\r\n     * @param mesh The mesh to use the fallbacks.\r\n     */\r\n    public addCPUSkinningFallback(rank: number, mesh: AbstractMesh) {\r\n        this._mesh = mesh;\r\n\r\n        if (rank < this._currentRank) {\r\n            this._currentRank = rank;\r\n        }\r\n        if (rank > this._maxRank) {\r\n            this._maxRank = rank;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks to see if more fallbacks are still availible.\r\n     */\r\n    public get hasMoreFallbacks(): boolean {\r\n        return this._currentRank <= this._maxRank;\r\n    }\r\n\r\n    /**\r\n     * Removes the defines that should be removed when falling back.\r\n     * @param currentDefines defines the current define statements for the shader.\r\n     * @param effect defines the current effect we try to compile\r\n     * @returns The resulting defines with defines of the current rank removed.\r\n     */\r\n    public reduce(currentDefines: string, effect: Effect): string {\r\n        // First we try to switch to CPU skinning\r\n        if (this._mesh && this._mesh.computeBonesUsingShaders && this._mesh.numBoneInfluencers > 0) {\r\n            this._mesh.computeBonesUsingShaders = false;\r\n            currentDefines = currentDefines.replace(\"#define NUM_BONE_INFLUENCERS \" + this._mesh.numBoneInfluencers, \"#define NUM_BONE_INFLUENCERS 0\");\r\n            effect._bonesComputationForcedToCPU = true;\r\n\r\n            var scene = this._mesh.getScene();\r\n            for (var index = 0; index < scene.meshes.length; index++) {\r\n                var otherMesh = scene.meshes[index];\r\n\r\n                if (!otherMesh.material) {\r\n                    if (!this._mesh.material && otherMesh.computeBonesUsingShaders && otherMesh.numBoneInfluencers > 0) {\r\n                        otherMesh.computeBonesUsingShaders = false;\r\n                    }\r\n                    continue;\r\n                }\r\n\r\n                if (!otherMesh.computeBonesUsingShaders || otherMesh.numBoneInfluencers === 0) {\r\n                    continue;\r\n                }\r\n\r\n                if (otherMesh.material.getEffect() === effect) {\r\n                    otherMesh.computeBonesUsingShaders = false;\r\n                } else if (otherMesh.subMeshes) {\r\n                    for (var subMesh of otherMesh.subMeshes) {\r\n                        let subMeshEffect = subMesh.effect;\r\n\r\n                        if (subMeshEffect === effect) {\r\n                            otherMesh.computeBonesUsingShaders = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var currentFallbacks = this._defines[this._currentRank];\r\n            if (currentFallbacks) {\r\n                for (var index = 0; index < currentFallbacks.length; index++) {\r\n                    currentDefines = currentDefines.replace(\"#define \" + currentFallbacks[index], \"\");\r\n                }\r\n            }\r\n\r\n            this._currentRank++;\r\n        }\r\n\r\n        return currentDefines;\r\n    }\r\n}"],"sourceRoot":""}